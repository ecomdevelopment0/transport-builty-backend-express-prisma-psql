/**
 * Client
 **/

import * as runtime from "./runtime/library.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model admins
 *
 */
export type admins = $Result.DefaultSelection<Prisma.$adminsPayload>;
/**
 * Model blacklists
 *
 */
export type blacklists = $Result.DefaultSelection<Prisma.$blacklistsPayload>;
/**
 * Model customers
 *
 */
export type customers = $Result.DefaultSelection<Prisma.$customersPayload>;
/**
 * Model firms
 *
 */
export type firms = $Result.DefaultSelection<Prisma.$firmsPayload>;
/**
 * Model owners
 *
 */
export type owners = $Result.DefaultSelection<Prisma.$ownersPayload>;
/**
 * Model payment_collections
 *
 */
export type payment_collections = $Result.DefaultSelection<Prisma.$payment_collectionsPayload>;
/**
 * Model payment_modes
 *
 */
export type payment_modes = $Result.DefaultSelection<Prisma.$payment_modesPayload>;
/**
 * Model prefixes
 *
 */
export type prefixes = $Result.DefaultSelection<Prisma.$prefixesPayload>;
/**
 * Model products
 *
 */
export type products = $Result.DefaultSelection<Prisma.$productsPayload>;
/**
 * Model provider_configurations
 *
 */
export type provider_configurations = $Result.DefaultSelection<Prisma.$provider_configurationsPayload>;
/**
 * Model rentals
 *
 */
export type rentals = $Result.DefaultSelection<Prisma.$rentalsPayload>;
/**
 * Model settings
 *
 */
export type settings = $Result.DefaultSelection<Prisma.$settingsPayload>;
/**
 * Model subscriptions
 *
 */
export type subscriptions = $Result.DefaultSelection<Prisma.$subscriptionsPayload>;
/**
 * Model templates
 *
 */
export type templates = $Result.DefaultSelection<Prisma.$templatesPayload>;
/**
 * Model terms_and_conditions
 *
 */
export type terms_and_conditions = $Result.DefaultSelection<Prisma.$terms_and_conditionsPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const Period: {
    per_hour: "per_hour";
    per_day: "per_day";
    per_week: "per_week";
    per_month: "per_month";
    per_year: "per_year";
  };

  export type Period = (typeof Period)[keyof typeof Period];

  export const Status: {
    available: "available";
    unavailable: "unavailable";
    rented: "rented";
  };

  export type Status = (typeof Status)[keyof typeof Status];

  export const InvoiceStatus: {
    paid: "paid";
    unpaid: "unpaid";
    partially_paid: "partially_paid";
    overdue: "overdue";
  };

  export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus];
}

export type Period = $Enums.Period;

export const Period: typeof $Enums.Period;

export type Status = $Enums.Status;

export const Status: typeof $Enums.Status;

export type InvoiceStatus = $Enums.InvoiceStatus;

export const InvoiceStatus: typeof $Enums.InvoiceStatus;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admins.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admins.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: { maxWait?: number; timeout?: number; isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.admins`: Exposes CRUD operations for the **admins** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Admins
   * const admins = await prisma.admins.findMany()
   * ```
   */
  get admins(): Prisma.adminsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blacklists`: Exposes CRUD operations for the **blacklists** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Blacklists
   * const blacklists = await prisma.blacklists.findMany()
   * ```
   */
  get blacklists(): Prisma.blacklistsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **customers** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Customers
   * const customers = await prisma.customers.findMany()
   * ```
   */
  get customers(): Prisma.customersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.firms`: Exposes CRUD operations for the **firms** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Firms
   * const firms = await prisma.firms.findMany()
   * ```
   */
  get firms(): Prisma.firmsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.owners`: Exposes CRUD operations for the **owners** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Owners
   * const owners = await prisma.owners.findMany()
   * ```
   */
  get owners(): Prisma.ownersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_collections`: Exposes CRUD operations for the **payment_collections** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Payment_collections
   * const payment_collections = await prisma.payment_collections.findMany()
   * ```
   */
  get payment_collections(): Prisma.payment_collectionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment_modes`: Exposes CRUD operations for the **payment_modes** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Payment_modes
   * const payment_modes = await prisma.payment_modes.findMany()
   * ```
   */
  get payment_modes(): Prisma.payment_modesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prefixes`: Exposes CRUD operations for the **prefixes** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Prefixes
   * const prefixes = await prisma.prefixes.findMany()
   * ```
   */
  get prefixes(): Prisma.prefixesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Products
   * const products = await prisma.products.findMany()
   * ```
   */
  get products(): Prisma.productsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider_configurations`: Exposes CRUD operations for the **provider_configurations** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Provider_configurations
   * const provider_configurations = await prisma.provider_configurations.findMany()
   * ```
   */
  get provider_configurations(): Prisma.provider_configurationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rentals`: Exposes CRUD operations for the **rentals** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Rentals
   * const rentals = await prisma.rentals.findMany()
   * ```
   */
  get rentals(): Prisma.rentalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **settings** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Settings
   * const settings = await prisma.settings.findMany()
   * ```
   */
  get settings(): Prisma.settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **subscriptions** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Subscriptions
   * const subscriptions = await prisma.subscriptions.findMany()
   * ```
   */
  get subscriptions(): Prisma.subscriptionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.templates`: Exposes CRUD operations for the **templates** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Templates
   * const templates = await prisma.templates.findMany()
   * ```
   */
  get templates(): Prisma.templatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.terms_and_conditions`: Exposes CRUD operations for the **terms_and_conditions** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Terms_and_conditions
   * const terms_and_conditions = await prisma.terms_and_conditions.findMany()
   * ```
   */
  get terms_and_conditions(): Prisma.terms_and_conditionsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object ? (U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : U) : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ? (K extends keyof O ? { [P in K]: O[P] } & O : O) | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<T, U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">> = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<"OR", K>, Extends<"AND", K>>, Extends<"NOT", K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>;

  export const ModelName: {
    admins: "admins";
    blacklists: "blacklists";
    customers: "customers";
    firms: "firms";
    owners: "owners";
    payment_collections: "payment_collections";
    payment_modes: "payment_modes";
    prefixes: "prefixes";
    products: "products";
    provider_configurations: "provider_configurations";
    rentals: "rentals";
    settings: "settings";
    subscriptions: "subscriptions";
    templates: "templates";
    terms_and_conditions: "terms_and_conditions";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "admins"
        | "blacklists"
        | "customers"
        | "firms"
        | "owners"
        | "payment_collections"
        | "payment_modes"
        | "prefixes"
        | "products"
        | "provider_configurations"
        | "rentals"
        | "settings"
        | "subscriptions"
        | "templates"
        | "terms_and_conditions";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      admins: {
        payload: Prisma.$adminsPayload<ExtArgs>;
        fields: Prisma.adminsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.adminsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$adminsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.adminsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>;
          };
          findFirst: {
            args: Prisma.adminsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$adminsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.adminsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>;
          };
          findMany: {
            args: Prisma.adminsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>[];
          };
          create: {
            args: Prisma.adminsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>;
          };
          createMany: {
            args: Prisma.adminsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.adminsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>[];
          };
          delete: {
            args: Prisma.adminsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>;
          };
          update: {
            args: Prisma.adminsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>;
          };
          deleteMany: {
            args: Prisma.adminsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.adminsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.adminsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>[];
          };
          upsert: {
            args: Prisma.adminsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$adminsPayload>;
          };
          aggregate: {
            args: Prisma.AdminsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAdmins>;
          };
          groupBy: {
            args: Prisma.adminsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AdminsGroupByOutputType>[];
          };
          count: {
            args: Prisma.adminsCountArgs<ExtArgs>;
            result: $Utils.Optional<AdminsCountAggregateOutputType> | number;
          };
        };
      };
      blacklists: {
        payload: Prisma.$blacklistsPayload<ExtArgs>;
        fields: Prisma.blacklistsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.blacklistsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$blacklistsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.blacklistsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$blacklistsPayload>;
          };
          findFirst: {
            args: Prisma.blacklistsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$blacklistsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.blacklistsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$blacklistsPayload>;
          };
          findMany: {
            args: Prisma.blacklistsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$blacklistsPayload>[];
          };
          create: {
            args: Prisma.blacklistsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$blacklistsPayload>;
          };
          createMany: {
            args: Prisma.blacklistsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.blacklistsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$blacklistsPayload>[];
          };
          delete: {
            args: Prisma.blacklistsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$blacklistsPayload>;
          };
          update: {
            args: Prisma.blacklistsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$blacklistsPayload>;
          };
          deleteMany: {
            args: Prisma.blacklistsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.blacklistsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.blacklistsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$blacklistsPayload>[];
          };
          upsert: {
            args: Prisma.blacklistsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$blacklistsPayload>;
          };
          aggregate: {
            args: Prisma.BlacklistsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateBlacklists>;
          };
          groupBy: {
            args: Prisma.blacklistsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<BlacklistsGroupByOutputType>[];
          };
          count: {
            args: Prisma.blacklistsCountArgs<ExtArgs>;
            result: $Utils.Optional<BlacklistsCountAggregateOutputType> | number;
          };
        };
      };
      customers: {
        payload: Prisma.$customersPayload<ExtArgs>;
        fields: Prisma.customersFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.customersFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$customersPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.customersFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$customersPayload>;
          };
          findFirst: {
            args: Prisma.customersFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$customersPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.customersFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$customersPayload>;
          };
          findMany: {
            args: Prisma.customersFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[];
          };
          create: {
            args: Prisma.customersCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$customersPayload>;
          };
          createMany: {
            args: Prisma.customersCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.customersCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[];
          };
          delete: {
            args: Prisma.customersDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$customersPayload>;
          };
          update: {
            args: Prisma.customersUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$customersPayload>;
          };
          deleteMany: {
            args: Prisma.customersDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.customersUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.customersUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$customersPayload>[];
          };
          upsert: {
            args: Prisma.customersUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$customersPayload>;
          };
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCustomers>;
          };
          groupBy: {
            args: Prisma.customersGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CustomersGroupByOutputType>[];
          };
          count: {
            args: Prisma.customersCountArgs<ExtArgs>;
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number;
          };
        };
      };
      firms: {
        payload: Prisma.$firmsPayload<ExtArgs>;
        fields: Prisma.firmsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.firmsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$firmsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.firmsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$firmsPayload>;
          };
          findFirst: {
            args: Prisma.firmsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$firmsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.firmsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$firmsPayload>;
          };
          findMany: {
            args: Prisma.firmsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$firmsPayload>[];
          };
          create: {
            args: Prisma.firmsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$firmsPayload>;
          };
          createMany: {
            args: Prisma.firmsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.firmsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$firmsPayload>[];
          };
          delete: {
            args: Prisma.firmsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$firmsPayload>;
          };
          update: {
            args: Prisma.firmsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$firmsPayload>;
          };
          deleteMany: {
            args: Prisma.firmsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.firmsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.firmsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$firmsPayload>[];
          };
          upsert: {
            args: Prisma.firmsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$firmsPayload>;
          };
          aggregate: {
            args: Prisma.FirmsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFirms>;
          };
          groupBy: {
            args: Prisma.firmsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FirmsGroupByOutputType>[];
          };
          count: {
            args: Prisma.firmsCountArgs<ExtArgs>;
            result: $Utils.Optional<FirmsCountAggregateOutputType> | number;
          };
        };
      };
      owners: {
        payload: Prisma.$ownersPayload<ExtArgs>;
        fields: Prisma.ownersFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ownersFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ownersPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ownersFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ownersPayload>;
          };
          findFirst: {
            args: Prisma.ownersFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ownersPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ownersFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ownersPayload>;
          };
          findMany: {
            args: Prisma.ownersFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ownersPayload>[];
          };
          create: {
            args: Prisma.ownersCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ownersPayload>;
          };
          createMany: {
            args: Prisma.ownersCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ownersCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ownersPayload>[];
          };
          delete: {
            args: Prisma.ownersDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ownersPayload>;
          };
          update: {
            args: Prisma.ownersUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ownersPayload>;
          };
          deleteMany: {
            args: Prisma.ownersDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ownersUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ownersUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ownersPayload>[];
          };
          upsert: {
            args: Prisma.ownersUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ownersPayload>;
          };
          aggregate: {
            args: Prisma.OwnersAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateOwners>;
          };
          groupBy: {
            args: Prisma.ownersGroupByArgs<ExtArgs>;
            result: $Utils.Optional<OwnersGroupByOutputType>[];
          };
          count: {
            args: Prisma.ownersCountArgs<ExtArgs>;
            result: $Utils.Optional<OwnersCountAggregateOutputType> | number;
          };
        };
      };
      payment_collections: {
        payload: Prisma.$payment_collectionsPayload<ExtArgs>;
        fields: Prisma.payment_collectionsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.payment_collectionsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_collectionsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.payment_collectionsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_collectionsPayload>;
          };
          findFirst: {
            args: Prisma.payment_collectionsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_collectionsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.payment_collectionsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_collectionsPayload>;
          };
          findMany: {
            args: Prisma.payment_collectionsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_collectionsPayload>[];
          };
          create: {
            args: Prisma.payment_collectionsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_collectionsPayload>;
          };
          createMany: {
            args: Prisma.payment_collectionsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.payment_collectionsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_collectionsPayload>[];
          };
          delete: {
            args: Prisma.payment_collectionsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_collectionsPayload>;
          };
          update: {
            args: Prisma.payment_collectionsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_collectionsPayload>;
          };
          deleteMany: {
            args: Prisma.payment_collectionsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.payment_collectionsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.payment_collectionsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_collectionsPayload>[];
          };
          upsert: {
            args: Prisma.payment_collectionsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_collectionsPayload>;
          };
          aggregate: {
            args: Prisma.Payment_collectionsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePayment_collections>;
          };
          groupBy: {
            args: Prisma.payment_collectionsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Payment_collectionsGroupByOutputType>[];
          };
          count: {
            args: Prisma.payment_collectionsCountArgs<ExtArgs>;
            result: $Utils.Optional<Payment_collectionsCountAggregateOutputType> | number;
          };
        };
      };
      payment_modes: {
        payload: Prisma.$payment_modesPayload<ExtArgs>;
        fields: Prisma.payment_modesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.payment_modesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_modesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.payment_modesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_modesPayload>;
          };
          findFirst: {
            args: Prisma.payment_modesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_modesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.payment_modesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_modesPayload>;
          };
          findMany: {
            args: Prisma.payment_modesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_modesPayload>[];
          };
          create: {
            args: Prisma.payment_modesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_modesPayload>;
          };
          createMany: {
            args: Prisma.payment_modesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.payment_modesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_modesPayload>[];
          };
          delete: {
            args: Prisma.payment_modesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_modesPayload>;
          };
          update: {
            args: Prisma.payment_modesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_modesPayload>;
          };
          deleteMany: {
            args: Prisma.payment_modesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.payment_modesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.payment_modesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_modesPayload>[];
          };
          upsert: {
            args: Prisma.payment_modesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$payment_modesPayload>;
          };
          aggregate: {
            args: Prisma.Payment_modesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePayment_modes>;
          };
          groupBy: {
            args: Prisma.payment_modesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Payment_modesGroupByOutputType>[];
          };
          count: {
            args: Prisma.payment_modesCountArgs<ExtArgs>;
            result: $Utils.Optional<Payment_modesCountAggregateOutputType> | number;
          };
        };
      };
      prefixes: {
        payload: Prisma.$prefixesPayload<ExtArgs>;
        fields: Prisma.prefixesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.prefixesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$prefixesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.prefixesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$prefixesPayload>;
          };
          findFirst: {
            args: Prisma.prefixesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$prefixesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.prefixesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$prefixesPayload>;
          };
          findMany: {
            args: Prisma.prefixesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$prefixesPayload>[];
          };
          create: {
            args: Prisma.prefixesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$prefixesPayload>;
          };
          createMany: {
            args: Prisma.prefixesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.prefixesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$prefixesPayload>[];
          };
          delete: {
            args: Prisma.prefixesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$prefixesPayload>;
          };
          update: {
            args: Prisma.prefixesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$prefixesPayload>;
          };
          deleteMany: {
            args: Prisma.prefixesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.prefixesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.prefixesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$prefixesPayload>[];
          };
          upsert: {
            args: Prisma.prefixesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$prefixesPayload>;
          };
          aggregate: {
            args: Prisma.PrefixesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePrefixes>;
          };
          groupBy: {
            args: Prisma.prefixesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PrefixesGroupByOutputType>[];
          };
          count: {
            args: Prisma.prefixesCountArgs<ExtArgs>;
            result: $Utils.Optional<PrefixesCountAggregateOutputType> | number;
          };
        };
      };
      products: {
        payload: Prisma.$productsPayload<ExtArgs>;
        fields: Prisma.productsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.productsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.productsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$productsPayload>;
          };
          findFirst: {
            args: Prisma.productsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.productsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$productsPayload>;
          };
          findMany: {
            args: Prisma.productsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[];
          };
          create: {
            args: Prisma.productsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$productsPayload>;
          };
          createMany: {
            args: Prisma.productsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.productsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[];
          };
          delete: {
            args: Prisma.productsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$productsPayload>;
          };
          update: {
            args: Prisma.productsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$productsPayload>;
          };
          deleteMany: {
            args: Prisma.productsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.productsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.productsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[];
          };
          upsert: {
            args: Prisma.productsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$productsPayload>;
          };
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProducts>;
          };
          groupBy: {
            args: Prisma.productsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProductsGroupByOutputType>[];
          };
          count: {
            args: Prisma.productsCountArgs<ExtArgs>;
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number;
          };
        };
      };
      provider_configurations: {
        payload: Prisma.$provider_configurationsPayload<ExtArgs>;
        fields: Prisma.provider_configurationsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.provider_configurationsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$provider_configurationsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.provider_configurationsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$provider_configurationsPayload>;
          };
          findFirst: {
            args: Prisma.provider_configurationsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$provider_configurationsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.provider_configurationsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$provider_configurationsPayload>;
          };
          findMany: {
            args: Prisma.provider_configurationsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$provider_configurationsPayload>[];
          };
          create: {
            args: Prisma.provider_configurationsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$provider_configurationsPayload>;
          };
          createMany: {
            args: Prisma.provider_configurationsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.provider_configurationsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$provider_configurationsPayload>[];
          };
          delete: {
            args: Prisma.provider_configurationsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$provider_configurationsPayload>;
          };
          update: {
            args: Prisma.provider_configurationsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$provider_configurationsPayload>;
          };
          deleteMany: {
            args: Prisma.provider_configurationsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.provider_configurationsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.provider_configurationsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$provider_configurationsPayload>[];
          };
          upsert: {
            args: Prisma.provider_configurationsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$provider_configurationsPayload>;
          };
          aggregate: {
            args: Prisma.Provider_configurationsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProvider_configurations>;
          };
          groupBy: {
            args: Prisma.provider_configurationsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Provider_configurationsGroupByOutputType>[];
          };
          count: {
            args: Prisma.provider_configurationsCountArgs<ExtArgs>;
            result: $Utils.Optional<Provider_configurationsCountAggregateOutputType> | number;
          };
        };
      };
      rentals: {
        payload: Prisma.$rentalsPayload<ExtArgs>;
        fields: Prisma.rentalsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.rentalsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rentalsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.rentalsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rentalsPayload>;
          };
          findFirst: {
            args: Prisma.rentalsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rentalsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.rentalsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rentalsPayload>;
          };
          findMany: {
            args: Prisma.rentalsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rentalsPayload>[];
          };
          create: {
            args: Prisma.rentalsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rentalsPayload>;
          };
          createMany: {
            args: Prisma.rentalsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.rentalsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rentalsPayload>[];
          };
          delete: {
            args: Prisma.rentalsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rentalsPayload>;
          };
          update: {
            args: Prisma.rentalsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rentalsPayload>;
          };
          deleteMany: {
            args: Prisma.rentalsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.rentalsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.rentalsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rentalsPayload>[];
          };
          upsert: {
            args: Prisma.rentalsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rentalsPayload>;
          };
          aggregate: {
            args: Prisma.RentalsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRentals>;
          };
          groupBy: {
            args: Prisma.rentalsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RentalsGroupByOutputType>[];
          };
          count: {
            args: Prisma.rentalsCountArgs<ExtArgs>;
            result: $Utils.Optional<RentalsCountAggregateOutputType> | number;
          };
        };
      };
      settings: {
        payload: Prisma.$settingsPayload<ExtArgs>;
        fields: Prisma.settingsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.settingsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$settingsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.settingsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>;
          };
          findFirst: {
            args: Prisma.settingsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$settingsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.settingsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>;
          };
          findMany: {
            args: Prisma.settingsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[];
          };
          create: {
            args: Prisma.settingsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>;
          };
          createMany: {
            args: Prisma.settingsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.settingsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[];
          };
          delete: {
            args: Prisma.settingsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>;
          };
          update: {
            args: Prisma.settingsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>;
          };
          deleteMany: {
            args: Prisma.settingsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.settingsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.settingsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>[];
          };
          upsert: {
            args: Prisma.settingsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$settingsPayload>;
          };
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSettings>;
          };
          groupBy: {
            args: Prisma.settingsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SettingsGroupByOutputType>[];
          };
          count: {
            args: Prisma.settingsCountArgs<ExtArgs>;
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number;
          };
        };
      };
      subscriptions: {
        payload: Prisma.$subscriptionsPayload<ExtArgs>;
        fields: Prisma.subscriptionsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.subscriptionsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.subscriptionsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>;
          };
          findFirst: {
            args: Prisma.subscriptionsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.subscriptionsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>;
          };
          findMany: {
            args: Prisma.subscriptionsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[];
          };
          create: {
            args: Prisma.subscriptionsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>;
          };
          createMany: {
            args: Prisma.subscriptionsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.subscriptionsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[];
          };
          delete: {
            args: Prisma.subscriptionsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>;
          };
          update: {
            args: Prisma.subscriptionsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>;
          };
          deleteMany: {
            args: Prisma.subscriptionsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.subscriptionsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.subscriptionsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[];
          };
          upsert: {
            args: Prisma.subscriptionsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>;
          };
          aggregate: {
            args: Prisma.SubscriptionsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSubscriptions>;
          };
          groupBy: {
            args: Prisma.subscriptionsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SubscriptionsGroupByOutputType>[];
          };
          count: {
            args: Prisma.subscriptionsCountArgs<ExtArgs>;
            result: $Utils.Optional<SubscriptionsCountAggregateOutputType> | number;
          };
        };
      };
      templates: {
        payload: Prisma.$templatesPayload<ExtArgs>;
        fields: Prisma.templatesFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.templatesFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$templatesPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.templatesFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$templatesPayload>;
          };
          findFirst: {
            args: Prisma.templatesFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$templatesPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.templatesFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$templatesPayload>;
          };
          findMany: {
            args: Prisma.templatesFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$templatesPayload>[];
          };
          create: {
            args: Prisma.templatesCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$templatesPayload>;
          };
          createMany: {
            args: Prisma.templatesCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.templatesCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$templatesPayload>[];
          };
          delete: {
            args: Prisma.templatesDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$templatesPayload>;
          };
          update: {
            args: Prisma.templatesUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$templatesPayload>;
          };
          deleteMany: {
            args: Prisma.templatesDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.templatesUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.templatesUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$templatesPayload>[];
          };
          upsert: {
            args: Prisma.templatesUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$templatesPayload>;
          };
          aggregate: {
            args: Prisma.TemplatesAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTemplates>;
          };
          groupBy: {
            args: Prisma.templatesGroupByArgs<ExtArgs>;
            result: $Utils.Optional<TemplatesGroupByOutputType>[];
          };
          count: {
            args: Prisma.templatesCountArgs<ExtArgs>;
            result: $Utils.Optional<TemplatesCountAggregateOutputType> | number;
          };
        };
      };
      terms_and_conditions: {
        payload: Prisma.$terms_and_conditionsPayload<ExtArgs>;
        fields: Prisma.terms_and_conditionsFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.terms_and_conditionsFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.terms_and_conditionsFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>;
          };
          findFirst: {
            args: Prisma.terms_and_conditionsFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.terms_and_conditionsFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>;
          };
          findMany: {
            args: Prisma.terms_and_conditionsFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>[];
          };
          create: {
            args: Prisma.terms_and_conditionsCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>;
          };
          createMany: {
            args: Prisma.terms_and_conditionsCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.terms_and_conditionsCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>[];
          };
          delete: {
            args: Prisma.terms_and_conditionsDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>;
          };
          update: {
            args: Prisma.terms_and_conditionsUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>;
          };
          deleteMany: {
            args: Prisma.terms_and_conditionsDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.terms_and_conditionsUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.terms_and_conditionsUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>[];
          };
          upsert: {
            args: Prisma.terms_and_conditionsUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$terms_and_conditionsPayload>;
          };
          aggregate: {
            args: Prisma.Terms_and_conditionsAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateTerms_and_conditions>;
          };
          groupBy: {
            args: Prisma.terms_and_conditionsGroupByArgs<ExtArgs>;
            result: $Utils.Optional<Terms_and_conditionsGroupByOutputType>[];
          };
          count: {
            args: Prisma.terms_and_conditionsCountArgs<ExtArgs>;
            result: $Utils.Optional<Terms_and_conditionsCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    admins?: adminsOmit;
    blacklists?: blacklistsOmit;
    customers?: customersOmit;
    firms?: firmsOmit;
    owners?: ownersOmit;
    payment_collections?: payment_collectionsOmit;
    payment_modes?: payment_modesOmit;
    prefixes?: prefixesOmit;
    products?: productsOmit;
    provider_configurations?: provider_configurationsOmit;
    rentals?: rentalsOmit;
    settings?: settingsOmit;
    subscriptions?: subscriptionsOmit;
    templates?: templatesOmit;
    terms_and_conditions?: terms_and_conditionsOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition
    ? T["emit"] extends "event"
      ? T["level"]
      : never
    : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ? GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type CustomersCountOutputType
   */

  export type CustomersCountOutputType = {
    rentals: number;
  };

  export type CustomersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rentals?: boolean | CustomersCountOutputTypeCountRentalsArgs;
  };

  // Custom InputTypes
  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the CustomersCountOutputType
       */
      select?: CustomersCountOutputTypeSelect<ExtArgs> | null;
    };

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountRentalsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: rentalsWhereInput;
  };

  /**
   * Count Type FirmsCountOutputType
   */

  export type FirmsCountOutputType = {
    products: number;
    terms_and_conditions: number;
    payment_collections: number;
    payment_modes: number;
    customers: number;
    owners: number;
  };

  export type FirmsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | FirmsCountOutputTypeCountProductsArgs;
    terms_and_conditions?: boolean | FirmsCountOutputTypeCountTerms_and_conditionsArgs;
    payment_collections?: boolean | FirmsCountOutputTypeCountPayment_collectionsArgs;
    payment_modes?: boolean | FirmsCountOutputTypeCountPayment_modesArgs;
    customers?: boolean | FirmsCountOutputTypeCountCustomersArgs;
    owners?: boolean | FirmsCountOutputTypeCountOwnersArgs;
  };

  // Custom InputTypes
  /**
   * FirmsCountOutputType without action
   */
  export type FirmsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FirmsCountOutputType
     */
    select?: FirmsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * FirmsCountOutputType without action
   */
  export type FirmsCountOutputTypeCountProductsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: productsWhereInput;
  };

  /**
   * FirmsCountOutputType without action
   */
  export type FirmsCountOutputTypeCountTerms_and_conditionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: terms_and_conditionsWhereInput;
  };

  /**
   * FirmsCountOutputType without action
   */
  export type FirmsCountOutputTypeCountPayment_collectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: payment_collectionsWhereInput;
  };

  /**
   * FirmsCountOutputType without action
   */
  export type FirmsCountOutputTypeCountPayment_modesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: payment_modesWhereInput;
  };

  /**
   * FirmsCountOutputType without action
   */
  export type FirmsCountOutputTypeCountCustomersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: customersWhereInput;
  };

  /**
   * FirmsCountOutputType without action
   */
  export type FirmsCountOutputTypeCountOwnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: ownersWhereInput;
    };

  /**
   * Count Type Payment_modesCountOutputType
   */

  export type Payment_modesCountOutputType = {
    payment_collections: number;
    rentals: number;
  };

  export type Payment_modesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_collections?: boolean | Payment_modesCountOutputTypeCountPayment_collectionsArgs;
    rentals?: boolean | Payment_modesCountOutputTypeCountRentalsArgs;
  };

  // Custom InputTypes
  /**
   * Payment_modesCountOutputType without action
   */
  export type Payment_modesCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment_modesCountOutputType
     */
    select?: Payment_modesCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * Payment_modesCountOutputType without action
   */
  export type Payment_modesCountOutputTypeCountPayment_collectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: payment_collectionsWhereInput;
  };

  /**
   * Payment_modesCountOutputType without action
   */
  export type Payment_modesCountOutputTypeCountRentalsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: rentalsWhereInput;
  };

  /**
   * Count Type RentalsCountOutputType
   */

  export type RentalsCountOutputType = {
    payment_collections: number;
  };

  export type RentalsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_collections?: boolean | RentalsCountOutputTypeCountPayment_collectionsArgs;
  };

  // Custom InputTypes
  /**
   * RentalsCountOutputType without action
   */
  export type RentalsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalsCountOutputType
     */
    select?: RentalsCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * RentalsCountOutputType without action
   */
  export type RentalsCountOutputTypeCountPayment_collectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: payment_collectionsWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model admins
   */

  export type AggregateAdmins = {
    _count: AdminsCountAggregateOutputType | null;
    _min: AdminsMinAggregateOutputType | null;
    _max: AdminsMaxAggregateOutputType | null;
  };

  export type AdminsMinAggregateOutputType = {
    id: string | null;
    full_name: string | null;
    mobile: string | null;
    email: string | null;
    image: string | null;
    username: string | null;
    alternate_mobile: string | null;
    address: string | null;
    city: string | null;
    state: string | null;
    country: string | null;
    pin_code: string | null;
    adhaar_number: string | null;
    driving_license_number: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type AdminsMaxAggregateOutputType = {
    id: string | null;
    full_name: string | null;
    mobile: string | null;
    email: string | null;
    image: string | null;
    username: string | null;
    alternate_mobile: string | null;
    address: string | null;
    city: string | null;
    state: string | null;
    country: string | null;
    pin_code: string | null;
    adhaar_number: string | null;
    driving_license_number: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type AdminsCountAggregateOutputType = {
    id: number;
    full_name: number;
    mobile: number;
    email: number;
    image: number;
    username: number;
    alternate_mobile: number;
    address: number;
    documents: number;
    city: number;
    state: number;
    country: number;
    pin_code: number;
    adhaar_number: number;
    driving_license_number: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type AdminsMinAggregateInputType = {
    id?: true;
    full_name?: true;
    mobile?: true;
    email?: true;
    image?: true;
    username?: true;
    alternate_mobile?: true;
    address?: true;
    city?: true;
    state?: true;
    country?: true;
    pin_code?: true;
    adhaar_number?: true;
    driving_license_number?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type AdminsMaxAggregateInputType = {
    id?: true;
    full_name?: true;
    mobile?: true;
    email?: true;
    image?: true;
    username?: true;
    alternate_mobile?: true;
    address?: true;
    city?: true;
    state?: true;
    country?: true;
    pin_code?: true;
    adhaar_number?: true;
    driving_license_number?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type AdminsCountAggregateInputType = {
    id?: true;
    full_name?: true;
    mobile?: true;
    email?: true;
    image?: true;
    username?: true;
    alternate_mobile?: true;
    address?: true;
    documents?: true;
    city?: true;
    state?: true;
    country?: true;
    pin_code?: true;
    adhaar_number?: true;
    driving_license_number?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type AdminsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to aggregate.
     */
    where?: adminsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of admins to fetch.
     */
    orderBy?: adminsOrderByWithRelationInput | adminsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: adminsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` admins from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` admins.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned admins
     **/
    _count?: true | AdminsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AdminsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AdminsMaxAggregateInputType;
  };

  export type GetAdminsAggregateType<T extends AdminsAggregateArgs> = {
    [P in keyof T & keyof AggregateAdmins]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmins[P]>
      : GetScalarType<T[P], AggregateAdmins[P]>;
  };

  export type adminsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminsWhereInput;
    orderBy?: adminsOrderByWithAggregationInput | adminsOrderByWithAggregationInput[];
    by: AdminsScalarFieldEnum[] | AdminsScalarFieldEnum;
    having?: adminsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AdminsCountAggregateInputType | true;
    _min?: AdminsMinAggregateInputType;
    _max?: AdminsMaxAggregateInputType;
  };

  export type AdminsGroupByOutputType = {
    id: string;
    full_name: string | null;
    mobile: string | null;
    email: string | null;
    image: string | null;
    username: string | null;
    alternate_mobile: string | null;
    address: string | null;
    documents: string[];
    city: string | null;
    state: string | null;
    country: string | null;
    pin_code: string | null;
    adhaar_number: string | null;
    driving_license_number: string | null;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: AdminsCountAggregateOutputType | null;
    _min: AdminsMinAggregateOutputType | null;
    _max: AdminsMaxAggregateOutputType | null;
  };

  type GetAdminsGroupByPayload<T extends adminsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminsGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof AdminsGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AdminsGroupByOutputType[P]>
          : GetScalarType<T[P], AdminsGroupByOutputType[P]>;
      }
    >
  >;

  export type adminsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
    {
      id?: boolean;
      full_name?: boolean;
      mobile?: boolean;
      email?: boolean;
      image?: boolean;
      username?: boolean;
      alternate_mobile?: boolean;
      address?: boolean;
      documents?: boolean;
      city?: boolean;
      state?: boolean;
      country?: boolean;
      pin_code?: boolean;
      adhaar_number?: boolean;
      driving_license_number?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      modified_at?: boolean;
      created_at?: boolean;
      created_by?: boolean;
      modified_by?: boolean;
    },
    ExtArgs["result"]["admins"]
  >;

  export type adminsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        full_name?: boolean;
        mobile?: boolean;
        email?: boolean;
        image?: boolean;
        username?: boolean;
        alternate_mobile?: boolean;
        address?: boolean;
        documents?: boolean;
        city?: boolean;
        state?: boolean;
        country?: boolean;
        pin_code?: boolean;
        adhaar_number?: boolean;
        driving_license_number?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["admins"]
    >;

  export type adminsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        full_name?: boolean;
        mobile?: boolean;
        email?: boolean;
        image?: boolean;
        username?: boolean;
        alternate_mobile?: boolean;
        address?: boolean;
        documents?: boolean;
        city?: boolean;
        state?: boolean;
        country?: boolean;
        pin_code?: boolean;
        adhaar_number?: boolean;
        driving_license_number?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["admins"]
    >;

  export type adminsSelectScalar = {
    id?: boolean;
    full_name?: boolean;
    mobile?: boolean;
    email?: boolean;
    image?: boolean;
    username?: boolean;
    alternate_mobile?: boolean;
    address?: boolean;
    documents?: boolean;
    city?: boolean;
    state?: boolean;
    country?: boolean;
    pin_code?: boolean;
    adhaar_number?: boolean;
    driving_license_number?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type adminsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "full_name"
    | "mobile"
    | "email"
    | "image"
    | "username"
    | "alternate_mobile"
    | "address"
    | "documents"
    | "city"
    | "state"
    | "country"
    | "pin_code"
    | "adhaar_number"
    | "driving_license_number"
    | "active_flag"
    | "delete_flag"
    | "modified_at"
    | "created_at"
    | "created_by"
    | "modified_by",
    ExtArgs["result"]["admins"]
  >;

  export type $adminsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admins";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        full_name: string | null;
        mobile: string | null;
        email: string | null;
        image: string | null;
        username: string | null;
        alternate_mobile: string | null;
        address: string | null;
        documents: string[];
        city: string | null;
        state: string | null;
        country: string | null;
        pin_code: string | null;
        adhaar_number: string | null;
        driving_license_number: string | null;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["admins"]
    >;
    composites: {};
  };

  type adminsGetPayload<S extends boolean | null | undefined | adminsDefaultArgs> = $Result.GetResult<
    Prisma.$adminsPayload,
    S
  >;

  type adminsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    adminsFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: AdminsCountAggregateInputType | true;
  };

  export interface adminsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["admins"]; meta: { name: "admins" } };
    /**
     * Find zero or one Admins that matches the filter.
     * @param {adminsFindUniqueArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminsFindUniqueArgs>(
      args: SelectSubset<T, adminsFindUniqueArgs<ExtArgs>>,
    ): Prisma__adminsClient<
      $Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Admins that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {adminsFindUniqueOrThrowArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, adminsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__adminsClient<
      $Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsFindFirstArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminsFindFirstArgs>(
      args?: SelectSubset<T, adminsFindFirstArgs<ExtArgs>>,
    ): Prisma__adminsClient<
      $Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Admins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsFindFirstOrThrowArgs} args - Arguments to find a Admins
     * @example
     * // Get one Admins
     * const admins = await prisma.admins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, adminsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__adminsClient<
      $Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admins.findMany()
     *
     * // Get first 10 Admins
     * const admins = await prisma.admins.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const adminsWithIdOnly = await prisma.admins.findMany({ select: { id: true } })
     *
     */
    findMany<T extends adminsFindManyArgs>(
      args?: SelectSubset<T, adminsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Admins.
     * @param {adminsCreateArgs} args - Arguments to create a Admins.
     * @example
     * // Create one Admins
     * const Admins = await prisma.admins.create({
     *   data: {
     *     // ... data to create a Admins
     *   }
     * })
     *
     */
    create<T extends adminsCreateArgs>(
      args: SelectSubset<T, adminsCreateArgs<ExtArgs>>,
    ): Prisma__adminsClient<
      $Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Admins.
     * @param {adminsCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admins = await prisma.admins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends adminsCreateManyArgs>(
      args?: SelectSubset<T, adminsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {adminsCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admins = await prisma.admins.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Admins and only return the `id`
     * const adminsWithIdOnly = await prisma.admins.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends adminsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, adminsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Admins.
     * @param {adminsDeleteArgs} args - Arguments to delete one Admins.
     * @example
     * // Delete one Admins
     * const Admins = await prisma.admins.delete({
     *   where: {
     *     // ... filter to delete one Admins
     *   }
     * })
     *
     */
    delete<T extends adminsDeleteArgs>(
      args: SelectSubset<T, adminsDeleteArgs<ExtArgs>>,
    ): Prisma__adminsClient<
      $Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Admins.
     * @param {adminsUpdateArgs} args - Arguments to update one Admins.
     * @example
     * // Update one Admins
     * const admins = await prisma.admins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends adminsUpdateArgs>(
      args: SelectSubset<T, adminsUpdateArgs<ExtArgs>>,
    ): Prisma__adminsClient<
      $Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Admins.
     * @param {adminsDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends adminsDeleteManyArgs>(
      args?: SelectSubset<T, adminsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admins = await prisma.admins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends adminsUpdateManyArgs>(
      args: SelectSubset<T, adminsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {adminsUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admins = await prisma.admins.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Admins and only return the `id`
     * const adminsWithIdOnly = await prisma.admins.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends adminsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, adminsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Admins.
     * @param {adminsUpsertArgs} args - Arguments to update or create a Admins.
     * @example
     * // Update or create a Admins
     * const admins = await prisma.admins.upsert({
     *   create: {
     *     // ... data to create a Admins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admins we want to update
     *   }
     * })
     */
    upsert<T extends adminsUpsertArgs>(
      args: SelectSubset<T, adminsUpsertArgs<ExtArgs>>,
    ): Prisma__adminsClient<
      $Result.GetResult<Prisma.$adminsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admins.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
     **/
    count<T extends adminsCountArgs>(
      args?: Subset<T, adminsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AdminsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AdminsAggregateArgs>(
      args: Subset<T, AdminsAggregateArgs>,
    ): Prisma.PrismaPromise<GetAdminsAggregateType<T>>;

    /**
     * Group by Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends adminsGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminsGroupByArgs["orderBy"] }
        : { orderBy?: adminsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, adminsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetAdminsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the admins model
     */
    readonly fields: adminsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the admins model
   */
  interface adminsFieldRefs {
    readonly id: FieldRef<"admins", "String">;
    readonly full_name: FieldRef<"admins", "String">;
    readonly mobile: FieldRef<"admins", "String">;
    readonly email: FieldRef<"admins", "String">;
    readonly image: FieldRef<"admins", "String">;
    readonly username: FieldRef<"admins", "String">;
    readonly alternate_mobile: FieldRef<"admins", "String">;
    readonly address: FieldRef<"admins", "String">;
    readonly documents: FieldRef<"admins", "String[]">;
    readonly city: FieldRef<"admins", "String">;
    readonly state: FieldRef<"admins", "String">;
    readonly country: FieldRef<"admins", "String">;
    readonly pin_code: FieldRef<"admins", "String">;
    readonly adhaar_number: FieldRef<"admins", "String">;
    readonly driving_license_number: FieldRef<"admins", "String">;
    readonly active_flag: FieldRef<"admins", "Boolean">;
    readonly delete_flag: FieldRef<"admins", "Boolean">;
    readonly modified_at: FieldRef<"admins", "DateTime">;
    readonly created_at: FieldRef<"admins", "DateTime">;
    readonly created_by: FieldRef<"admins", "String">;
    readonly modified_by: FieldRef<"admins", "String">;
  }

  // Custom InputTypes
  /**
   * admins findUnique
   */
  export type adminsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null;
    /**
     * Filter, which admins to fetch.
     */
    where: adminsWhereUniqueInput;
  };

  /**
   * admins findUniqueOrThrow
   */
  export type adminsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null;
    /**
     * Filter, which admins to fetch.
     */
    where: adminsWhereUniqueInput;
  };

  /**
   * admins findFirst
   */
  export type adminsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null;
    /**
     * Filter, which admins to fetch.
     */
    where?: adminsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of admins to fetch.
     */
    orderBy?: adminsOrderByWithRelationInput | adminsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for admins.
     */
    cursor?: adminsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` admins from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` admins.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of admins.
     */
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[];
  };

  /**
   * admins findFirstOrThrow
   */
  export type adminsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null;
    /**
     * Filter, which admins to fetch.
     */
    where?: adminsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of admins to fetch.
     */
    orderBy?: adminsOrderByWithRelationInput | adminsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for admins.
     */
    cursor?: adminsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` admins from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` admins.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of admins.
     */
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[];
  };

  /**
   * admins findMany
   */
  export type adminsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null;
    /**
     * Filter, which admins to fetch.
     */
    where?: adminsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of admins to fetch.
     */
    orderBy?: adminsOrderByWithRelationInput | adminsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing admins.
     */
    cursor?: adminsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` admins from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` admins.
     */
    skip?: number;
    distinct?: AdminsScalarFieldEnum | AdminsScalarFieldEnum[];
  };

  /**
   * admins create
   */
  export type adminsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null;
    /**
     * The data needed to create a admins.
     */
    data: XOR<adminsCreateInput, adminsUncheckedCreateInput>;
  };

  /**
   * admins createMany
   */
  export type adminsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminsCreateManyInput | adminsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * admins createManyAndReturn
   */
  export type adminsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null;
    /**
     * The data used to create many admins.
     */
    data: adminsCreateManyInput | adminsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * admins update
   */
  export type adminsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null;
    /**
     * The data needed to update a admins.
     */
    data: XOR<adminsUpdateInput, adminsUncheckedUpdateInput>;
    /**
     * Choose, which admins to update.
     */
    where: adminsWhereUniqueInput;
  };

  /**
   * admins updateMany
   */
  export type adminsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminsUpdateManyMutationInput, adminsUncheckedUpdateManyInput>;
    /**
     * Filter which admins to update
     */
    where?: adminsWhereInput;
    /**
     * Limit how many admins to update.
     */
    limit?: number;
  };

  /**
   * admins updateManyAndReturn
   */
  export type adminsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null;
    /**
     * The data used to update admins.
     */
    data: XOR<adminsUpdateManyMutationInput, adminsUncheckedUpdateManyInput>;
    /**
     * Filter which admins to update
     */
    where?: adminsWhereInput;
    /**
     * Limit how many admins to update.
     */
    limit?: number;
  };

  /**
   * admins upsert
   */
  export type adminsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null;
    /**
     * The filter to search for the admins to update in case it exists.
     */
    where: adminsWhereUniqueInput;
    /**
     * In case the admins found by the `where` argument doesn't exist, create a new admins with this data.
     */
    create: XOR<adminsCreateInput, adminsUncheckedCreateInput>;
    /**
     * In case the admins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminsUpdateInput, adminsUncheckedUpdateInput>;
  };

  /**
   * admins delete
   */
  export type adminsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null;
    /**
     * Filter which admins to delete.
     */
    where: adminsWhereUniqueInput;
  };

  /**
   * admins deleteMany
   */
  export type adminsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminsWhereInput;
    /**
     * Limit how many admins to delete.
     */
    limit?: number;
  };

  /**
   * admins without action
   */
  export type adminsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admins
     */
    select?: adminsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the admins
     */
    omit?: adminsOmit<ExtArgs> | null;
  };

  /**
   * Model blacklists
   */

  export type AggregateBlacklists = {
    _count: BlacklistsCountAggregateOutputType | null;
    _min: BlacklistsMinAggregateOutputType | null;
    _max: BlacklistsMaxAggregateOutputType | null;
  };

  export type BlacklistsMinAggregateOutputType = {
    id: string | null;
    refresh_token: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type BlacklistsMaxAggregateOutputType = {
    id: string | null;
    refresh_token: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type BlacklistsCountAggregateOutputType = {
    id: number;
    refresh_token: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type BlacklistsMinAggregateInputType = {
    id?: true;
    refresh_token?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type BlacklistsMaxAggregateInputType = {
    id?: true;
    refresh_token?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type BlacklistsCountAggregateInputType = {
    id?: true;
    refresh_token?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type BlacklistsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blacklists to aggregate.
     */
    where?: blacklistsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of blacklists to fetch.
     */
    orderBy?: blacklistsOrderByWithRelationInput | blacklistsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: blacklistsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` blacklists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` blacklists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned blacklists
     **/
    _count?: true | BlacklistsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: BlacklistsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: BlacklistsMaxAggregateInputType;
  };

  export type GetBlacklistsAggregateType<T extends BlacklistsAggregateArgs> = {
    [P in keyof T & keyof AggregateBlacklists]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlacklists[P]>
      : GetScalarType<T[P], AggregateBlacklists[P]>;
  };

  export type blacklistsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blacklistsWhereInput;
    orderBy?: blacklistsOrderByWithAggregationInput | blacklistsOrderByWithAggregationInput[];
    by: BlacklistsScalarFieldEnum[] | BlacklistsScalarFieldEnum;
    having?: blacklistsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: BlacklistsCountAggregateInputType | true;
    _min?: BlacklistsMinAggregateInputType;
    _max?: BlacklistsMaxAggregateInputType;
  };

  export type BlacklistsGroupByOutputType = {
    id: string;
    refresh_token: string;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: BlacklistsCountAggregateOutputType | null;
    _min: BlacklistsMinAggregateOutputType | null;
    _max: BlacklistsMaxAggregateOutputType | null;
  };

  type GetBlacklistsGroupByPayload<T extends blacklistsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlacklistsGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof BlacklistsGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], BlacklistsGroupByOutputType[P]>
          : GetScalarType<T[P], BlacklistsGroupByOutputType[P]>;
      }
    >
  >;

  export type blacklistsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        refresh_token?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["blacklists"]
    >;

  export type blacklistsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        refresh_token?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["blacklists"]
    >;

  export type blacklistsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        refresh_token?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["blacklists"]
    >;

  export type blacklistsSelectScalar = {
    id?: boolean;
    refresh_token?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type blacklistsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "refresh_token"
    | "active_flag"
    | "delete_flag"
    | "modified_at"
    | "created_at"
    | "created_by"
    | "modified_by",
    ExtArgs["result"]["blacklists"]
  >;

  export type $blacklistsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blacklists";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        refresh_token: string;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["blacklists"]
    >;
    composites: {};
  };

  type blacklistsGetPayload<S extends boolean | null | undefined | blacklistsDefaultArgs> = $Result.GetResult<
    Prisma.$blacklistsPayload,
    S
  >;

  type blacklistsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    blacklistsFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: BlacklistsCountAggregateInputType | true;
  };

  export interface blacklistsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["blacklists"]; meta: { name: "blacklists" } };
    /**
     * Find zero or one Blacklists that matches the filter.
     * @param {blacklistsFindUniqueArgs} args - Arguments to find a Blacklists
     * @example
     * // Get one Blacklists
     * const blacklists = await prisma.blacklists.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blacklistsFindUniqueArgs>(
      args: SelectSubset<T, blacklistsFindUniqueArgs<ExtArgs>>,
    ): Prisma__blacklistsClient<
      $Result.GetResult<Prisma.$blacklistsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Blacklists that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blacklistsFindUniqueOrThrowArgs} args - Arguments to find a Blacklists
     * @example
     * // Get one Blacklists
     * const blacklists = await prisma.blacklists.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blacklistsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, blacklistsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__blacklistsClient<
      $Result.GetResult<Prisma.$blacklistsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Blacklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blacklistsFindFirstArgs} args - Arguments to find a Blacklists
     * @example
     * // Get one Blacklists
     * const blacklists = await prisma.blacklists.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blacklistsFindFirstArgs>(
      args?: SelectSubset<T, blacklistsFindFirstArgs<ExtArgs>>,
    ): Prisma__blacklistsClient<
      $Result.GetResult<Prisma.$blacklistsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Blacklists that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blacklistsFindFirstOrThrowArgs} args - Arguments to find a Blacklists
     * @example
     * // Get one Blacklists
     * const blacklists = await prisma.blacklists.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blacklistsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, blacklistsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__blacklistsClient<
      $Result.GetResult<Prisma.$blacklistsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Blacklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blacklistsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blacklists
     * const blacklists = await prisma.blacklists.findMany()
     *
     * // Get first 10 Blacklists
     * const blacklists = await prisma.blacklists.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const blacklistsWithIdOnly = await prisma.blacklists.findMany({ select: { id: true } })
     *
     */
    findMany<T extends blacklistsFindManyArgs>(
      args?: SelectSubset<T, blacklistsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blacklistsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Blacklists.
     * @param {blacklistsCreateArgs} args - Arguments to create a Blacklists.
     * @example
     * // Create one Blacklists
     * const Blacklists = await prisma.blacklists.create({
     *   data: {
     *     // ... data to create a Blacklists
     *   }
     * })
     *
     */
    create<T extends blacklistsCreateArgs>(
      args: SelectSubset<T, blacklistsCreateArgs<ExtArgs>>,
    ): Prisma__blacklistsClient<
      $Result.GetResult<Prisma.$blacklistsPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Blacklists.
     * @param {blacklistsCreateManyArgs} args - Arguments to create many Blacklists.
     * @example
     * // Create many Blacklists
     * const blacklists = await prisma.blacklists.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends blacklistsCreateManyArgs>(
      args?: SelectSubset<T, blacklistsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Blacklists and returns the data saved in the database.
     * @param {blacklistsCreateManyAndReturnArgs} args - Arguments to create many Blacklists.
     * @example
     * // Create many Blacklists
     * const blacklists = await prisma.blacklists.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Blacklists and only return the `id`
     * const blacklistsWithIdOnly = await prisma.blacklists.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends blacklistsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, blacklistsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$blacklistsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Blacklists.
     * @param {blacklistsDeleteArgs} args - Arguments to delete one Blacklists.
     * @example
     * // Delete one Blacklists
     * const Blacklists = await prisma.blacklists.delete({
     *   where: {
     *     // ... filter to delete one Blacklists
     *   }
     * })
     *
     */
    delete<T extends blacklistsDeleteArgs>(
      args: SelectSubset<T, blacklistsDeleteArgs<ExtArgs>>,
    ): Prisma__blacklistsClient<
      $Result.GetResult<Prisma.$blacklistsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Blacklists.
     * @param {blacklistsUpdateArgs} args - Arguments to update one Blacklists.
     * @example
     * // Update one Blacklists
     * const blacklists = await prisma.blacklists.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends blacklistsUpdateArgs>(
      args: SelectSubset<T, blacklistsUpdateArgs<ExtArgs>>,
    ): Prisma__blacklistsClient<
      $Result.GetResult<Prisma.$blacklistsPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Blacklists.
     * @param {blacklistsDeleteManyArgs} args - Arguments to filter Blacklists to delete.
     * @example
     * // Delete a few Blacklists
     * const { count } = await prisma.blacklists.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends blacklistsDeleteManyArgs>(
      args?: SelectSubset<T, blacklistsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Blacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blacklistsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blacklists
     * const blacklists = await prisma.blacklists.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends blacklistsUpdateManyArgs>(
      args: SelectSubset<T, blacklistsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Blacklists and returns the data updated in the database.
     * @param {blacklistsUpdateManyAndReturnArgs} args - Arguments to update many Blacklists.
     * @example
     * // Update many Blacklists
     * const blacklists = await prisma.blacklists.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Blacklists and only return the `id`
     * const blacklistsWithIdOnly = await prisma.blacklists.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends blacklistsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, blacklistsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$blacklistsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Blacklists.
     * @param {blacklistsUpsertArgs} args - Arguments to update or create a Blacklists.
     * @example
     * // Update or create a Blacklists
     * const blacklists = await prisma.blacklists.upsert({
     *   create: {
     *     // ... data to create a Blacklists
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blacklists we want to update
     *   }
     * })
     */
    upsert<T extends blacklistsUpsertArgs>(
      args: SelectSubset<T, blacklistsUpsertArgs<ExtArgs>>,
    ): Prisma__blacklistsClient<
      $Result.GetResult<Prisma.$blacklistsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Blacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blacklistsCountArgs} args - Arguments to filter Blacklists to count.
     * @example
     * // Count the number of Blacklists
     * const count = await prisma.blacklists.count({
     *   where: {
     *     // ... the filter for the Blacklists we want to count
     *   }
     * })
     **/
    count<T extends blacklistsCountArgs>(
      args?: Subset<T, blacklistsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], BlacklistsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Blacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends BlacklistsAggregateArgs>(
      args: Subset<T, BlacklistsAggregateArgs>,
    ): Prisma.PrismaPromise<GetBlacklistsAggregateType<T>>;

    /**
     * Group by Blacklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blacklistsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends blacklistsGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blacklistsGroupByArgs["orderBy"] }
        : { orderBy?: blacklistsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, blacklistsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetBlacklistsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the blacklists model
     */
    readonly fields: blacklistsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blacklists.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blacklistsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the blacklists model
   */
  interface blacklistsFieldRefs {
    readonly id: FieldRef<"blacklists", "String">;
    readonly refresh_token: FieldRef<"blacklists", "String">;
    readonly active_flag: FieldRef<"blacklists", "Boolean">;
    readonly delete_flag: FieldRef<"blacklists", "Boolean">;
    readonly modified_at: FieldRef<"blacklists", "DateTime">;
    readonly created_at: FieldRef<"blacklists", "DateTime">;
    readonly created_by: FieldRef<"blacklists", "String">;
    readonly modified_by: FieldRef<"blacklists", "String">;
  }

  // Custom InputTypes
  /**
   * blacklists findUnique
   */
  export type blacklistsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklists
     */
    select?: blacklistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the blacklists
     */
    omit?: blacklistsOmit<ExtArgs> | null;
    /**
     * Filter, which blacklists to fetch.
     */
    where: blacklistsWhereUniqueInput;
  };

  /**
   * blacklists findUniqueOrThrow
   */
  export type blacklistsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklists
     */
    select?: blacklistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the blacklists
     */
    omit?: blacklistsOmit<ExtArgs> | null;
    /**
     * Filter, which blacklists to fetch.
     */
    where: blacklistsWhereUniqueInput;
  };

  /**
   * blacklists findFirst
   */
  export type blacklistsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklists
     */
    select?: blacklistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the blacklists
     */
    omit?: blacklistsOmit<ExtArgs> | null;
    /**
     * Filter, which blacklists to fetch.
     */
    where?: blacklistsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of blacklists to fetch.
     */
    orderBy?: blacklistsOrderByWithRelationInput | blacklistsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for blacklists.
     */
    cursor?: blacklistsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` blacklists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` blacklists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of blacklists.
     */
    distinct?: BlacklistsScalarFieldEnum | BlacklistsScalarFieldEnum[];
  };

  /**
   * blacklists findFirstOrThrow
   */
  export type blacklistsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklists
     */
    select?: blacklistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the blacklists
     */
    omit?: blacklistsOmit<ExtArgs> | null;
    /**
     * Filter, which blacklists to fetch.
     */
    where?: blacklistsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of blacklists to fetch.
     */
    orderBy?: blacklistsOrderByWithRelationInput | blacklistsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for blacklists.
     */
    cursor?: blacklistsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` blacklists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` blacklists.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of blacklists.
     */
    distinct?: BlacklistsScalarFieldEnum | BlacklistsScalarFieldEnum[];
  };

  /**
   * blacklists findMany
   */
  export type blacklistsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklists
     */
    select?: blacklistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the blacklists
     */
    omit?: blacklistsOmit<ExtArgs> | null;
    /**
     * Filter, which blacklists to fetch.
     */
    where?: blacklistsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of blacklists to fetch.
     */
    orderBy?: blacklistsOrderByWithRelationInput | blacklistsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing blacklists.
     */
    cursor?: blacklistsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` blacklists from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` blacklists.
     */
    skip?: number;
    distinct?: BlacklistsScalarFieldEnum | BlacklistsScalarFieldEnum[];
  };

  /**
   * blacklists create
   */
  export type blacklistsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklists
     */
    select?: blacklistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the blacklists
     */
    omit?: blacklistsOmit<ExtArgs> | null;
    /**
     * The data needed to create a blacklists.
     */
    data: XOR<blacklistsCreateInput, blacklistsUncheckedCreateInput>;
  };

  /**
   * blacklists createMany
   */
  export type blacklistsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blacklists.
     */
    data: blacklistsCreateManyInput | blacklistsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * blacklists createManyAndReturn
   */
  export type blacklistsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklists
     */
    select?: blacklistsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the blacklists
     */
    omit?: blacklistsOmit<ExtArgs> | null;
    /**
     * The data used to create many blacklists.
     */
    data: blacklistsCreateManyInput | blacklistsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * blacklists update
   */
  export type blacklistsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklists
     */
    select?: blacklistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the blacklists
     */
    omit?: blacklistsOmit<ExtArgs> | null;
    /**
     * The data needed to update a blacklists.
     */
    data: XOR<blacklistsUpdateInput, blacklistsUncheckedUpdateInput>;
    /**
     * Choose, which blacklists to update.
     */
    where: blacklistsWhereUniqueInput;
  };

  /**
   * blacklists updateMany
   */
  export type blacklistsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blacklists.
     */
    data: XOR<blacklistsUpdateManyMutationInput, blacklistsUncheckedUpdateManyInput>;
    /**
     * Filter which blacklists to update
     */
    where?: blacklistsWhereInput;
    /**
     * Limit how many blacklists to update.
     */
    limit?: number;
  };

  /**
   * blacklists updateManyAndReturn
   */
  export type blacklistsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklists
     */
    select?: blacklistsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the blacklists
     */
    omit?: blacklistsOmit<ExtArgs> | null;
    /**
     * The data used to update blacklists.
     */
    data: XOR<blacklistsUpdateManyMutationInput, blacklistsUncheckedUpdateManyInput>;
    /**
     * Filter which blacklists to update
     */
    where?: blacklistsWhereInput;
    /**
     * Limit how many blacklists to update.
     */
    limit?: number;
  };

  /**
   * blacklists upsert
   */
  export type blacklistsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklists
     */
    select?: blacklistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the blacklists
     */
    omit?: blacklistsOmit<ExtArgs> | null;
    /**
     * The filter to search for the blacklists to update in case it exists.
     */
    where: blacklistsWhereUniqueInput;
    /**
     * In case the blacklists found by the `where` argument doesn't exist, create a new blacklists with this data.
     */
    create: XOR<blacklistsCreateInput, blacklistsUncheckedCreateInput>;
    /**
     * In case the blacklists was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blacklistsUpdateInput, blacklistsUncheckedUpdateInput>;
  };

  /**
   * blacklists delete
   */
  export type blacklistsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklists
     */
    select?: blacklistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the blacklists
     */
    omit?: blacklistsOmit<ExtArgs> | null;
    /**
     * Filter which blacklists to delete.
     */
    where: blacklistsWhereUniqueInput;
  };

  /**
   * blacklists deleteMany
   */
  export type blacklistsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blacklists to delete
     */
    where?: blacklistsWhereInput;
    /**
     * Limit how many blacklists to delete.
     */
    limit?: number;
  };

  /**
   * blacklists without action
   */
  export type blacklistsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blacklists
     */
    select?: blacklistsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the blacklists
     */
    omit?: blacklistsOmit<ExtArgs> | null;
  };

  /**
   * Model customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null;
    _min: CustomersMinAggregateOutputType | null;
    _max: CustomersMaxAggregateOutputType | null;
  };

  export type CustomersMinAggregateOutputType = {
    id: string | null;
    firm_id: string | null;
    full_name: string | null;
    mobile: string | null;
    email: string | null;
    image: string | null;
    username: string | null;
    alternate_mobile: string | null;
    address: string | null;
    city: string | null;
    state: string | null;
    country: string | null;
    pin_code: string | null;
    adhaar_number: string | null;
    driving_license_number: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type CustomersMaxAggregateOutputType = {
    id: string | null;
    firm_id: string | null;
    full_name: string | null;
    mobile: string | null;
    email: string | null;
    image: string | null;
    username: string | null;
    alternate_mobile: string | null;
    address: string | null;
    city: string | null;
    state: string | null;
    country: string | null;
    pin_code: string | null;
    adhaar_number: string | null;
    driving_license_number: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type CustomersCountAggregateOutputType = {
    id: number;
    firm_id: number;
    full_name: number;
    mobile: number;
    email: number;
    image: number;
    username: number;
    alternate_mobile: number;
    address: number;
    documents: number;
    city: number;
    state: number;
    country: number;
    pin_code: number;
    adhaar_number: number;
    driving_license_number: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type CustomersMinAggregateInputType = {
    id?: true;
    firm_id?: true;
    full_name?: true;
    mobile?: true;
    email?: true;
    image?: true;
    username?: true;
    alternate_mobile?: true;
    address?: true;
    city?: true;
    state?: true;
    country?: true;
    pin_code?: true;
    adhaar_number?: true;
    driving_license_number?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type CustomersMaxAggregateInputType = {
    id?: true;
    firm_id?: true;
    full_name?: true;
    mobile?: true;
    email?: true;
    image?: true;
    username?: true;
    alternate_mobile?: true;
    address?: true;
    city?: true;
    state?: true;
    country?: true;
    pin_code?: true;
    adhaar_number?: true;
    driving_license_number?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type CustomersCountAggregateInputType = {
    id?: true;
    firm_id?: true;
    full_name?: true;
    mobile?: true;
    email?: true;
    image?: true;
    username?: true;
    alternate_mobile?: true;
    address?: true;
    documents?: true;
    city?: true;
    state?: true;
    country?: true;
    pin_code?: true;
    adhaar_number?: true;
    driving_license_number?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to aggregate.
     */
    where?: customersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: customersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` customers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` customers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned customers
     **/
    _count?: true | CustomersCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CustomersMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CustomersMaxAggregateInputType;
  };

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
    [P in keyof T & keyof AggregateCustomers]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>;
  };

  export type customersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customersWhereInput;
    orderBy?: customersOrderByWithAggregationInput | customersOrderByWithAggregationInput[];
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum;
    having?: customersScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CustomersCountAggregateInputType | true;
    _min?: CustomersMinAggregateInputType;
    _max?: CustomersMaxAggregateInputType;
  };

  export type CustomersGroupByOutputType = {
    id: string;
    firm_id: string;
    full_name: string | null;
    mobile: string | null;
    email: string | null;
    image: string | null;
    username: string | null;
    alternate_mobile: string | null;
    address: string | null;
    documents: string[];
    city: string | null;
    state: string | null;
    country: string | null;
    pin_code: string | null;
    adhaar_number: string | null;
    driving_license_number: string | null;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: CustomersCountAggregateOutputType | null;
    _min: CustomersMinAggregateOutputType | null;
    _max: CustomersMaxAggregateOutputType | null;
  };

  type GetCustomersGroupByPayload<T extends customersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof CustomersGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
          : GetScalarType<T[P], CustomersGroupByOutputType[P]>;
      }
    >
  >;

  export type customersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        firm_id?: boolean;
        full_name?: boolean;
        mobile?: boolean;
        email?: boolean;
        image?: boolean;
        username?: boolean;
        alternate_mobile?: boolean;
        address?: boolean;
        documents?: boolean;
        city?: boolean;
        state?: boolean;
        country?: boolean;
        pin_code?: boolean;
        adhaar_number?: boolean;
        driving_license_number?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
        firm?: boolean | firmsDefaultArgs<ExtArgs>;
        rentals?: boolean | customers$rentalsArgs<ExtArgs>;
        _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["customers"]
    >;

  export type customersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        firm_id?: boolean;
        full_name?: boolean;
        mobile?: boolean;
        email?: boolean;
        image?: boolean;
        username?: boolean;
        alternate_mobile?: boolean;
        address?: boolean;
        documents?: boolean;
        city?: boolean;
        state?: boolean;
        country?: boolean;
        pin_code?: boolean;
        adhaar_number?: boolean;
        driving_license_number?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
        firm?: boolean | firmsDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["customers"]
    >;

  export type customersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        firm_id?: boolean;
        full_name?: boolean;
        mobile?: boolean;
        email?: boolean;
        image?: boolean;
        username?: boolean;
        alternate_mobile?: boolean;
        address?: boolean;
        documents?: boolean;
        city?: boolean;
        state?: boolean;
        country?: boolean;
        pin_code?: boolean;
        adhaar_number?: boolean;
        driving_license_number?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
        firm?: boolean | firmsDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["customers"]
    >;

  export type customersSelectScalar = {
    id?: boolean;
    firm_id?: boolean;
    full_name?: boolean;
    mobile?: boolean;
    email?: boolean;
    image?: boolean;
    username?: boolean;
    alternate_mobile?: boolean;
    address?: boolean;
    documents?: boolean;
    city?: boolean;
    state?: boolean;
    country?: boolean;
    pin_code?: boolean;
    adhaar_number?: boolean;
    driving_license_number?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type customersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "firm_id"
    | "full_name"
    | "mobile"
    | "email"
    | "image"
    | "username"
    | "alternate_mobile"
    | "address"
    | "documents"
    | "city"
    | "state"
    | "country"
    | "pin_code"
    | "adhaar_number"
    | "driving_license_number"
    | "active_flag"
    | "delete_flag"
    | "modified_at"
    | "created_at"
    | "created_by"
    | "modified_by",
    ExtArgs["result"]["customers"]
  >;
  export type customersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    firm?: boolean | firmsDefaultArgs<ExtArgs>;
    rentals?: boolean | customers$rentalsArgs<ExtArgs>;
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type customersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      firm?: boolean | firmsDefaultArgs<ExtArgs>;
    };
  export type customersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      firm?: boolean | firmsDefaultArgs<ExtArgs>;
    };

  export type $customersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customers";
    objects: {
      firm: Prisma.$firmsPayload<ExtArgs>;
      rentals: Prisma.$rentalsPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        firm_id: string;
        full_name: string | null;
        mobile: string | null;
        email: string | null;
        image: string | null;
        username: string | null;
        alternate_mobile: string | null;
        address: string | null;
        documents: string[];
        city: string | null;
        state: string | null;
        country: string | null;
        pin_code: string | null;
        adhaar_number: string | null;
        driving_license_number: string | null;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["customers"]
    >;
    composites: {};
  };

  type customersGetPayload<S extends boolean | null | undefined | customersDefaultArgs> = $Result.GetResult<
    Prisma.$customersPayload,
    S
  >;

  type customersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    customersFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: CustomersCountAggregateInputType | true;
  };

  export interface customersDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["customers"]; meta: { name: "customers" } };
    /**
     * Find zero or one Customers that matches the filter.
     * @param {customersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customersFindUniqueArgs>(
      args: SelectSubset<T, customersFindUniqueArgs<ExtArgs>>,
    ): Prisma__customersClient<
      $Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Customers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customersFindUniqueOrThrowArgs>(
      args: SelectSubset<T, customersFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__customersClient<
      $Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customersFindFirstArgs>(
      args?: SelectSubset<T, customersFindFirstArgs<ExtArgs>>,
    ): Prisma__customersClient<
      $Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, customersFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__customersClient<
      $Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     *
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     *
     */
    findMany<T extends customersFindManyArgs>(
      args?: SelectSubset<T, customersFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Customers.
     * @param {customersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     *
     */
    create<T extends customersCreateArgs>(
      args: SelectSubset<T, customersCreateArgs<ExtArgs>>,
    ): Prisma__customersClient<
      $Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Customers.
     * @param {customersCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends customersCreateManyArgs>(
      args?: SelectSubset<T, customersCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {customersCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends customersCreateManyAndReturnArgs>(
      args?: SelectSubset<T, customersCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Customers.
     * @param {customersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     *
     */
    delete<T extends customersDeleteArgs>(
      args: SelectSubset<T, customersDeleteArgs<ExtArgs>>,
    ): Prisma__customersClient<
      $Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Customers.
     * @param {customersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends customersUpdateArgs>(
      args: SelectSubset<T, customersUpdateArgs<ExtArgs>>,
    ): Prisma__customersClient<
      $Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Customers.
     * @param {customersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends customersDeleteManyArgs>(
      args?: SelectSubset<T, customersDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends customersUpdateManyArgs>(
      args: SelectSubset<T, customersUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {customersUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends customersUpdateManyAndReturnArgs>(
      args: SelectSubset<T, customersUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Customers.
     * @param {customersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
     */
    upsert<T extends customersUpsertArgs>(
      args: SelectSubset<T, customersUpsertArgs<ExtArgs>>,
    ): Prisma__customersClient<
      $Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
     **/
    count<T extends customersCountArgs>(
      args?: Subset<T, customersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], CustomersCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CustomersAggregateArgs>(
      args: Subset<T, CustomersAggregateArgs>,
    ): Prisma.PrismaPromise<GetCustomersAggregateType<T>>;

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends customersGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customersGroupByArgs["orderBy"] }
        : { orderBy?: customersGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, customersGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the customers model
     */
    readonly fields: customersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customersClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    firm<T extends firmsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, firmsDefaultArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    rentals<T extends customers$rentalsArgs<ExtArgs> = {}>(
      args?: Subset<T, customers$rentalsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the customers model
   */
  interface customersFieldRefs {
    readonly id: FieldRef<"customers", "String">;
    readonly firm_id: FieldRef<"customers", "String">;
    readonly full_name: FieldRef<"customers", "String">;
    readonly mobile: FieldRef<"customers", "String">;
    readonly email: FieldRef<"customers", "String">;
    readonly image: FieldRef<"customers", "String">;
    readonly username: FieldRef<"customers", "String">;
    readonly alternate_mobile: FieldRef<"customers", "String">;
    readonly address: FieldRef<"customers", "String">;
    readonly documents: FieldRef<"customers", "String[]">;
    readonly city: FieldRef<"customers", "String">;
    readonly state: FieldRef<"customers", "String">;
    readonly country: FieldRef<"customers", "String">;
    readonly pin_code: FieldRef<"customers", "String">;
    readonly adhaar_number: FieldRef<"customers", "String">;
    readonly driving_license_number: FieldRef<"customers", "String">;
    readonly active_flag: FieldRef<"customers", "Boolean">;
    readonly delete_flag: FieldRef<"customers", "Boolean">;
    readonly modified_at: FieldRef<"customers", "DateTime">;
    readonly created_at: FieldRef<"customers", "DateTime">;
    readonly created_by: FieldRef<"customers", "String">;
    readonly modified_by: FieldRef<"customers", "String">;
  }

  // Custom InputTypes
  /**
   * customers findUnique
   */
  export type customersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null;
    /**
     * Filter, which customers to fetch.
     */
    where: customersWhereUniqueInput;
  };

  /**
   * customers findUniqueOrThrow
   */
  export type customersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null;
    /**
     * Filter, which customers to fetch.
     */
    where: customersWhereUniqueInput;
  };

  /**
   * customers findFirst
   */
  export type customersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null;
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for customers.
     */
    cursor?: customersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` customers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` customers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[];
  };

  /**
   * customers findFirstOrThrow
   */
  export type customersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null;
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for customers.
     */
    cursor?: customersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` customers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` customers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[];
  };

  /**
   * customers findMany
   */
  export type customersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null;
    /**
     * Filter, which customers to fetch.
     */
    where?: customersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of customers to fetch.
     */
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing customers.
     */
    cursor?: customersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` customers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` customers.
     */
    skip?: number;
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[];
  };

  /**
   * customers create
   */
  export type customersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null;
    /**
     * The data needed to create a customers.
     */
    data: XOR<customersCreateInput, customersUncheckedCreateInput>;
  };

  /**
   * customers createMany
   */
  export type customersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customersCreateManyInput | customersCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * customers createManyAndReturn
   */
  export type customersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * The data used to create many customers.
     */
    data: customersCreateManyInput | customersCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * customers update
   */
  export type customersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null;
    /**
     * The data needed to update a customers.
     */
    data: XOR<customersUpdateInput, customersUncheckedUpdateInput>;
    /**
     * Choose, which customers to update.
     */
    where: customersWhereUniqueInput;
  };

  /**
   * customers updateMany
   */
  export type customersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyInput>;
    /**
     * Filter which customers to update
     */
    where?: customersWhereInput;
    /**
     * Limit how many customers to update.
     */
    limit?: number;
  };

  /**
   * customers updateManyAndReturn
   */
  export type customersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * The data used to update customers.
     */
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyInput>;
    /**
     * Filter which customers to update
     */
    where?: customersWhereInput;
    /**
     * Limit how many customers to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * customers upsert
   */
  export type customersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null;
    /**
     * The filter to search for the customers to update in case it exists.
     */
    where: customersWhereUniqueInput;
    /**
     * In case the customers found by the `where` argument doesn't exist, create a new customers with this data.
     */
    create: XOR<customersCreateInput, customersUncheckedCreateInput>;
    /**
     * In case the customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customersUpdateInput, customersUncheckedUpdateInput>;
  };

  /**
   * customers delete
   */
  export type customersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null;
    /**
     * Filter which customers to delete.
     */
    where: customersWhereUniqueInput;
  };

  /**
   * customers deleteMany
   */
  export type customersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customersWhereInput;
    /**
     * Limit how many customers to delete.
     */
    limit?: number;
  };

  /**
   * customers.rentals
   */
  export type customers$rentalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
    where?: rentalsWhereInput;
    orderBy?: rentalsOrderByWithRelationInput | rentalsOrderByWithRelationInput[];
    cursor?: rentalsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RentalsScalarFieldEnum | RentalsScalarFieldEnum[];
  };

  /**
   * customers without action
   */
  export type customersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null;
  };

  /**
   * Model firms
   */

  export type AggregateFirms = {
    _count: FirmsCountAggregateOutputType | null;
    _min: FirmsMinAggregateOutputType | null;
    _max: FirmsMaxAggregateOutputType | null;
  };

  export type FirmsMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    mobile: string | null;
    email: string | null;
    gst_number: string | null;
    address: string | null;
    city: string | null;
    state: string | null;
    country: string | null;
    pin_code: string | null;
    description: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type FirmsMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    mobile: string | null;
    email: string | null;
    gst_number: string | null;
    address: string | null;
    city: string | null;
    state: string | null;
    country: string | null;
    pin_code: string | null;
    description: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type FirmsCountAggregateOutputType = {
    id: number;
    name: number;
    mobile: number;
    email: number;
    media: number;
    gst_number: number;
    address: number;
    city: number;
    state: number;
    country: number;
    pin_code: number;
    description: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type FirmsMinAggregateInputType = {
    id?: true;
    name?: true;
    mobile?: true;
    email?: true;
    gst_number?: true;
    address?: true;
    city?: true;
    state?: true;
    country?: true;
    pin_code?: true;
    description?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type FirmsMaxAggregateInputType = {
    id?: true;
    name?: true;
    mobile?: true;
    email?: true;
    gst_number?: true;
    address?: true;
    city?: true;
    state?: true;
    country?: true;
    pin_code?: true;
    description?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type FirmsCountAggregateInputType = {
    id?: true;
    name?: true;
    mobile?: true;
    email?: true;
    media?: true;
    gst_number?: true;
    address?: true;
    city?: true;
    state?: true;
    country?: true;
    pin_code?: true;
    description?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type FirmsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which firms to aggregate.
     */
    where?: firmsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of firms to fetch.
     */
    orderBy?: firmsOrderByWithRelationInput | firmsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: firmsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` firms from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` firms.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned firms
     **/
    _count?: true | FirmsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FirmsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FirmsMaxAggregateInputType;
  };

  export type GetFirmsAggregateType<T extends FirmsAggregateArgs> = {
    [P in keyof T & keyof AggregateFirms]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFirms[P]>
      : GetScalarType<T[P], AggregateFirms[P]>;
  };

  export type firmsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: firmsWhereInput;
    orderBy?: firmsOrderByWithAggregationInput | firmsOrderByWithAggregationInput[];
    by: FirmsScalarFieldEnum[] | FirmsScalarFieldEnum;
    having?: firmsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FirmsCountAggregateInputType | true;
    _min?: FirmsMinAggregateInputType;
    _max?: FirmsMaxAggregateInputType;
  };

  export type FirmsGroupByOutputType = {
    id: string;
    name: string;
    mobile: string | null;
    email: string | null;
    media: string[];
    gst_number: string | null;
    address: string | null;
    city: string | null;
    state: string | null;
    country: string | null;
    pin_code: string | null;
    description: string | null;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: FirmsCountAggregateOutputType | null;
    _min: FirmsMinAggregateOutputType | null;
    _max: FirmsMaxAggregateOutputType | null;
  };

  type GetFirmsGroupByPayload<T extends firmsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FirmsGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof FirmsGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], FirmsGroupByOutputType[P]>
          : GetScalarType<T[P], FirmsGroupByOutputType[P]>;
      }
    >
  >;

  export type firmsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      mobile?: boolean;
      email?: boolean;
      media?: boolean;
      gst_number?: boolean;
      address?: boolean;
      city?: boolean;
      state?: boolean;
      country?: boolean;
      pin_code?: boolean;
      description?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      modified_at?: boolean;
      created_at?: boolean;
      created_by?: boolean;
      modified_by?: boolean;
      products?: boolean | firms$productsArgs<ExtArgs>;
      terms_and_conditions?: boolean | firms$terms_and_conditionsArgs<ExtArgs>;
      payment_collections?: boolean | firms$payment_collectionsArgs<ExtArgs>;
      payment_modes?: boolean | firms$payment_modesArgs<ExtArgs>;
      customers?: boolean | firms$customersArgs<ExtArgs>;
      owners?: boolean | firms$ownersArgs<ExtArgs>;
      _count?: boolean | FirmsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["firms"]
  >;

  export type firmsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        mobile?: boolean;
        email?: boolean;
        media?: boolean;
        gst_number?: boolean;
        address?: boolean;
        city?: boolean;
        state?: boolean;
        country?: boolean;
        pin_code?: boolean;
        description?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["firms"]
    >;

  export type firmsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        mobile?: boolean;
        email?: boolean;
        media?: boolean;
        gst_number?: boolean;
        address?: boolean;
        city?: boolean;
        state?: boolean;
        country?: boolean;
        pin_code?: boolean;
        description?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["firms"]
    >;

  export type firmsSelectScalar = {
    id?: boolean;
    name?: boolean;
    mobile?: boolean;
    email?: boolean;
    media?: boolean;
    gst_number?: boolean;
    address?: boolean;
    city?: boolean;
    state?: boolean;
    country?: boolean;
    pin_code?: boolean;
    description?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type firmsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "name"
    | "mobile"
    | "email"
    | "media"
    | "gst_number"
    | "address"
    | "city"
    | "state"
    | "country"
    | "pin_code"
    | "description"
    | "active_flag"
    | "delete_flag"
    | "modified_at"
    | "created_at"
    | "created_by"
    | "modified_by",
    ExtArgs["result"]["firms"]
  >;
  export type firmsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | firms$productsArgs<ExtArgs>;
    terms_and_conditions?: boolean | firms$terms_and_conditionsArgs<ExtArgs>;
    payment_collections?: boolean | firms$payment_collectionsArgs<ExtArgs>;
    payment_modes?: boolean | firms$payment_modesArgs<ExtArgs>;
    customers?: boolean | firms$customersArgs<ExtArgs>;
    owners?: boolean | firms$ownersArgs<ExtArgs>;
    _count?: boolean | FirmsCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type firmsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {};
  export type firmsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {};

  export type $firmsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "firms";
    objects: {
      products: Prisma.$productsPayload<ExtArgs>[];
      terms_and_conditions: Prisma.$terms_and_conditionsPayload<ExtArgs>[];
      payment_collections: Prisma.$payment_collectionsPayload<ExtArgs>[];
      payment_modes: Prisma.$payment_modesPayload<ExtArgs>[];
      customers: Prisma.$customersPayload<ExtArgs>[];
      owners: Prisma.$ownersPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        mobile: string | null;
        email: string | null;
        media: string[];
        gst_number: string | null;
        address: string | null;
        city: string | null;
        state: string | null;
        country: string | null;
        pin_code: string | null;
        description: string | null;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["firms"]
    >;
    composites: {};
  };

  type firmsGetPayload<S extends boolean | null | undefined | firmsDefaultArgs> = $Result.GetResult<
    Prisma.$firmsPayload,
    S
  >;

  type firmsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    firmsFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: FirmsCountAggregateInputType | true;
  };

  export interface firmsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["firms"]; meta: { name: "firms" } };
    /**
     * Find zero or one Firms that matches the filter.
     * @param {firmsFindUniqueArgs} args - Arguments to find a Firms
     * @example
     * // Get one Firms
     * const firms = await prisma.firms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends firmsFindUniqueArgs>(
      args: SelectSubset<T, firmsFindUniqueArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Firms that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {firmsFindUniqueOrThrowArgs} args - Arguments to find a Firms
     * @example
     * // Get one Firms
     * const firms = await prisma.firms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends firmsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, firmsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Firms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {firmsFindFirstArgs} args - Arguments to find a Firms
     * @example
     * // Get one Firms
     * const firms = await prisma.firms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends firmsFindFirstArgs>(
      args?: SelectSubset<T, firmsFindFirstArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Firms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {firmsFindFirstOrThrowArgs} args - Arguments to find a Firms
     * @example
     * // Get one Firms
     * const firms = await prisma.firms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends firmsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, firmsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Firms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {firmsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Firms
     * const firms = await prisma.firms.findMany()
     *
     * // Get first 10 Firms
     * const firms = await prisma.firms.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const firmsWithIdOnly = await prisma.firms.findMany({ select: { id: true } })
     *
     */
    findMany<T extends firmsFindManyArgs>(
      args?: SelectSubset<T, firmsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Firms.
     * @param {firmsCreateArgs} args - Arguments to create a Firms.
     * @example
     * // Create one Firms
     * const Firms = await prisma.firms.create({
     *   data: {
     *     // ... data to create a Firms
     *   }
     * })
     *
     */
    create<T extends firmsCreateArgs>(
      args: SelectSubset<T, firmsCreateArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Firms.
     * @param {firmsCreateManyArgs} args - Arguments to create many Firms.
     * @example
     * // Create many Firms
     * const firms = await prisma.firms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends firmsCreateManyArgs>(
      args?: SelectSubset<T, firmsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Firms and returns the data saved in the database.
     * @param {firmsCreateManyAndReturnArgs} args - Arguments to create many Firms.
     * @example
     * // Create many Firms
     * const firms = await prisma.firms.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Firms and only return the `id`
     * const firmsWithIdOnly = await prisma.firms.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends firmsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, firmsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Firms.
     * @param {firmsDeleteArgs} args - Arguments to delete one Firms.
     * @example
     * // Delete one Firms
     * const Firms = await prisma.firms.delete({
     *   where: {
     *     // ... filter to delete one Firms
     *   }
     * })
     *
     */
    delete<T extends firmsDeleteArgs>(
      args: SelectSubset<T, firmsDeleteArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Firms.
     * @param {firmsUpdateArgs} args - Arguments to update one Firms.
     * @example
     * // Update one Firms
     * const firms = await prisma.firms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends firmsUpdateArgs>(
      args: SelectSubset<T, firmsUpdateArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Firms.
     * @param {firmsDeleteManyArgs} args - Arguments to filter Firms to delete.
     * @example
     * // Delete a few Firms
     * const { count } = await prisma.firms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends firmsDeleteManyArgs>(
      args?: SelectSubset<T, firmsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Firms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {firmsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Firms
     * const firms = await prisma.firms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends firmsUpdateManyArgs>(
      args: SelectSubset<T, firmsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Firms and returns the data updated in the database.
     * @param {firmsUpdateManyAndReturnArgs} args - Arguments to update many Firms.
     * @example
     * // Update many Firms
     * const firms = await prisma.firms.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Firms and only return the `id`
     * const firmsWithIdOnly = await prisma.firms.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends firmsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, firmsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Firms.
     * @param {firmsUpsertArgs} args - Arguments to update or create a Firms.
     * @example
     * // Update or create a Firms
     * const firms = await prisma.firms.upsert({
     *   create: {
     *     // ... data to create a Firms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Firms we want to update
     *   }
     * })
     */
    upsert<T extends firmsUpsertArgs>(
      args: SelectSubset<T, firmsUpsertArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Firms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {firmsCountArgs} args - Arguments to filter Firms to count.
     * @example
     * // Count the number of Firms
     * const count = await prisma.firms.count({
     *   where: {
     *     // ... the filter for the Firms we want to count
     *   }
     * })
     **/
    count<T extends firmsCountArgs>(
      args?: Subset<T, firmsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], FirmsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Firms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FirmsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FirmsAggregateArgs>(
      args: Subset<T, FirmsAggregateArgs>,
    ): Prisma.PrismaPromise<GetFirmsAggregateType<T>>;

    /**
     * Group by Firms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {firmsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends firmsGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: firmsGroupByArgs["orderBy"] }
        : { orderBy?: firmsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, firmsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetFirmsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the firms model
     */
    readonly fields: firmsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for firms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__firmsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    products<T extends firms$productsArgs<ExtArgs> = {}>(
      args?: Subset<T, firms$productsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    terms_and_conditions<T extends firms$terms_and_conditionsArgs<ExtArgs> = {}>(
      args?: Subset<T, firms$terms_and_conditionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    payment_collections<T extends firms$payment_collectionsArgs<ExtArgs> = {}>(
      args?: Subset<T, firms$payment_collectionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    payment_modes<T extends firms$payment_modesArgs<ExtArgs> = {}>(
      args?: Subset<T, firms$payment_modesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    customers<T extends firms$customersArgs<ExtArgs> = {}>(
      args?: Subset<T, firms$customersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    owners<T extends firms$ownersArgs<ExtArgs> = {}>(
      args?: Subset<T, firms$ownersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ownersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the firms model
   */
  interface firmsFieldRefs {
    readonly id: FieldRef<"firms", "String">;
    readonly name: FieldRef<"firms", "String">;
    readonly mobile: FieldRef<"firms", "String">;
    readonly email: FieldRef<"firms", "String">;
    readonly media: FieldRef<"firms", "String[]">;
    readonly gst_number: FieldRef<"firms", "String">;
    readonly address: FieldRef<"firms", "String">;
    readonly city: FieldRef<"firms", "String">;
    readonly state: FieldRef<"firms", "String">;
    readonly country: FieldRef<"firms", "String">;
    readonly pin_code: FieldRef<"firms", "String">;
    readonly description: FieldRef<"firms", "String">;
    readonly active_flag: FieldRef<"firms", "Boolean">;
    readonly delete_flag: FieldRef<"firms", "Boolean">;
    readonly modified_at: FieldRef<"firms", "DateTime">;
    readonly created_at: FieldRef<"firms", "DateTime">;
    readonly created_by: FieldRef<"firms", "String">;
    readonly modified_by: FieldRef<"firms", "String">;
  }

  // Custom InputTypes
  /**
   * firms findUnique
   */
  export type firmsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
    /**
     * Filter, which firms to fetch.
     */
    where: firmsWhereUniqueInput;
  };

  /**
   * firms findUniqueOrThrow
   */
  export type firmsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
    /**
     * Filter, which firms to fetch.
     */
    where: firmsWhereUniqueInput;
  };

  /**
   * firms findFirst
   */
  export type firmsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
    /**
     * Filter, which firms to fetch.
     */
    where?: firmsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of firms to fetch.
     */
    orderBy?: firmsOrderByWithRelationInput | firmsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for firms.
     */
    cursor?: firmsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` firms from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` firms.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of firms.
     */
    distinct?: FirmsScalarFieldEnum | FirmsScalarFieldEnum[];
  };

  /**
   * firms findFirstOrThrow
   */
  export type firmsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
    /**
     * Filter, which firms to fetch.
     */
    where?: firmsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of firms to fetch.
     */
    orderBy?: firmsOrderByWithRelationInput | firmsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for firms.
     */
    cursor?: firmsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` firms from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` firms.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of firms.
     */
    distinct?: FirmsScalarFieldEnum | FirmsScalarFieldEnum[];
  };

  /**
   * firms findMany
   */
  export type firmsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
    /**
     * Filter, which firms to fetch.
     */
    where?: firmsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of firms to fetch.
     */
    orderBy?: firmsOrderByWithRelationInput | firmsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing firms.
     */
    cursor?: firmsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` firms from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` firms.
     */
    skip?: number;
    distinct?: FirmsScalarFieldEnum | FirmsScalarFieldEnum[];
  };

  /**
   * firms create
   */
  export type firmsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
    /**
     * The data needed to create a firms.
     */
    data: XOR<firmsCreateInput, firmsUncheckedCreateInput>;
  };

  /**
   * firms createMany
   */
  export type firmsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many firms.
     */
    data: firmsCreateManyInput | firmsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * firms createManyAndReturn
   */
  export type firmsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * The data used to create many firms.
     */
    data: firmsCreateManyInput | firmsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * firms update
   */
  export type firmsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
    /**
     * The data needed to update a firms.
     */
    data: XOR<firmsUpdateInput, firmsUncheckedUpdateInput>;
    /**
     * Choose, which firms to update.
     */
    where: firmsWhereUniqueInput;
  };

  /**
   * firms updateMany
   */
  export type firmsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update firms.
     */
    data: XOR<firmsUpdateManyMutationInput, firmsUncheckedUpdateManyInput>;
    /**
     * Filter which firms to update
     */
    where?: firmsWhereInput;
    /**
     * Limit how many firms to update.
     */
    limit?: number;
  };

  /**
   * firms updateManyAndReturn
   */
  export type firmsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * The data used to update firms.
     */
    data: XOR<firmsUpdateManyMutationInput, firmsUncheckedUpdateManyInput>;
    /**
     * Filter which firms to update
     */
    where?: firmsWhereInput;
    /**
     * Limit how many firms to update.
     */
    limit?: number;
  };

  /**
   * firms upsert
   */
  export type firmsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
    /**
     * The filter to search for the firms to update in case it exists.
     */
    where: firmsWhereUniqueInput;
    /**
     * In case the firms found by the `where` argument doesn't exist, create a new firms with this data.
     */
    create: XOR<firmsCreateInput, firmsUncheckedCreateInput>;
    /**
     * In case the firms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<firmsUpdateInput, firmsUncheckedUpdateInput>;
  };

  /**
   * firms delete
   */
  export type firmsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
    /**
     * Filter which firms to delete.
     */
    where: firmsWhereUniqueInput;
  };

  /**
   * firms deleteMany
   */
  export type firmsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which firms to delete
     */
    where?: firmsWhereInput;
    /**
     * Limit how many firms to delete.
     */
    limit?: number;
  };

  /**
   * firms.products
   */
  export type firms$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null;
    where?: productsWhereInput;
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[];
    cursor?: productsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[];
  };

  /**
   * firms.terms_and_conditions
   */
  export type firms$terms_and_conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null;
    where?: terms_and_conditionsWhereInput;
    orderBy?: terms_and_conditionsOrderByWithRelationInput | terms_and_conditionsOrderByWithRelationInput[];
    cursor?: terms_and_conditionsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: Terms_and_conditionsScalarFieldEnum | Terms_and_conditionsScalarFieldEnum[];
  };

  /**
   * firms.payment_collections
   */
  export type firms$payment_collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
    where?: payment_collectionsWhereInput;
    orderBy?: payment_collectionsOrderByWithRelationInput | payment_collectionsOrderByWithRelationInput[];
    cursor?: payment_collectionsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: Payment_collectionsScalarFieldEnum | Payment_collectionsScalarFieldEnum[];
  };

  /**
   * firms.payment_modes
   */
  export type firms$payment_modesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_modes
     */
    select?: payment_modesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_modes
     */
    omit?: payment_modesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_modesInclude<ExtArgs> | null;
    where?: payment_modesWhereInput;
    orderBy?: payment_modesOrderByWithRelationInput | payment_modesOrderByWithRelationInput[];
    cursor?: payment_modesWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: Payment_modesScalarFieldEnum | Payment_modesScalarFieldEnum[];
  };

  /**
   * firms.customers
   */
  export type firms$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null;
    where?: customersWhereInput;
    orderBy?: customersOrderByWithRelationInput | customersOrderByWithRelationInput[];
    cursor?: customersWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[];
  };

  /**
   * firms.owners
   */
  export type firms$ownersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersInclude<ExtArgs> | null;
    where?: ownersWhereInput;
    orderBy?: ownersOrderByWithRelationInput | ownersOrderByWithRelationInput[];
    cursor?: ownersWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: OwnersScalarFieldEnum | OwnersScalarFieldEnum[];
  };

  /**
   * firms without action
   */
  export type firmsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
  };

  /**
   * Model owners
   */

  export type AggregateOwners = {
    _count: OwnersCountAggregateOutputType | null;
    _min: OwnersMinAggregateOutputType | null;
    _max: OwnersMaxAggregateOutputType | null;
  };

  export type OwnersMinAggregateOutputType = {
    id: string | null;
    firm_id: string | null;
    full_name: string | null;
    mobile: string | null;
    email: string | null;
    image: string | null;
    username: string | null;
    alternate_mobile: string | null;
    address: string | null;
    city: string | null;
    state: string | null;
    country: string | null;
    pin_code: string | null;
    adhaar_number: string | null;
    driving_license_number: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type OwnersMaxAggregateOutputType = {
    id: string | null;
    firm_id: string | null;
    full_name: string | null;
    mobile: string | null;
    email: string | null;
    image: string | null;
    username: string | null;
    alternate_mobile: string | null;
    address: string | null;
    city: string | null;
    state: string | null;
    country: string | null;
    pin_code: string | null;
    adhaar_number: string | null;
    driving_license_number: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type OwnersCountAggregateOutputType = {
    id: number;
    firm_id: number;
    full_name: number;
    mobile: number;
    email: number;
    image: number;
    username: number;
    alternate_mobile: number;
    address: number;
    documents: number;
    city: number;
    state: number;
    country: number;
    pin_code: number;
    adhaar_number: number;
    driving_license_number: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type OwnersMinAggregateInputType = {
    id?: true;
    firm_id?: true;
    full_name?: true;
    mobile?: true;
    email?: true;
    image?: true;
    username?: true;
    alternate_mobile?: true;
    address?: true;
    city?: true;
    state?: true;
    country?: true;
    pin_code?: true;
    adhaar_number?: true;
    driving_license_number?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type OwnersMaxAggregateInputType = {
    id?: true;
    firm_id?: true;
    full_name?: true;
    mobile?: true;
    email?: true;
    image?: true;
    username?: true;
    alternate_mobile?: true;
    address?: true;
    city?: true;
    state?: true;
    country?: true;
    pin_code?: true;
    adhaar_number?: true;
    driving_license_number?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type OwnersCountAggregateInputType = {
    id?: true;
    firm_id?: true;
    full_name?: true;
    mobile?: true;
    email?: true;
    image?: true;
    username?: true;
    alternate_mobile?: true;
    address?: true;
    documents?: true;
    city?: true;
    state?: true;
    country?: true;
    pin_code?: true;
    adhaar_number?: true;
    driving_license_number?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type OwnersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which owners to aggregate.
     */
    where?: ownersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of owners to fetch.
     */
    orderBy?: ownersOrderByWithRelationInput | ownersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ownersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` owners from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` owners.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned owners
     **/
    _count?: true | OwnersCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: OwnersMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: OwnersMaxAggregateInputType;
  };

  export type GetOwnersAggregateType<T extends OwnersAggregateArgs> = {
    [P in keyof T & keyof AggregateOwners]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwners[P]>
      : GetScalarType<T[P], AggregateOwners[P]>;
  };

  export type ownersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ownersWhereInput;
    orderBy?: ownersOrderByWithAggregationInput | ownersOrderByWithAggregationInput[];
    by: OwnersScalarFieldEnum[] | OwnersScalarFieldEnum;
    having?: ownersScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: OwnersCountAggregateInputType | true;
    _min?: OwnersMinAggregateInputType;
    _max?: OwnersMaxAggregateInputType;
  };

  export type OwnersGroupByOutputType = {
    id: string;
    firm_id: string;
    full_name: string | null;
    mobile: string | null;
    email: string | null;
    image: string | null;
    username: string | null;
    alternate_mobile: string | null;
    address: string | null;
    documents: string[];
    city: string | null;
    state: string | null;
    country: string | null;
    pin_code: string | null;
    adhaar_number: string | null;
    driving_license_number: string | null;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: OwnersCountAggregateOutputType | null;
    _min: OwnersMinAggregateOutputType | null;
    _max: OwnersMaxAggregateOutputType | null;
  };

  type GetOwnersGroupByPayload<T extends ownersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnersGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof OwnersGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], OwnersGroupByOutputType[P]>
          : GetScalarType<T[P], OwnersGroupByOutputType[P]>;
      }
    >
  >;

  export type ownersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
    {
      id?: boolean;
      firm_id?: boolean;
      full_name?: boolean;
      mobile?: boolean;
      email?: boolean;
      image?: boolean;
      username?: boolean;
      alternate_mobile?: boolean;
      address?: boolean;
      documents?: boolean;
      city?: boolean;
      state?: boolean;
      country?: boolean;
      pin_code?: boolean;
      adhaar_number?: boolean;
      driving_license_number?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      modified_at?: boolean;
      created_at?: boolean;
      created_by?: boolean;
      modified_by?: boolean;
      firm?: boolean | owners$firmArgs<ExtArgs>;
    },
    ExtArgs["result"]["owners"]
  >;

  export type ownersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        firm_id?: boolean;
        full_name?: boolean;
        mobile?: boolean;
        email?: boolean;
        image?: boolean;
        username?: boolean;
        alternate_mobile?: boolean;
        address?: boolean;
        documents?: boolean;
        city?: boolean;
        state?: boolean;
        country?: boolean;
        pin_code?: boolean;
        adhaar_number?: boolean;
        driving_license_number?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
        firm?: boolean | owners$firmArgs<ExtArgs>;
      },
      ExtArgs["result"]["owners"]
    >;

  export type ownersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        firm_id?: boolean;
        full_name?: boolean;
        mobile?: boolean;
        email?: boolean;
        image?: boolean;
        username?: boolean;
        alternate_mobile?: boolean;
        address?: boolean;
        documents?: boolean;
        city?: boolean;
        state?: boolean;
        country?: boolean;
        pin_code?: boolean;
        adhaar_number?: boolean;
        driving_license_number?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
        firm?: boolean | owners$firmArgs<ExtArgs>;
      },
      ExtArgs["result"]["owners"]
    >;

  export type ownersSelectScalar = {
    id?: boolean;
    firm_id?: boolean;
    full_name?: boolean;
    mobile?: boolean;
    email?: boolean;
    image?: boolean;
    username?: boolean;
    alternate_mobile?: boolean;
    address?: boolean;
    documents?: boolean;
    city?: boolean;
    state?: boolean;
    country?: boolean;
    pin_code?: boolean;
    adhaar_number?: boolean;
    driving_license_number?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type ownersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "firm_id"
    | "full_name"
    | "mobile"
    | "email"
    | "image"
    | "username"
    | "alternate_mobile"
    | "address"
    | "documents"
    | "city"
    | "state"
    | "country"
    | "pin_code"
    | "adhaar_number"
    | "driving_license_number"
    | "active_flag"
    | "delete_flag"
    | "modified_at"
    | "created_at"
    | "created_by"
    | "modified_by",
    ExtArgs["result"]["owners"]
  >;
  export type ownersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    firm?: boolean | owners$firmArgs<ExtArgs>;
  };
  export type ownersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    firm?: boolean | owners$firmArgs<ExtArgs>;
  };
  export type ownersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    firm?: boolean | owners$firmArgs<ExtArgs>;
  };

  export type $ownersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "owners";
    objects: {
      firm: Prisma.$firmsPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        firm_id: string;
        full_name: string | null;
        mobile: string | null;
        email: string | null;
        image: string | null;
        username: string | null;
        alternate_mobile: string | null;
        address: string | null;
        documents: string[];
        city: string | null;
        state: string | null;
        country: string | null;
        pin_code: string | null;
        adhaar_number: string | null;
        driving_license_number: string | null;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["owners"]
    >;
    composites: {};
  };

  type ownersGetPayload<S extends boolean | null | undefined | ownersDefaultArgs> = $Result.GetResult<
    Prisma.$ownersPayload,
    S
  >;

  type ownersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    ownersFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: OwnersCountAggregateInputType | true;
  };

  export interface ownersDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["owners"]; meta: { name: "owners" } };
    /**
     * Find zero or one Owners that matches the filter.
     * @param {ownersFindUniqueArgs} args - Arguments to find a Owners
     * @example
     * // Get one Owners
     * const owners = await prisma.owners.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ownersFindUniqueArgs>(
      args: SelectSubset<T, ownersFindUniqueArgs<ExtArgs>>,
    ): Prisma__ownersClient<
      $Result.GetResult<Prisma.$ownersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Owners that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ownersFindUniqueOrThrowArgs} args - Arguments to find a Owners
     * @example
     * // Get one Owners
     * const owners = await prisma.owners.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ownersFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ownersFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ownersClient<
      $Result.GetResult<Prisma.$ownersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Owners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ownersFindFirstArgs} args - Arguments to find a Owners
     * @example
     * // Get one Owners
     * const owners = await prisma.owners.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ownersFindFirstArgs>(
      args?: SelectSubset<T, ownersFindFirstArgs<ExtArgs>>,
    ): Prisma__ownersClient<
      $Result.GetResult<Prisma.$ownersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Owners that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ownersFindFirstOrThrowArgs} args - Arguments to find a Owners
     * @example
     * // Get one Owners
     * const owners = await prisma.owners.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ownersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ownersFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ownersClient<
      $Result.GetResult<Prisma.$ownersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Owners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ownersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Owners
     * const owners = await prisma.owners.findMany()
     *
     * // Get first 10 Owners
     * const owners = await prisma.owners.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const ownersWithIdOnly = await prisma.owners.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ownersFindManyArgs>(
      args?: SelectSubset<T, ownersFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ownersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Owners.
     * @param {ownersCreateArgs} args - Arguments to create a Owners.
     * @example
     * // Create one Owners
     * const Owners = await prisma.owners.create({
     *   data: {
     *     // ... data to create a Owners
     *   }
     * })
     *
     */
    create<T extends ownersCreateArgs>(
      args: SelectSubset<T, ownersCreateArgs<ExtArgs>>,
    ): Prisma__ownersClient<
      $Result.GetResult<Prisma.$ownersPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Owners.
     * @param {ownersCreateManyArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owners = await prisma.owners.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ownersCreateManyArgs>(
      args?: SelectSubset<T, ownersCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Owners and returns the data saved in the database.
     * @param {ownersCreateManyAndReturnArgs} args - Arguments to create many Owners.
     * @example
     * // Create many Owners
     * const owners = await prisma.owners.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Owners and only return the `id`
     * const ownersWithIdOnly = await prisma.owners.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ownersCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ownersCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ownersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Owners.
     * @param {ownersDeleteArgs} args - Arguments to delete one Owners.
     * @example
     * // Delete one Owners
     * const Owners = await prisma.owners.delete({
     *   where: {
     *     // ... filter to delete one Owners
     *   }
     * })
     *
     */
    delete<T extends ownersDeleteArgs>(
      args: SelectSubset<T, ownersDeleteArgs<ExtArgs>>,
    ): Prisma__ownersClient<
      $Result.GetResult<Prisma.$ownersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Owners.
     * @param {ownersUpdateArgs} args - Arguments to update one Owners.
     * @example
     * // Update one Owners
     * const owners = await prisma.owners.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ownersUpdateArgs>(
      args: SelectSubset<T, ownersUpdateArgs<ExtArgs>>,
    ): Prisma__ownersClient<
      $Result.GetResult<Prisma.$ownersPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Owners.
     * @param {ownersDeleteManyArgs} args - Arguments to filter Owners to delete.
     * @example
     * // Delete a few Owners
     * const { count } = await prisma.owners.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ownersDeleteManyArgs>(
      args?: SelectSubset<T, ownersDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ownersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Owners
     * const owners = await prisma.owners.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ownersUpdateManyArgs>(
      args: SelectSubset<T, ownersUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Owners and returns the data updated in the database.
     * @param {ownersUpdateManyAndReturnArgs} args - Arguments to update many Owners.
     * @example
     * // Update many Owners
     * const owners = await prisma.owners.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Owners and only return the `id`
     * const ownersWithIdOnly = await prisma.owners.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ownersUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ownersUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ownersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Owners.
     * @param {ownersUpsertArgs} args - Arguments to update or create a Owners.
     * @example
     * // Update or create a Owners
     * const owners = await prisma.owners.upsert({
     *   create: {
     *     // ... data to create a Owners
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Owners we want to update
     *   }
     * })
     */
    upsert<T extends ownersUpsertArgs>(
      args: SelectSubset<T, ownersUpsertArgs<ExtArgs>>,
    ): Prisma__ownersClient<
      $Result.GetResult<Prisma.$ownersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ownersCountArgs} args - Arguments to filter Owners to count.
     * @example
     * // Count the number of Owners
     * const count = await prisma.owners.count({
     *   where: {
     *     // ... the filter for the Owners we want to count
     *   }
     * })
     **/
    count<T extends ownersCountArgs>(
      args?: Subset<T, ownersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], OwnersCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends OwnersAggregateArgs>(
      args: Subset<T, OwnersAggregateArgs>,
    ): Prisma.PrismaPromise<GetOwnersAggregateType<T>>;

    /**
     * Group by Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ownersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ownersGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ownersGroupByArgs["orderBy"] }
        : { orderBy?: ownersGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ownersGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetOwnersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the owners model
     */
    readonly fields: ownersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for owners.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ownersClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    firm<T extends owners$firmArgs<ExtArgs> = {}>(
      args?: Subset<T, owners$firmArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the owners model
   */
  interface ownersFieldRefs {
    readonly id: FieldRef<"owners", "String">;
    readonly firm_id: FieldRef<"owners", "String">;
    readonly full_name: FieldRef<"owners", "String">;
    readonly mobile: FieldRef<"owners", "String">;
    readonly email: FieldRef<"owners", "String">;
    readonly image: FieldRef<"owners", "String">;
    readonly username: FieldRef<"owners", "String">;
    readonly alternate_mobile: FieldRef<"owners", "String">;
    readonly address: FieldRef<"owners", "String">;
    readonly documents: FieldRef<"owners", "String[]">;
    readonly city: FieldRef<"owners", "String">;
    readonly state: FieldRef<"owners", "String">;
    readonly country: FieldRef<"owners", "String">;
    readonly pin_code: FieldRef<"owners", "String">;
    readonly adhaar_number: FieldRef<"owners", "String">;
    readonly driving_license_number: FieldRef<"owners", "String">;
    readonly active_flag: FieldRef<"owners", "Boolean">;
    readonly delete_flag: FieldRef<"owners", "Boolean">;
    readonly modified_at: FieldRef<"owners", "DateTime">;
    readonly created_at: FieldRef<"owners", "DateTime">;
    readonly created_by: FieldRef<"owners", "String">;
    readonly modified_by: FieldRef<"owners", "String">;
  }

  // Custom InputTypes
  /**
   * owners findUnique
   */
  export type ownersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersInclude<ExtArgs> | null;
    /**
     * Filter, which owners to fetch.
     */
    where: ownersWhereUniqueInput;
  };

  /**
   * owners findUniqueOrThrow
   */
  export type ownersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersInclude<ExtArgs> | null;
    /**
     * Filter, which owners to fetch.
     */
    where: ownersWhereUniqueInput;
  };

  /**
   * owners findFirst
   */
  export type ownersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersInclude<ExtArgs> | null;
    /**
     * Filter, which owners to fetch.
     */
    where?: ownersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of owners to fetch.
     */
    orderBy?: ownersOrderByWithRelationInput | ownersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for owners.
     */
    cursor?: ownersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` owners from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` owners.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of owners.
     */
    distinct?: OwnersScalarFieldEnum | OwnersScalarFieldEnum[];
  };

  /**
   * owners findFirstOrThrow
   */
  export type ownersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersInclude<ExtArgs> | null;
    /**
     * Filter, which owners to fetch.
     */
    where?: ownersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of owners to fetch.
     */
    orderBy?: ownersOrderByWithRelationInput | ownersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for owners.
     */
    cursor?: ownersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` owners from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` owners.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of owners.
     */
    distinct?: OwnersScalarFieldEnum | OwnersScalarFieldEnum[];
  };

  /**
   * owners findMany
   */
  export type ownersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersInclude<ExtArgs> | null;
    /**
     * Filter, which owners to fetch.
     */
    where?: ownersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of owners to fetch.
     */
    orderBy?: ownersOrderByWithRelationInput | ownersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing owners.
     */
    cursor?: ownersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` owners from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` owners.
     */
    skip?: number;
    distinct?: OwnersScalarFieldEnum | OwnersScalarFieldEnum[];
  };

  /**
   * owners create
   */
  export type ownersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersInclude<ExtArgs> | null;
    /**
     * The data needed to create a owners.
     */
    data: XOR<ownersCreateInput, ownersUncheckedCreateInput>;
  };

  /**
   * owners createMany
   */
  export type ownersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many owners.
     */
    data: ownersCreateManyInput | ownersCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * owners createManyAndReturn
   */
  export type ownersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * The data used to create many owners.
     */
    data: ownersCreateManyInput | ownersCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * owners update
   */
  export type ownersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersInclude<ExtArgs> | null;
    /**
     * The data needed to update a owners.
     */
    data: XOR<ownersUpdateInput, ownersUncheckedUpdateInput>;
    /**
     * Choose, which owners to update.
     */
    where: ownersWhereUniqueInput;
  };

  /**
   * owners updateMany
   */
  export type ownersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update owners.
     */
    data: XOR<ownersUpdateManyMutationInput, ownersUncheckedUpdateManyInput>;
    /**
     * Filter which owners to update
     */
    where?: ownersWhereInput;
    /**
     * Limit how many owners to update.
     */
    limit?: number;
  };

  /**
   * owners updateManyAndReturn
   */
  export type ownersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * The data used to update owners.
     */
    data: XOR<ownersUpdateManyMutationInput, ownersUncheckedUpdateManyInput>;
    /**
     * Filter which owners to update
     */
    where?: ownersWhereInput;
    /**
     * Limit how many owners to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * owners upsert
   */
  export type ownersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersInclude<ExtArgs> | null;
    /**
     * The filter to search for the owners to update in case it exists.
     */
    where: ownersWhereUniqueInput;
    /**
     * In case the owners found by the `where` argument doesn't exist, create a new owners with this data.
     */
    create: XOR<ownersCreateInput, ownersUncheckedCreateInput>;
    /**
     * In case the owners was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ownersUpdateInput, ownersUncheckedUpdateInput>;
  };

  /**
   * owners delete
   */
  export type ownersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersInclude<ExtArgs> | null;
    /**
     * Filter which owners to delete.
     */
    where: ownersWhereUniqueInput;
  };

  /**
   * owners deleteMany
   */
  export type ownersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which owners to delete
     */
    where?: ownersWhereInput;
    /**
     * Limit how many owners to delete.
     */
    limit?: number;
  };

  /**
   * owners.firm
   */
  export type owners$firmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
    where?: firmsWhereInput;
  };

  /**
   * owners without action
   */
  export type ownersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the owners
     */
    select?: ownersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the owners
     */
    omit?: ownersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ownersInclude<ExtArgs> | null;
  };

  /**
   * Model payment_collections
   */

  export type AggregatePayment_collections = {
    _count: Payment_collectionsCountAggregateOutputType | null;
    _avg: Payment_collectionsAvgAggregateOutputType | null;
    _sum: Payment_collectionsSumAggregateOutputType | null;
    _min: Payment_collectionsMinAggregateOutputType | null;
    _max: Payment_collectionsMaxAggregateOutputType | null;
  };

  export type Payment_collectionsAvgAggregateOutputType = {
    amount: number | null;
  };

  export type Payment_collectionsSumAggregateOutputType = {
    amount: number | null;
  };

  export type Payment_collectionsMinAggregateOutputType = {
    id: string | null;
    rental_id: string | null;
    firm_id: string | null;
    payment_mode_id: string | null;
    amount: number | null;
    description: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type Payment_collectionsMaxAggregateOutputType = {
    id: string | null;
    rental_id: string | null;
    firm_id: string | null;
    payment_mode_id: string | null;
    amount: number | null;
    description: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type Payment_collectionsCountAggregateOutputType = {
    id: number;
    rental_id: number;
    firm_id: number;
    payment_mode_id: number;
    amount: number;
    description: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type Payment_collectionsAvgAggregateInputType = {
    amount?: true;
  };

  export type Payment_collectionsSumAggregateInputType = {
    amount?: true;
  };

  export type Payment_collectionsMinAggregateInputType = {
    id?: true;
    rental_id?: true;
    firm_id?: true;
    payment_mode_id?: true;
    amount?: true;
    description?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type Payment_collectionsMaxAggregateInputType = {
    id?: true;
    rental_id?: true;
    firm_id?: true;
    payment_mode_id?: true;
    amount?: true;
    description?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type Payment_collectionsCountAggregateInputType = {
    id?: true;
    rental_id?: true;
    firm_id?: true;
    payment_mode_id?: true;
    amount?: true;
    description?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type Payment_collectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_collections to aggregate.
     */
    where?: payment_collectionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of payment_collections to fetch.
     */
    orderBy?: payment_collectionsOrderByWithRelationInput | payment_collectionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: payment_collectionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` payment_collections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` payment_collections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned payment_collections
     **/
    _count?: true | Payment_collectionsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: Payment_collectionsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: Payment_collectionsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Payment_collectionsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Payment_collectionsMaxAggregateInputType;
  };

  export type GetPayment_collectionsAggregateType<T extends Payment_collectionsAggregateArgs> = {
    [P in keyof T & keyof AggregatePayment_collections]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_collections[P]>
      : GetScalarType<T[P], AggregatePayment_collections[P]>;
  };

  export type payment_collectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_collectionsWhereInput;
    orderBy?: payment_collectionsOrderByWithAggregationInput | payment_collectionsOrderByWithAggregationInput[];
    by: Payment_collectionsScalarFieldEnum[] | Payment_collectionsScalarFieldEnum;
    having?: payment_collectionsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Payment_collectionsCountAggregateInputType | true;
    _avg?: Payment_collectionsAvgAggregateInputType;
    _sum?: Payment_collectionsSumAggregateInputType;
    _min?: Payment_collectionsMinAggregateInputType;
    _max?: Payment_collectionsMaxAggregateInputType;
  };

  export type Payment_collectionsGroupByOutputType = {
    id: string;
    rental_id: string;
    firm_id: string;
    payment_mode_id: string;
    amount: number;
    description: string | null;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: Payment_collectionsCountAggregateOutputType | null;
    _avg: Payment_collectionsAvgAggregateOutputType | null;
    _sum: Payment_collectionsSumAggregateOutputType | null;
    _min: Payment_collectionsMinAggregateOutputType | null;
    _max: Payment_collectionsMaxAggregateOutputType | null;
  };

  type GetPayment_collectionsGroupByPayload<T extends payment_collectionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_collectionsGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof Payment_collectionsGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], Payment_collectionsGroupByOutputType[P]>
          : GetScalarType<T[P], Payment_collectionsGroupByOutputType[P]>;
      }
    >
  >;

  export type payment_collectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        rental_id?: boolean;
        firm_id?: boolean;
        payment_mode_id?: boolean;
        amount?: boolean;
        description?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
        firm?: boolean | payment_collections$firmArgs<ExtArgs>;
        payment_mode?: boolean | payment_collections$payment_modeArgs<ExtArgs>;
        rental?: boolean | payment_collections$rentalArgs<ExtArgs>;
      },
      ExtArgs["result"]["payment_collections"]
    >;

  export type payment_collectionsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      rental_id?: boolean;
      firm_id?: boolean;
      payment_mode_id?: boolean;
      amount?: boolean;
      description?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      modified_at?: boolean;
      created_at?: boolean;
      created_by?: boolean;
      modified_by?: boolean;
      firm?: boolean | payment_collections$firmArgs<ExtArgs>;
      payment_mode?: boolean | payment_collections$payment_modeArgs<ExtArgs>;
      rental?: boolean | payment_collections$rentalArgs<ExtArgs>;
    },
    ExtArgs["result"]["payment_collections"]
  >;

  export type payment_collectionsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      rental_id?: boolean;
      firm_id?: boolean;
      payment_mode_id?: boolean;
      amount?: boolean;
      description?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      modified_at?: boolean;
      created_at?: boolean;
      created_by?: boolean;
      modified_by?: boolean;
      firm?: boolean | payment_collections$firmArgs<ExtArgs>;
      payment_mode?: boolean | payment_collections$payment_modeArgs<ExtArgs>;
      rental?: boolean | payment_collections$rentalArgs<ExtArgs>;
    },
    ExtArgs["result"]["payment_collections"]
  >;

  export type payment_collectionsSelectScalar = {
    id?: boolean;
    rental_id?: boolean;
    firm_id?: boolean;
    payment_mode_id?: boolean;
    amount?: boolean;
    description?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type payment_collectionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "rental_id"
      | "firm_id"
      | "payment_mode_id"
      | "amount"
      | "description"
      | "active_flag"
      | "delete_flag"
      | "modified_at"
      | "created_at"
      | "created_by"
      | "modified_by",
      ExtArgs["result"]["payment_collections"]
    >;
  export type payment_collectionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    firm?: boolean | payment_collections$firmArgs<ExtArgs>;
    payment_mode?: boolean | payment_collections$payment_modeArgs<ExtArgs>;
    rental?: boolean | payment_collections$rentalArgs<ExtArgs>;
  };
  export type payment_collectionsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    firm?: boolean | payment_collections$firmArgs<ExtArgs>;
    payment_mode?: boolean | payment_collections$payment_modeArgs<ExtArgs>;
    rental?: boolean | payment_collections$rentalArgs<ExtArgs>;
  };
  export type payment_collectionsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    firm?: boolean | payment_collections$firmArgs<ExtArgs>;
    payment_mode?: boolean | payment_collections$payment_modeArgs<ExtArgs>;
    rental?: boolean | payment_collections$rentalArgs<ExtArgs>;
  };

  export type $payment_collectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_collections";
    objects: {
      firm: Prisma.$firmsPayload<ExtArgs> | null;
      payment_mode: Prisma.$payment_modesPayload<ExtArgs> | null;
      rental: Prisma.$rentalsPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        rental_id: string;
        firm_id: string;
        payment_mode_id: string;
        amount: number;
        description: string | null;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["payment_collections"]
    >;
    composites: {};
  };

  type payment_collectionsGetPayload<S extends boolean | null | undefined | payment_collectionsDefaultArgs> =
    $Result.GetResult<Prisma.$payment_collectionsPayload, S>;

  type payment_collectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    payment_collectionsFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: Payment_collectionsCountAggregateInputType | true;
  };

  export interface payment_collectionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["payment_collections"];
      meta: { name: "payment_collections" };
    };
    /**
     * Find zero or one Payment_collections that matches the filter.
     * @param {payment_collectionsFindUniqueArgs} args - Arguments to find a Payment_collections
     * @example
     * // Get one Payment_collections
     * const payment_collections = await prisma.payment_collections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_collectionsFindUniqueArgs>(
      args: SelectSubset<T, payment_collectionsFindUniqueArgs<ExtArgs>>,
    ): Prisma__payment_collectionsClient<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Payment_collections that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_collectionsFindUniqueOrThrowArgs} args - Arguments to find a Payment_collections
     * @example
     * // Get one Payment_collections
     * const payment_collections = await prisma.payment_collections.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_collectionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, payment_collectionsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__payment_collectionsClient<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment_collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_collectionsFindFirstArgs} args - Arguments to find a Payment_collections
     * @example
     * // Get one Payment_collections
     * const payment_collections = await prisma.payment_collections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_collectionsFindFirstArgs>(
      args?: SelectSubset<T, payment_collectionsFindFirstArgs<ExtArgs>>,
    ): Prisma__payment_collectionsClient<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment_collections that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_collectionsFindFirstOrThrowArgs} args - Arguments to find a Payment_collections
     * @example
     * // Get one Payment_collections
     * const payment_collections = await prisma.payment_collections.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_collectionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, payment_collectionsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__payment_collectionsClient<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Payment_collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_collectionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_collections
     * const payment_collections = await prisma.payment_collections.findMany()
     *
     * // Get first 10 Payment_collections
     * const payment_collections = await prisma.payment_collections.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const payment_collectionsWithIdOnly = await prisma.payment_collections.findMany({ select: { id: true } })
     *
     */
    findMany<T extends payment_collectionsFindManyArgs>(
      args?: SelectSubset<T, payment_collectionsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Payment_collections.
     * @param {payment_collectionsCreateArgs} args - Arguments to create a Payment_collections.
     * @example
     * // Create one Payment_collections
     * const Payment_collections = await prisma.payment_collections.create({
     *   data: {
     *     // ... data to create a Payment_collections
     *   }
     * })
     *
     */
    create<T extends payment_collectionsCreateArgs>(
      args: SelectSubset<T, payment_collectionsCreateArgs<ExtArgs>>,
    ): Prisma__payment_collectionsClient<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Payment_collections.
     * @param {payment_collectionsCreateManyArgs} args - Arguments to create many Payment_collections.
     * @example
     * // Create many Payment_collections
     * const payment_collections = await prisma.payment_collections.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends payment_collectionsCreateManyArgs>(
      args?: SelectSubset<T, payment_collectionsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Payment_collections and returns the data saved in the database.
     * @param {payment_collectionsCreateManyAndReturnArgs} args - Arguments to create many Payment_collections.
     * @example
     * // Create many Payment_collections
     * const payment_collections = await prisma.payment_collections.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Payment_collections and only return the `id`
     * const payment_collectionsWithIdOnly = await prisma.payment_collections.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends payment_collectionsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, payment_collectionsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Payment_collections.
     * @param {payment_collectionsDeleteArgs} args - Arguments to delete one Payment_collections.
     * @example
     * // Delete one Payment_collections
     * const Payment_collections = await prisma.payment_collections.delete({
     *   where: {
     *     // ... filter to delete one Payment_collections
     *   }
     * })
     *
     */
    delete<T extends payment_collectionsDeleteArgs>(
      args: SelectSubset<T, payment_collectionsDeleteArgs<ExtArgs>>,
    ): Prisma__payment_collectionsClient<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Payment_collections.
     * @param {payment_collectionsUpdateArgs} args - Arguments to update one Payment_collections.
     * @example
     * // Update one Payment_collections
     * const payment_collections = await prisma.payment_collections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends payment_collectionsUpdateArgs>(
      args: SelectSubset<T, payment_collectionsUpdateArgs<ExtArgs>>,
    ): Prisma__payment_collectionsClient<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Payment_collections.
     * @param {payment_collectionsDeleteManyArgs} args - Arguments to filter Payment_collections to delete.
     * @example
     * // Delete a few Payment_collections
     * const { count } = await prisma.payment_collections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends payment_collectionsDeleteManyArgs>(
      args?: SelectSubset<T, payment_collectionsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payment_collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_collectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_collections
     * const payment_collections = await prisma.payment_collections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends payment_collectionsUpdateManyArgs>(
      args: SelectSubset<T, payment_collectionsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payment_collections and returns the data updated in the database.
     * @param {payment_collectionsUpdateManyAndReturnArgs} args - Arguments to update many Payment_collections.
     * @example
     * // Update many Payment_collections
     * const payment_collections = await prisma.payment_collections.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Payment_collections and only return the `id`
     * const payment_collectionsWithIdOnly = await prisma.payment_collections.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends payment_collectionsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, payment_collectionsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Payment_collections.
     * @param {payment_collectionsUpsertArgs} args - Arguments to update or create a Payment_collections.
     * @example
     * // Update or create a Payment_collections
     * const payment_collections = await prisma.payment_collections.upsert({
     *   create: {
     *     // ... data to create a Payment_collections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_collections we want to update
     *   }
     * })
     */
    upsert<T extends payment_collectionsUpsertArgs>(
      args: SelectSubset<T, payment_collectionsUpsertArgs<ExtArgs>>,
    ): Prisma__payment_collectionsClient<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Payment_collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_collectionsCountArgs} args - Arguments to filter Payment_collections to count.
     * @example
     * // Count the number of Payment_collections
     * const count = await prisma.payment_collections.count({
     *   where: {
     *     // ... the filter for the Payment_collections we want to count
     *   }
     * })
     **/
    count<T extends payment_collectionsCountArgs>(
      args?: Subset<T, payment_collectionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], Payment_collectionsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Payment_collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_collectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Payment_collectionsAggregateArgs>(
      args: Subset<T, Payment_collectionsAggregateArgs>,
    ): Prisma.PrismaPromise<GetPayment_collectionsAggregateType<T>>;

    /**
     * Group by Payment_collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_collectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends payment_collectionsGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_collectionsGroupByArgs["orderBy"] }
        : { orderBy?: payment_collectionsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, payment_collectionsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetPayment_collectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the payment_collections model
     */
    readonly fields: payment_collectionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_collections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_collectionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    firm<T extends payment_collections$firmArgs<ExtArgs> = {}>(
      args?: Subset<T, payment_collections$firmArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    payment_mode<T extends payment_collections$payment_modeArgs<ExtArgs> = {}>(
      args?: Subset<T, payment_collections$payment_modeArgs<ExtArgs>>,
    ): Prisma__payment_modesClient<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    rental<T extends payment_collections$rentalArgs<ExtArgs> = {}>(
      args?: Subset<T, payment_collections$rentalArgs<ExtArgs>>,
    ): Prisma__rentalsClient<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the payment_collections model
   */
  interface payment_collectionsFieldRefs {
    readonly id: FieldRef<"payment_collections", "String">;
    readonly rental_id: FieldRef<"payment_collections", "String">;
    readonly firm_id: FieldRef<"payment_collections", "String">;
    readonly payment_mode_id: FieldRef<"payment_collections", "String">;
    readonly amount: FieldRef<"payment_collections", "Float">;
    readonly description: FieldRef<"payment_collections", "String">;
    readonly active_flag: FieldRef<"payment_collections", "Boolean">;
    readonly delete_flag: FieldRef<"payment_collections", "Boolean">;
    readonly modified_at: FieldRef<"payment_collections", "DateTime">;
    readonly created_at: FieldRef<"payment_collections", "DateTime">;
    readonly created_by: FieldRef<"payment_collections", "String">;
    readonly modified_by: FieldRef<"payment_collections", "String">;
  }

  // Custom InputTypes
  /**
   * payment_collections findUnique
   */
  export type payment_collectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
    /**
     * Filter, which payment_collections to fetch.
     */
    where: payment_collectionsWhereUniqueInput;
  };

  /**
   * payment_collections findUniqueOrThrow
   */
  export type payment_collectionsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
    /**
     * Filter, which payment_collections to fetch.
     */
    where: payment_collectionsWhereUniqueInput;
  };

  /**
   * payment_collections findFirst
   */
  export type payment_collectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
    /**
     * Filter, which payment_collections to fetch.
     */
    where?: payment_collectionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of payment_collections to fetch.
     */
    orderBy?: payment_collectionsOrderByWithRelationInput | payment_collectionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for payment_collections.
     */
    cursor?: payment_collectionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` payment_collections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` payment_collections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of payment_collections.
     */
    distinct?: Payment_collectionsScalarFieldEnum | Payment_collectionsScalarFieldEnum[];
  };

  /**
   * payment_collections findFirstOrThrow
   */
  export type payment_collectionsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
    /**
     * Filter, which payment_collections to fetch.
     */
    where?: payment_collectionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of payment_collections to fetch.
     */
    orderBy?: payment_collectionsOrderByWithRelationInput | payment_collectionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for payment_collections.
     */
    cursor?: payment_collectionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` payment_collections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` payment_collections.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of payment_collections.
     */
    distinct?: Payment_collectionsScalarFieldEnum | Payment_collectionsScalarFieldEnum[];
  };

  /**
   * payment_collections findMany
   */
  export type payment_collectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
    /**
     * Filter, which payment_collections to fetch.
     */
    where?: payment_collectionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of payment_collections to fetch.
     */
    orderBy?: payment_collectionsOrderByWithRelationInput | payment_collectionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing payment_collections.
     */
    cursor?: payment_collectionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` payment_collections from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` payment_collections.
     */
    skip?: number;
    distinct?: Payment_collectionsScalarFieldEnum | Payment_collectionsScalarFieldEnum[];
  };

  /**
   * payment_collections create
   */
  export type payment_collectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
    /**
     * The data needed to create a payment_collections.
     */
    data: XOR<payment_collectionsCreateInput, payment_collectionsUncheckedCreateInput>;
  };

  /**
   * payment_collections createMany
   */
  export type payment_collectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_collections.
     */
    data: payment_collectionsCreateManyInput | payment_collectionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * payment_collections createManyAndReturn
   */
  export type payment_collectionsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * The data used to create many payment_collections.
     */
    data: payment_collectionsCreateManyInput | payment_collectionsCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * payment_collections update
   */
  export type payment_collectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
    /**
     * The data needed to update a payment_collections.
     */
    data: XOR<payment_collectionsUpdateInput, payment_collectionsUncheckedUpdateInput>;
    /**
     * Choose, which payment_collections to update.
     */
    where: payment_collectionsWhereUniqueInput;
  };

  /**
   * payment_collections updateMany
   */
  export type payment_collectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_collections.
     */
    data: XOR<payment_collectionsUpdateManyMutationInput, payment_collectionsUncheckedUpdateManyInput>;
    /**
     * Filter which payment_collections to update
     */
    where?: payment_collectionsWhereInput;
    /**
     * Limit how many payment_collections to update.
     */
    limit?: number;
  };

  /**
   * payment_collections updateManyAndReturn
   */
  export type payment_collectionsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * The data used to update payment_collections.
     */
    data: XOR<payment_collectionsUpdateManyMutationInput, payment_collectionsUncheckedUpdateManyInput>;
    /**
     * Filter which payment_collections to update
     */
    where?: payment_collectionsWhereInput;
    /**
     * Limit how many payment_collections to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * payment_collections upsert
   */
  export type payment_collectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
    /**
     * The filter to search for the payment_collections to update in case it exists.
     */
    where: payment_collectionsWhereUniqueInput;
    /**
     * In case the payment_collections found by the `where` argument doesn't exist, create a new payment_collections with this data.
     */
    create: XOR<payment_collectionsCreateInput, payment_collectionsUncheckedCreateInput>;
    /**
     * In case the payment_collections was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_collectionsUpdateInput, payment_collectionsUncheckedUpdateInput>;
  };

  /**
   * payment_collections delete
   */
  export type payment_collectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
    /**
     * Filter which payment_collections to delete.
     */
    where: payment_collectionsWhereUniqueInput;
  };

  /**
   * payment_collections deleteMany
   */
  export type payment_collectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_collections to delete
     */
    where?: payment_collectionsWhereInput;
    /**
     * Limit how many payment_collections to delete.
     */
    limit?: number;
  };

  /**
   * payment_collections.firm
   */
  export type payment_collections$firmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
    where?: firmsWhereInput;
  };

  /**
   * payment_collections.payment_mode
   */
  export type payment_collections$payment_modeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the payment_modes
       */
      select?: payment_modesSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the payment_modes
       */
      omit?: payment_modesOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: payment_modesInclude<ExtArgs> | null;
      where?: payment_modesWhereInput;
    };

  /**
   * payment_collections.rental
   */
  export type payment_collections$rentalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
    where?: rentalsWhereInput;
  };

  /**
   * payment_collections without action
   */
  export type payment_collectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
  };

  /**
   * Model payment_modes
   */

  export type AggregatePayment_modes = {
    _count: Payment_modesCountAggregateOutputType | null;
    _min: Payment_modesMinAggregateOutputType | null;
    _max: Payment_modesMaxAggregateOutputType | null;
  };

  export type Payment_modesMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    firm_id: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type Payment_modesMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    firm_id: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type Payment_modesCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    firm_id: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type Payment_modesMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    firm_id?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type Payment_modesMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    firm_id?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type Payment_modesCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    firm_id?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type Payment_modesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_modes to aggregate.
     */
    where?: payment_modesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of payment_modes to fetch.
     */
    orderBy?: payment_modesOrderByWithRelationInput | payment_modesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: payment_modesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` payment_modes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` payment_modes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned payment_modes
     **/
    _count?: true | Payment_modesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Payment_modesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Payment_modesMaxAggregateInputType;
  };

  export type GetPayment_modesAggregateType<T extends Payment_modesAggregateArgs> = {
    [P in keyof T & keyof AggregatePayment_modes]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_modes[P]>
      : GetScalarType<T[P], AggregatePayment_modes[P]>;
  };

  export type payment_modesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_modesWhereInput;
    orderBy?: payment_modesOrderByWithAggregationInput | payment_modesOrderByWithAggregationInput[];
    by: Payment_modesScalarFieldEnum[] | Payment_modesScalarFieldEnum;
    having?: payment_modesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Payment_modesCountAggregateInputType | true;
    _min?: Payment_modesMinAggregateInputType;
    _max?: Payment_modesMaxAggregateInputType;
  };

  export type Payment_modesGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    firm_id: string | null;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: Payment_modesCountAggregateOutputType | null;
    _min: Payment_modesMinAggregateOutputType | null;
    _max: Payment_modesMaxAggregateOutputType | null;
  };

  type GetPayment_modesGroupByPayload<T extends payment_modesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_modesGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof Payment_modesGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], Payment_modesGroupByOutputType[P]>
          : GetScalarType<T[P], Payment_modesGroupByOutputType[P]>;
      }
    >
  >;

  export type payment_modesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        description?: boolean;
        firm_id?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
        firm?: boolean | payment_modes$firmArgs<ExtArgs>;
        payment_collections?: boolean | payment_modes$payment_collectionsArgs<ExtArgs>;
        rentals?: boolean | payment_modes$rentalsArgs<ExtArgs>;
        _count?: boolean | Payment_modesCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["payment_modes"]
    >;

  export type payment_modesSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      firm_id?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      modified_at?: boolean;
      created_at?: boolean;
      created_by?: boolean;
      modified_by?: boolean;
      firm?: boolean | payment_modes$firmArgs<ExtArgs>;
    },
    ExtArgs["result"]["payment_modes"]
  >;

  export type payment_modesSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      firm_id?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      modified_at?: boolean;
      created_at?: boolean;
      created_by?: boolean;
      modified_by?: boolean;
      firm?: boolean | payment_modes$firmArgs<ExtArgs>;
    },
    ExtArgs["result"]["payment_modes"]
  >;

  export type payment_modesSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    firm_id?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type payment_modesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "name"
      | "description"
      | "firm_id"
      | "active_flag"
      | "delete_flag"
      | "modified_at"
      | "created_at"
      | "created_by"
      | "modified_by",
      ExtArgs["result"]["payment_modes"]
    >;
  export type payment_modesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    firm?: boolean | payment_modes$firmArgs<ExtArgs>;
    payment_collections?: boolean | payment_modes$payment_collectionsArgs<ExtArgs>;
    rentals?: boolean | payment_modes$rentalsArgs<ExtArgs>;
    _count?: boolean | Payment_modesCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type payment_modesIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    firm?: boolean | payment_modes$firmArgs<ExtArgs>;
  };
  export type payment_modesIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    firm?: boolean | payment_modes$firmArgs<ExtArgs>;
  };

  export type $payment_modesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_modes";
    objects: {
      firm: Prisma.$firmsPayload<ExtArgs> | null;
      payment_collections: Prisma.$payment_collectionsPayload<ExtArgs>[];
      rentals: Prisma.$rentalsPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        firm_id: string | null;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["payment_modes"]
    >;
    composites: {};
  };

  type payment_modesGetPayload<S extends boolean | null | undefined | payment_modesDefaultArgs> = $Result.GetResult<
    Prisma.$payment_modesPayload,
    S
  >;

  type payment_modesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    payment_modesFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: Payment_modesCountAggregateInputType | true;
  };

  export interface payment_modesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["payment_modes"]; meta: { name: "payment_modes" } };
    /**
     * Find zero or one Payment_modes that matches the filter.
     * @param {payment_modesFindUniqueArgs} args - Arguments to find a Payment_modes
     * @example
     * // Get one Payment_modes
     * const payment_modes = await prisma.payment_modes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payment_modesFindUniqueArgs>(
      args: SelectSubset<T, payment_modesFindUniqueArgs<ExtArgs>>,
    ): Prisma__payment_modesClient<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Payment_modes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payment_modesFindUniqueOrThrowArgs} args - Arguments to find a Payment_modes
     * @example
     * // Get one Payment_modes
     * const payment_modes = await prisma.payment_modes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payment_modesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, payment_modesFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__payment_modesClient<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment_modes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_modesFindFirstArgs} args - Arguments to find a Payment_modes
     * @example
     * // Get one Payment_modes
     * const payment_modes = await prisma.payment_modes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payment_modesFindFirstArgs>(
      args?: SelectSubset<T, payment_modesFindFirstArgs<ExtArgs>>,
    ): Prisma__payment_modesClient<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment_modes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_modesFindFirstOrThrowArgs} args - Arguments to find a Payment_modes
     * @example
     * // Get one Payment_modes
     * const payment_modes = await prisma.payment_modes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payment_modesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, payment_modesFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__payment_modesClient<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Payment_modes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_modesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_modes
     * const payment_modes = await prisma.payment_modes.findMany()
     *
     * // Get first 10 Payment_modes
     * const payment_modes = await prisma.payment_modes.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const payment_modesWithIdOnly = await prisma.payment_modes.findMany({ select: { id: true } })
     *
     */
    findMany<T extends payment_modesFindManyArgs>(
      args?: SelectSubset<T, payment_modesFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Payment_modes.
     * @param {payment_modesCreateArgs} args - Arguments to create a Payment_modes.
     * @example
     * // Create one Payment_modes
     * const Payment_modes = await prisma.payment_modes.create({
     *   data: {
     *     // ... data to create a Payment_modes
     *   }
     * })
     *
     */
    create<T extends payment_modesCreateArgs>(
      args: SelectSubset<T, payment_modesCreateArgs<ExtArgs>>,
    ): Prisma__payment_modesClient<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Payment_modes.
     * @param {payment_modesCreateManyArgs} args - Arguments to create many Payment_modes.
     * @example
     * // Create many Payment_modes
     * const payment_modes = await prisma.payment_modes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends payment_modesCreateManyArgs>(
      args?: SelectSubset<T, payment_modesCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Payment_modes and returns the data saved in the database.
     * @param {payment_modesCreateManyAndReturnArgs} args - Arguments to create many Payment_modes.
     * @example
     * // Create many Payment_modes
     * const payment_modes = await prisma.payment_modes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Payment_modes and only return the `id`
     * const payment_modesWithIdOnly = await prisma.payment_modes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends payment_modesCreateManyAndReturnArgs>(
      args?: SelectSubset<T, payment_modesCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Payment_modes.
     * @param {payment_modesDeleteArgs} args - Arguments to delete one Payment_modes.
     * @example
     * // Delete one Payment_modes
     * const Payment_modes = await prisma.payment_modes.delete({
     *   where: {
     *     // ... filter to delete one Payment_modes
     *   }
     * })
     *
     */
    delete<T extends payment_modesDeleteArgs>(
      args: SelectSubset<T, payment_modesDeleteArgs<ExtArgs>>,
    ): Prisma__payment_modesClient<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Payment_modes.
     * @param {payment_modesUpdateArgs} args - Arguments to update one Payment_modes.
     * @example
     * // Update one Payment_modes
     * const payment_modes = await prisma.payment_modes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends payment_modesUpdateArgs>(
      args: SelectSubset<T, payment_modesUpdateArgs<ExtArgs>>,
    ): Prisma__payment_modesClient<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Payment_modes.
     * @param {payment_modesDeleteManyArgs} args - Arguments to filter Payment_modes to delete.
     * @example
     * // Delete a few Payment_modes
     * const { count } = await prisma.payment_modes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends payment_modesDeleteManyArgs>(
      args?: SelectSubset<T, payment_modesDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payment_modes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_modesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_modes
     * const payment_modes = await prisma.payment_modes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends payment_modesUpdateManyArgs>(
      args: SelectSubset<T, payment_modesUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payment_modes and returns the data updated in the database.
     * @param {payment_modesUpdateManyAndReturnArgs} args - Arguments to update many Payment_modes.
     * @example
     * // Update many Payment_modes
     * const payment_modes = await prisma.payment_modes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Payment_modes and only return the `id`
     * const payment_modesWithIdOnly = await prisma.payment_modes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends payment_modesUpdateManyAndReturnArgs>(
      args: SelectSubset<T, payment_modesUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Payment_modes.
     * @param {payment_modesUpsertArgs} args - Arguments to update or create a Payment_modes.
     * @example
     * // Update or create a Payment_modes
     * const payment_modes = await prisma.payment_modes.upsert({
     *   create: {
     *     // ... data to create a Payment_modes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_modes we want to update
     *   }
     * })
     */
    upsert<T extends payment_modesUpsertArgs>(
      args: SelectSubset<T, payment_modesUpsertArgs<ExtArgs>>,
    ): Prisma__payment_modesClient<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Payment_modes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_modesCountArgs} args - Arguments to filter Payment_modes to count.
     * @example
     * // Count the number of Payment_modes
     * const count = await prisma.payment_modes.count({
     *   where: {
     *     // ... the filter for the Payment_modes we want to count
     *   }
     * })
     **/
    count<T extends payment_modesCountArgs>(
      args?: Subset<T, payment_modesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], Payment_modesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Payment_modes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_modesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Payment_modesAggregateArgs>(
      args: Subset<T, Payment_modesAggregateArgs>,
    ): Prisma.PrismaPromise<GetPayment_modesAggregateType<T>>;

    /**
     * Group by Payment_modes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_modesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends payment_modesGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_modesGroupByArgs["orderBy"] }
        : { orderBy?: payment_modesGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, payment_modesGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetPayment_modesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the payment_modes model
     */
    readonly fields: payment_modesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_modes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_modesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    firm<T extends payment_modes$firmArgs<ExtArgs> = {}>(
      args?: Subset<T, payment_modes$firmArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    payment_collections<T extends payment_modes$payment_collectionsArgs<ExtArgs> = {}>(
      args?: Subset<T, payment_modes$payment_collectionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    rentals<T extends payment_modes$rentalsArgs<ExtArgs> = {}>(
      args?: Subset<T, payment_modes$rentalsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the payment_modes model
   */
  interface payment_modesFieldRefs {
    readonly id: FieldRef<"payment_modes", "String">;
    readonly name: FieldRef<"payment_modes", "String">;
    readonly description: FieldRef<"payment_modes", "String">;
    readonly firm_id: FieldRef<"payment_modes", "String">;
    readonly active_flag: FieldRef<"payment_modes", "Boolean">;
    readonly delete_flag: FieldRef<"payment_modes", "Boolean">;
    readonly modified_at: FieldRef<"payment_modes", "DateTime">;
    readonly created_at: FieldRef<"payment_modes", "DateTime">;
    readonly created_by: FieldRef<"payment_modes", "String">;
    readonly modified_by: FieldRef<"payment_modes", "String">;
  }

  // Custom InputTypes
  /**
   * payment_modes findUnique
   */
  export type payment_modesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_modes
     */
    select?: payment_modesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_modes
     */
    omit?: payment_modesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_modesInclude<ExtArgs> | null;
    /**
     * Filter, which payment_modes to fetch.
     */
    where: payment_modesWhereUniqueInput;
  };

  /**
   * payment_modes findUniqueOrThrow
   */
  export type payment_modesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_modes
     */
    select?: payment_modesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_modes
     */
    omit?: payment_modesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_modesInclude<ExtArgs> | null;
    /**
     * Filter, which payment_modes to fetch.
     */
    where: payment_modesWhereUniqueInput;
  };

  /**
   * payment_modes findFirst
   */
  export type payment_modesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_modes
     */
    select?: payment_modesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_modes
     */
    omit?: payment_modesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_modesInclude<ExtArgs> | null;
    /**
     * Filter, which payment_modes to fetch.
     */
    where?: payment_modesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of payment_modes to fetch.
     */
    orderBy?: payment_modesOrderByWithRelationInput | payment_modesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for payment_modes.
     */
    cursor?: payment_modesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` payment_modes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` payment_modes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of payment_modes.
     */
    distinct?: Payment_modesScalarFieldEnum | Payment_modesScalarFieldEnum[];
  };

  /**
   * payment_modes findFirstOrThrow
   */
  export type payment_modesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_modes
     */
    select?: payment_modesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_modes
     */
    omit?: payment_modesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_modesInclude<ExtArgs> | null;
    /**
     * Filter, which payment_modes to fetch.
     */
    where?: payment_modesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of payment_modes to fetch.
     */
    orderBy?: payment_modesOrderByWithRelationInput | payment_modesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for payment_modes.
     */
    cursor?: payment_modesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` payment_modes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` payment_modes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of payment_modes.
     */
    distinct?: Payment_modesScalarFieldEnum | Payment_modesScalarFieldEnum[];
  };

  /**
   * payment_modes findMany
   */
  export type payment_modesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_modes
     */
    select?: payment_modesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_modes
     */
    omit?: payment_modesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_modesInclude<ExtArgs> | null;
    /**
     * Filter, which payment_modes to fetch.
     */
    where?: payment_modesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of payment_modes to fetch.
     */
    orderBy?: payment_modesOrderByWithRelationInput | payment_modesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing payment_modes.
     */
    cursor?: payment_modesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` payment_modes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` payment_modes.
     */
    skip?: number;
    distinct?: Payment_modesScalarFieldEnum | Payment_modesScalarFieldEnum[];
  };

  /**
   * payment_modes create
   */
  export type payment_modesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_modes
     */
    select?: payment_modesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_modes
     */
    omit?: payment_modesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_modesInclude<ExtArgs> | null;
    /**
     * The data needed to create a payment_modes.
     */
    data: XOR<payment_modesCreateInput, payment_modesUncheckedCreateInput>;
  };

  /**
   * payment_modes createMany
   */
  export type payment_modesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_modes.
     */
    data: payment_modesCreateManyInput | payment_modesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * payment_modes createManyAndReturn
   */
  export type payment_modesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the payment_modes
       */
      select?: payment_modesSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the payment_modes
       */
      omit?: payment_modesOmit<ExtArgs> | null;
      /**
       * The data used to create many payment_modes.
       */
      data: payment_modesCreateManyInput | payment_modesCreateManyInput[];
      skipDuplicates?: boolean;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: payment_modesIncludeCreateManyAndReturn<ExtArgs> | null;
    };

  /**
   * payment_modes update
   */
  export type payment_modesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_modes
     */
    select?: payment_modesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_modes
     */
    omit?: payment_modesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_modesInclude<ExtArgs> | null;
    /**
     * The data needed to update a payment_modes.
     */
    data: XOR<payment_modesUpdateInput, payment_modesUncheckedUpdateInput>;
    /**
     * Choose, which payment_modes to update.
     */
    where: payment_modesWhereUniqueInput;
  };

  /**
   * payment_modes updateMany
   */
  export type payment_modesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_modes.
     */
    data: XOR<payment_modesUpdateManyMutationInput, payment_modesUncheckedUpdateManyInput>;
    /**
     * Filter which payment_modes to update
     */
    where?: payment_modesWhereInput;
    /**
     * Limit how many payment_modes to update.
     */
    limit?: number;
  };

  /**
   * payment_modes updateManyAndReturn
   */
  export type payment_modesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the payment_modes
       */
      select?: payment_modesSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the payment_modes
       */
      omit?: payment_modesOmit<ExtArgs> | null;
      /**
       * The data used to update payment_modes.
       */
      data: XOR<payment_modesUpdateManyMutationInput, payment_modesUncheckedUpdateManyInput>;
      /**
       * Filter which payment_modes to update
       */
      where?: payment_modesWhereInput;
      /**
       * Limit how many payment_modes to update.
       */
      limit?: number;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: payment_modesIncludeUpdateManyAndReturn<ExtArgs> | null;
    };

  /**
   * payment_modes upsert
   */
  export type payment_modesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_modes
     */
    select?: payment_modesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_modes
     */
    omit?: payment_modesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_modesInclude<ExtArgs> | null;
    /**
     * The filter to search for the payment_modes to update in case it exists.
     */
    where: payment_modesWhereUniqueInput;
    /**
     * In case the payment_modes found by the `where` argument doesn't exist, create a new payment_modes with this data.
     */
    create: XOR<payment_modesCreateInput, payment_modesUncheckedCreateInput>;
    /**
     * In case the payment_modes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_modesUpdateInput, payment_modesUncheckedUpdateInput>;
  };

  /**
   * payment_modes delete
   */
  export type payment_modesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_modes
     */
    select?: payment_modesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_modes
     */
    omit?: payment_modesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_modesInclude<ExtArgs> | null;
    /**
     * Filter which payment_modes to delete.
     */
    where: payment_modesWhereUniqueInput;
  };

  /**
   * payment_modes deleteMany
   */
  export type payment_modesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_modes to delete
     */
    where?: payment_modesWhereInput;
    /**
     * Limit how many payment_modes to delete.
     */
    limit?: number;
  };

  /**
   * payment_modes.firm
   */
  export type payment_modes$firmArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the firms
     */
    select?: firmsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the firms
     */
    omit?: firmsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: firmsInclude<ExtArgs> | null;
    where?: firmsWhereInput;
  };

  /**
   * payment_modes.payment_collections
   */
  export type payment_modes$payment_collectionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
    where?: payment_collectionsWhereInput;
    orderBy?: payment_collectionsOrderByWithRelationInput | payment_collectionsOrderByWithRelationInput[];
    cursor?: payment_collectionsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: Payment_collectionsScalarFieldEnum | Payment_collectionsScalarFieldEnum[];
  };

  /**
   * payment_modes.rentals
   */
  export type payment_modes$rentalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
    where?: rentalsWhereInput;
    orderBy?: rentalsOrderByWithRelationInput | rentalsOrderByWithRelationInput[];
    cursor?: rentalsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RentalsScalarFieldEnum | RentalsScalarFieldEnum[];
  };

  /**
   * payment_modes without action
   */
  export type payment_modesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_modes
     */
    select?: payment_modesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_modes
     */
    omit?: payment_modesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_modesInclude<ExtArgs> | null;
  };

  /**
   * Model prefixes
   */

  export type AggregatePrefixes = {
    _count: PrefixesCountAggregateOutputType | null;
    _avg: PrefixesAvgAggregateOutputType | null;
    _sum: PrefixesSumAggregateOutputType | null;
    _min: PrefixesMinAggregateOutputType | null;
    _max: PrefixesMaxAggregateOutputType | null;
  };

  export type PrefixesAvgAggregateOutputType = {
    start: number | null;
    end: number | null;
    current: number | null;
  };

  export type PrefixesSumAggregateOutputType = {
    start: number | null;
    end: number | null;
    current: number | null;
  };

  export type PrefixesMinAggregateOutputType = {
    id: string | null;
    object_type: string | null;
    name: string | null;
    start: number | null;
    end: number | null;
    current: number | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type PrefixesMaxAggregateOutputType = {
    id: string | null;
    object_type: string | null;
    name: string | null;
    start: number | null;
    end: number | null;
    current: number | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type PrefixesCountAggregateOutputType = {
    id: number;
    object_type: number;
    name: number;
    start: number;
    end: number;
    current: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type PrefixesAvgAggregateInputType = {
    start?: true;
    end?: true;
    current?: true;
  };

  export type PrefixesSumAggregateInputType = {
    start?: true;
    end?: true;
    current?: true;
  };

  export type PrefixesMinAggregateInputType = {
    id?: true;
    object_type?: true;
    name?: true;
    start?: true;
    end?: true;
    current?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type PrefixesMaxAggregateInputType = {
    id?: true;
    object_type?: true;
    name?: true;
    start?: true;
    end?: true;
    current?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type PrefixesCountAggregateInputType = {
    id?: true;
    object_type?: true;
    name?: true;
    start?: true;
    end?: true;
    current?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type PrefixesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prefixes to aggregate.
     */
    where?: prefixesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of prefixes to fetch.
     */
    orderBy?: prefixesOrderByWithRelationInput | prefixesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: prefixesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` prefixes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` prefixes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned prefixes
     **/
    _count?: true | PrefixesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PrefixesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PrefixesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PrefixesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PrefixesMaxAggregateInputType;
  };

  export type GetPrefixesAggregateType<T extends PrefixesAggregateArgs> = {
    [P in keyof T & keyof AggregatePrefixes]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrefixes[P]>
      : GetScalarType<T[P], AggregatePrefixes[P]>;
  };

  export type prefixesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prefixesWhereInput;
    orderBy?: prefixesOrderByWithAggregationInput | prefixesOrderByWithAggregationInput[];
    by: PrefixesScalarFieldEnum[] | PrefixesScalarFieldEnum;
    having?: prefixesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PrefixesCountAggregateInputType | true;
    _avg?: PrefixesAvgAggregateInputType;
    _sum?: PrefixesSumAggregateInputType;
    _min?: PrefixesMinAggregateInputType;
    _max?: PrefixesMaxAggregateInputType;
  };

  export type PrefixesGroupByOutputType = {
    id: string;
    object_type: string;
    name: string;
    start: number;
    end: number;
    current: number;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: PrefixesCountAggregateOutputType | null;
    _avg: PrefixesAvgAggregateOutputType | null;
    _sum: PrefixesSumAggregateOutputType | null;
    _min: PrefixesMinAggregateOutputType | null;
    _max: PrefixesMaxAggregateOutputType | null;
  };

  type GetPrefixesGroupByPayload<T extends prefixesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrefixesGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof PrefixesGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PrefixesGroupByOutputType[P]>
          : GetScalarType<T[P], PrefixesGroupByOutputType[P]>;
      }
    >
  >;

  export type prefixesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        object_type?: boolean;
        name?: boolean;
        start?: boolean;
        end?: boolean;
        current?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["prefixes"]
    >;

  export type prefixesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        object_type?: boolean;
        name?: boolean;
        start?: boolean;
        end?: boolean;
        current?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["prefixes"]
    >;

  export type prefixesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        object_type?: boolean;
        name?: boolean;
        start?: boolean;
        end?: boolean;
        current?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["prefixes"]
    >;

  export type prefixesSelectScalar = {
    id?: boolean;
    object_type?: boolean;
    name?: boolean;
    start?: boolean;
    end?: boolean;
    current?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type prefixesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "object_type"
    | "name"
    | "start"
    | "end"
    | "current"
    | "active_flag"
    | "delete_flag"
    | "modified_at"
    | "created_at"
    | "created_by"
    | "modified_by",
    ExtArgs["result"]["prefixes"]
  >;

  export type $prefixesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prefixes";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        object_type: string;
        name: string;
        start: number;
        end: number;
        current: number;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["prefixes"]
    >;
    composites: {};
  };

  type prefixesGetPayload<S extends boolean | null | undefined | prefixesDefaultArgs> = $Result.GetResult<
    Prisma.$prefixesPayload,
    S
  >;

  type prefixesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    prefixesFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: PrefixesCountAggregateInputType | true;
  };

  export interface prefixesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["prefixes"]; meta: { name: "prefixes" } };
    /**
     * Find zero or one Prefixes that matches the filter.
     * @param {prefixesFindUniqueArgs} args - Arguments to find a Prefixes
     * @example
     * // Get one Prefixes
     * const prefixes = await prisma.prefixes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prefixesFindUniqueArgs>(
      args: SelectSubset<T, prefixesFindUniqueArgs<ExtArgs>>,
    ): Prisma__prefixesClient<
      $Result.GetResult<Prisma.$prefixesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Prefixes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {prefixesFindUniqueOrThrowArgs} args - Arguments to find a Prefixes
     * @example
     * // Get one Prefixes
     * const prefixes = await prisma.prefixes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prefixesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, prefixesFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__prefixesClient<
      $Result.GetResult<Prisma.$prefixesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Prefixes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prefixesFindFirstArgs} args - Arguments to find a Prefixes
     * @example
     * // Get one Prefixes
     * const prefixes = await prisma.prefixes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prefixesFindFirstArgs>(
      args?: SelectSubset<T, prefixesFindFirstArgs<ExtArgs>>,
    ): Prisma__prefixesClient<
      $Result.GetResult<Prisma.$prefixesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Prefixes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prefixesFindFirstOrThrowArgs} args - Arguments to find a Prefixes
     * @example
     * // Get one Prefixes
     * const prefixes = await prisma.prefixes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prefixesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, prefixesFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__prefixesClient<
      $Result.GetResult<Prisma.$prefixesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Prefixes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prefixesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prefixes
     * const prefixes = await prisma.prefixes.findMany()
     *
     * // Get first 10 Prefixes
     * const prefixes = await prisma.prefixes.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const prefixesWithIdOnly = await prisma.prefixes.findMany({ select: { id: true } })
     *
     */
    findMany<T extends prefixesFindManyArgs>(
      args?: SelectSubset<T, prefixesFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prefixesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Prefixes.
     * @param {prefixesCreateArgs} args - Arguments to create a Prefixes.
     * @example
     * // Create one Prefixes
     * const Prefixes = await prisma.prefixes.create({
     *   data: {
     *     // ... data to create a Prefixes
     *   }
     * })
     *
     */
    create<T extends prefixesCreateArgs>(
      args: SelectSubset<T, prefixesCreateArgs<ExtArgs>>,
    ): Prisma__prefixesClient<
      $Result.GetResult<Prisma.$prefixesPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Prefixes.
     * @param {prefixesCreateManyArgs} args - Arguments to create many Prefixes.
     * @example
     * // Create many Prefixes
     * const prefixes = await prisma.prefixes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends prefixesCreateManyArgs>(
      args?: SelectSubset<T, prefixesCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Prefixes and returns the data saved in the database.
     * @param {prefixesCreateManyAndReturnArgs} args - Arguments to create many Prefixes.
     * @example
     * // Create many Prefixes
     * const prefixes = await prisma.prefixes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Prefixes and only return the `id`
     * const prefixesWithIdOnly = await prisma.prefixes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends prefixesCreateManyAndReturnArgs>(
      args?: SelectSubset<T, prefixesCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$prefixesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Prefixes.
     * @param {prefixesDeleteArgs} args - Arguments to delete one Prefixes.
     * @example
     * // Delete one Prefixes
     * const Prefixes = await prisma.prefixes.delete({
     *   where: {
     *     // ... filter to delete one Prefixes
     *   }
     * })
     *
     */
    delete<T extends prefixesDeleteArgs>(
      args: SelectSubset<T, prefixesDeleteArgs<ExtArgs>>,
    ): Prisma__prefixesClient<
      $Result.GetResult<Prisma.$prefixesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Prefixes.
     * @param {prefixesUpdateArgs} args - Arguments to update one Prefixes.
     * @example
     * // Update one Prefixes
     * const prefixes = await prisma.prefixes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends prefixesUpdateArgs>(
      args: SelectSubset<T, prefixesUpdateArgs<ExtArgs>>,
    ): Prisma__prefixesClient<
      $Result.GetResult<Prisma.$prefixesPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Prefixes.
     * @param {prefixesDeleteManyArgs} args - Arguments to filter Prefixes to delete.
     * @example
     * // Delete a few Prefixes
     * const { count } = await prisma.prefixes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends prefixesDeleteManyArgs>(
      args?: SelectSubset<T, prefixesDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Prefixes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prefixesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prefixes
     * const prefixes = await prisma.prefixes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends prefixesUpdateManyArgs>(
      args: SelectSubset<T, prefixesUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Prefixes and returns the data updated in the database.
     * @param {prefixesUpdateManyAndReturnArgs} args - Arguments to update many Prefixes.
     * @example
     * // Update many Prefixes
     * const prefixes = await prisma.prefixes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Prefixes and only return the `id`
     * const prefixesWithIdOnly = await prisma.prefixes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends prefixesUpdateManyAndReturnArgs>(
      args: SelectSubset<T, prefixesUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$prefixesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Prefixes.
     * @param {prefixesUpsertArgs} args - Arguments to update or create a Prefixes.
     * @example
     * // Update or create a Prefixes
     * const prefixes = await prisma.prefixes.upsert({
     *   create: {
     *     // ... data to create a Prefixes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prefixes we want to update
     *   }
     * })
     */
    upsert<T extends prefixesUpsertArgs>(
      args: SelectSubset<T, prefixesUpsertArgs<ExtArgs>>,
    ): Prisma__prefixesClient<
      $Result.GetResult<Prisma.$prefixesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Prefixes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prefixesCountArgs} args - Arguments to filter Prefixes to count.
     * @example
     * // Count the number of Prefixes
     * const count = await prisma.prefixes.count({
     *   where: {
     *     // ... the filter for the Prefixes we want to count
     *   }
     * })
     **/
    count<T extends prefixesCountArgs>(
      args?: Subset<T, prefixesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], PrefixesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Prefixes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrefixesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PrefixesAggregateArgs>(
      args: Subset<T, PrefixesAggregateArgs>,
    ): Prisma.PrismaPromise<GetPrefixesAggregateType<T>>;

    /**
     * Group by Prefixes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prefixesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends prefixesGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prefixesGroupByArgs["orderBy"] }
        : { orderBy?: prefixesGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, prefixesGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetPrefixesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the prefixes model
     */
    readonly fields: prefixesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prefixes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prefixesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the prefixes model
   */
  interface prefixesFieldRefs {
    readonly id: FieldRef<"prefixes", "String">;
    readonly object_type: FieldRef<"prefixes", "String">;
    readonly name: FieldRef<"prefixes", "String">;
    readonly start: FieldRef<"prefixes", "Int">;
    readonly end: FieldRef<"prefixes", "Int">;
    readonly current: FieldRef<"prefixes", "Int">;
    readonly active_flag: FieldRef<"prefixes", "Boolean">;
    readonly delete_flag: FieldRef<"prefixes", "Boolean">;
    readonly modified_at: FieldRef<"prefixes", "DateTime">;
    readonly created_at: FieldRef<"prefixes", "DateTime">;
    readonly created_by: FieldRef<"prefixes", "String">;
    readonly modified_by: FieldRef<"prefixes", "String">;
  }

  // Custom InputTypes
  /**
   * prefixes findUnique
   */
  export type prefixesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixes
     */
    select?: prefixesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the prefixes
     */
    omit?: prefixesOmit<ExtArgs> | null;
    /**
     * Filter, which prefixes to fetch.
     */
    where: prefixesWhereUniqueInput;
  };

  /**
   * prefixes findUniqueOrThrow
   */
  export type prefixesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixes
     */
    select?: prefixesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the prefixes
     */
    omit?: prefixesOmit<ExtArgs> | null;
    /**
     * Filter, which prefixes to fetch.
     */
    where: prefixesWhereUniqueInput;
  };

  /**
   * prefixes findFirst
   */
  export type prefixesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixes
     */
    select?: prefixesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the prefixes
     */
    omit?: prefixesOmit<ExtArgs> | null;
    /**
     * Filter, which prefixes to fetch.
     */
    where?: prefixesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of prefixes to fetch.
     */
    orderBy?: prefixesOrderByWithRelationInput | prefixesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for prefixes.
     */
    cursor?: prefixesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` prefixes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` prefixes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of prefixes.
     */
    distinct?: PrefixesScalarFieldEnum | PrefixesScalarFieldEnum[];
  };

  /**
   * prefixes findFirstOrThrow
   */
  export type prefixesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixes
     */
    select?: prefixesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the prefixes
     */
    omit?: prefixesOmit<ExtArgs> | null;
    /**
     * Filter, which prefixes to fetch.
     */
    where?: prefixesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of prefixes to fetch.
     */
    orderBy?: prefixesOrderByWithRelationInput | prefixesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for prefixes.
     */
    cursor?: prefixesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` prefixes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` prefixes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of prefixes.
     */
    distinct?: PrefixesScalarFieldEnum | PrefixesScalarFieldEnum[];
  };

  /**
   * prefixes findMany
   */
  export type prefixesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixes
     */
    select?: prefixesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the prefixes
     */
    omit?: prefixesOmit<ExtArgs> | null;
    /**
     * Filter, which prefixes to fetch.
     */
    where?: prefixesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of prefixes to fetch.
     */
    orderBy?: prefixesOrderByWithRelationInput | prefixesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing prefixes.
     */
    cursor?: prefixesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` prefixes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` prefixes.
     */
    skip?: number;
    distinct?: PrefixesScalarFieldEnum | PrefixesScalarFieldEnum[];
  };

  /**
   * prefixes create
   */
  export type prefixesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixes
     */
    select?: prefixesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the prefixes
     */
    omit?: prefixesOmit<ExtArgs> | null;
    /**
     * The data needed to create a prefixes.
     */
    data: XOR<prefixesCreateInput, prefixesUncheckedCreateInput>;
  };

  /**
   * prefixes createMany
   */
  export type prefixesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prefixes.
     */
    data: prefixesCreateManyInput | prefixesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * prefixes createManyAndReturn
   */
  export type prefixesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixes
     */
    select?: prefixesSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the prefixes
     */
    omit?: prefixesOmit<ExtArgs> | null;
    /**
     * The data used to create many prefixes.
     */
    data: prefixesCreateManyInput | prefixesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * prefixes update
   */
  export type prefixesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixes
     */
    select?: prefixesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the prefixes
     */
    omit?: prefixesOmit<ExtArgs> | null;
    /**
     * The data needed to update a prefixes.
     */
    data: XOR<prefixesUpdateInput, prefixesUncheckedUpdateInput>;
    /**
     * Choose, which prefixes to update.
     */
    where: prefixesWhereUniqueInput;
  };

  /**
   * prefixes updateMany
   */
  export type prefixesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prefixes.
     */
    data: XOR<prefixesUpdateManyMutationInput, prefixesUncheckedUpdateManyInput>;
    /**
     * Filter which prefixes to update
     */
    where?: prefixesWhereInput;
    /**
     * Limit how many prefixes to update.
     */
    limit?: number;
  };

  /**
   * prefixes updateManyAndReturn
   */
  export type prefixesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixes
     */
    select?: prefixesSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the prefixes
     */
    omit?: prefixesOmit<ExtArgs> | null;
    /**
     * The data used to update prefixes.
     */
    data: XOR<prefixesUpdateManyMutationInput, prefixesUncheckedUpdateManyInput>;
    /**
     * Filter which prefixes to update
     */
    where?: prefixesWhereInput;
    /**
     * Limit how many prefixes to update.
     */
    limit?: number;
  };

  /**
   * prefixes upsert
   */
  export type prefixesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixes
     */
    select?: prefixesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the prefixes
     */
    omit?: prefixesOmit<ExtArgs> | null;
    /**
     * The filter to search for the prefixes to update in case it exists.
     */
    where: prefixesWhereUniqueInput;
    /**
     * In case the prefixes found by the `where` argument doesn't exist, create a new prefixes with this data.
     */
    create: XOR<prefixesCreateInput, prefixesUncheckedCreateInput>;
    /**
     * In case the prefixes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prefixesUpdateInput, prefixesUncheckedUpdateInput>;
  };

  /**
   * prefixes delete
   */
  export type prefixesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixes
     */
    select?: prefixesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the prefixes
     */
    omit?: prefixesOmit<ExtArgs> | null;
    /**
     * Filter which prefixes to delete.
     */
    where: prefixesWhereUniqueInput;
  };

  /**
   * prefixes deleteMany
   */
  export type prefixesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prefixes to delete
     */
    where?: prefixesWhereInput;
    /**
     * Limit how many prefixes to delete.
     */
    limit?: number;
  };

  /**
   * prefixes without action
   */
  export type prefixesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prefixes
     */
    select?: prefixesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the prefixes
     */
    omit?: prefixesOmit<ExtArgs> | null;
  };

  /**
   * Model products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null;
    _avg: ProductsAvgAggregateOutputType | null;
    _sum: ProductsSumAggregateOutputType | null;
    _min: ProductsMinAggregateOutputType | null;
    _max: ProductsMaxAggregateOutputType | null;
  };

  export type ProductsAvgAggregateOutputType = {
    price: number | null;
    sales_price: number | null;
    fine: number | null;
    deposit: number | null;
    stock: number | null;
    current_rented_stock: number | null;
  };

  export type ProductsSumAggregateOutputType = {
    price: number | null;
    sales_price: number | null;
    fine: number | null;
    deposit: number | null;
    stock: number | null;
    current_rented_stock: number | null;
  };

  export type ProductsMinAggregateOutputType = {
    id: string | null;
    firm_id: string | null;
    name: string | null;
    code: string | null;
    price: number | null;
    sales_price: number | null;
    fine: number | null;
    deposit: number | null;
    description: string | null;
    rental_period: $Enums.Period | null;
    fine_period: $Enums.Period | null;
    color: string | null;
    type: string | null;
    barcode: string | null;
    brand: string | null;
    size: string | null;
    stock: number | null;
    current_rented_stock: number | null;
    status: $Enums.Status | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type ProductsMaxAggregateOutputType = {
    id: string | null;
    firm_id: string | null;
    name: string | null;
    code: string | null;
    price: number | null;
    sales_price: number | null;
    fine: number | null;
    deposit: number | null;
    description: string | null;
    rental_period: $Enums.Period | null;
    fine_period: $Enums.Period | null;
    color: string | null;
    type: string | null;
    barcode: string | null;
    brand: string | null;
    size: string | null;
    stock: number | null;
    current_rented_stock: number | null;
    status: $Enums.Status | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type ProductsCountAggregateOutputType = {
    id: number;
    firm_id: number;
    name: number;
    code: number;
    price: number;
    sales_price: number;
    fine: number;
    deposit: number;
    description: number;
    rental_period: number;
    fine_period: number;
    color: number;
    type: number;
    barcode: number;
    brand: number;
    size: number;
    stock: number;
    current_rented_stock: number;
    keywords: number;
    media: number;
    status: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type ProductsAvgAggregateInputType = {
    price?: true;
    sales_price?: true;
    fine?: true;
    deposit?: true;
    stock?: true;
    current_rented_stock?: true;
  };

  export type ProductsSumAggregateInputType = {
    price?: true;
    sales_price?: true;
    fine?: true;
    deposit?: true;
    stock?: true;
    current_rented_stock?: true;
  };

  export type ProductsMinAggregateInputType = {
    id?: true;
    firm_id?: true;
    name?: true;
    code?: true;
    price?: true;
    sales_price?: true;
    fine?: true;
    deposit?: true;
    description?: true;
    rental_period?: true;
    fine_period?: true;
    color?: true;
    type?: true;
    barcode?: true;
    brand?: true;
    size?: true;
    stock?: true;
    current_rented_stock?: true;
    status?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type ProductsMaxAggregateInputType = {
    id?: true;
    firm_id?: true;
    name?: true;
    code?: true;
    price?: true;
    sales_price?: true;
    fine?: true;
    deposit?: true;
    description?: true;
    rental_period?: true;
    fine_period?: true;
    color?: true;
    type?: true;
    barcode?: true;
    brand?: true;
    size?: true;
    stock?: true;
    current_rented_stock?: true;
    status?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type ProductsCountAggregateInputType = {
    id?: true;
    firm_id?: true;
    name?: true;
    code?: true;
    price?: true;
    sales_price?: true;
    fine?: true;
    deposit?: true;
    description?: true;
    rental_period?: true;
    fine_period?: true;
    color?: true;
    type?: true;
    barcode?: true;
    brand?: true;
    size?: true;
    stock?: true;
    current_rented_stock?: true;
    keywords?: true;
    media?: true;
    status?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to aggregate.
     */
    where?: productsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: productsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` products from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` products.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned products
     **/
    _count?: true | ProductsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProductsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProductsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProductsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProductsMaxAggregateInputType;
  };

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
    [P in keyof T & keyof AggregateProducts]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>;
  };

  export type productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput;
    orderBy?: productsOrderByWithAggregationInput | productsOrderByWithAggregationInput[];
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum;
    having?: productsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProductsCountAggregateInputType | true;
    _avg?: ProductsAvgAggregateInputType;
    _sum?: ProductsSumAggregateInputType;
    _min?: ProductsMinAggregateInputType;
    _max?: ProductsMaxAggregateInputType;
  };

  export type ProductsGroupByOutputType = {
    id: string;
    firm_id: string;
    name: string;
    code: string;
    price: number;
    sales_price: number;
    fine: number;
    deposit: number;
    description: string | null;
    rental_period: $Enums.Period;
    fine_period: $Enums.Period;
    color: string | null;
    type: string | null;
    barcode: string | null;
    brand: string | null;
    size: string | null;
    stock: number;
    current_rented_stock: number;
    keywords: string[];
    media: string[];
    status: $Enums.Status;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: ProductsCountAggregateOutputType | null;
    _avg: ProductsAvgAggregateOutputType | null;
    _sum: ProductsSumAggregateOutputType | null;
    _min: ProductsMinAggregateOutputType | null;
    _max: ProductsMaxAggregateOutputType | null;
  };

  type GetProductsGroupByPayload<T extends productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof ProductsGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
          : GetScalarType<T[P], ProductsGroupByOutputType[P]>;
      }
    >
  >;

  export type productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        firm_id?: boolean;
        name?: boolean;
        code?: boolean;
        price?: boolean;
        sales_price?: boolean;
        fine?: boolean;
        deposit?: boolean;
        description?: boolean;
        rental_period?: boolean;
        fine_period?: boolean;
        color?: boolean;
        type?: boolean;
        barcode?: boolean;
        brand?: boolean;
        size?: boolean;
        stock?: boolean;
        current_rented_stock?: boolean;
        keywords?: boolean;
        media?: boolean;
        status?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
        firm?: boolean | firmsDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["products"]
    >;

  export type productsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        firm_id?: boolean;
        name?: boolean;
        code?: boolean;
        price?: boolean;
        sales_price?: boolean;
        fine?: boolean;
        deposit?: boolean;
        description?: boolean;
        rental_period?: boolean;
        fine_period?: boolean;
        color?: boolean;
        type?: boolean;
        barcode?: boolean;
        brand?: boolean;
        size?: boolean;
        stock?: boolean;
        current_rented_stock?: boolean;
        keywords?: boolean;
        media?: boolean;
        status?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
        firm?: boolean | firmsDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["products"]
    >;

  export type productsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        firm_id?: boolean;
        name?: boolean;
        code?: boolean;
        price?: boolean;
        sales_price?: boolean;
        fine?: boolean;
        deposit?: boolean;
        description?: boolean;
        rental_period?: boolean;
        fine_period?: boolean;
        color?: boolean;
        type?: boolean;
        barcode?: boolean;
        brand?: boolean;
        size?: boolean;
        stock?: boolean;
        current_rented_stock?: boolean;
        keywords?: boolean;
        media?: boolean;
        status?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
        firm?: boolean | firmsDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["products"]
    >;

  export type productsSelectScalar = {
    id?: boolean;
    firm_id?: boolean;
    name?: boolean;
    code?: boolean;
    price?: boolean;
    sales_price?: boolean;
    fine?: boolean;
    deposit?: boolean;
    description?: boolean;
    rental_period?: boolean;
    fine_period?: boolean;
    color?: boolean;
    type?: boolean;
    barcode?: boolean;
    brand?: boolean;
    size?: boolean;
    stock?: boolean;
    current_rented_stock?: boolean;
    keywords?: boolean;
    media?: boolean;
    status?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type productsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "firm_id"
    | "name"
    | "code"
    | "price"
    | "sales_price"
    | "fine"
    | "deposit"
    | "description"
    | "rental_period"
    | "fine_period"
    | "color"
    | "type"
    | "barcode"
    | "brand"
    | "size"
    | "stock"
    | "current_rented_stock"
    | "keywords"
    | "media"
    | "status"
    | "active_flag"
    | "delete_flag"
    | "modified_at"
    | "created_at"
    | "created_by"
    | "modified_by",
    ExtArgs["result"]["products"]
  >;
  export type productsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    firm?: boolean | firmsDefaultArgs<ExtArgs>;
  };
  export type productsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    firm?: boolean | firmsDefaultArgs<ExtArgs>;
  };
  export type productsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    firm?: boolean | firmsDefaultArgs<ExtArgs>;
  };

  export type $productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "products";
    objects: {
      firm: Prisma.$firmsPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        firm_id: string;
        name: string;
        code: string;
        price: number;
        sales_price: number;
        fine: number;
        deposit: number;
        description: string | null;
        rental_period: $Enums.Period;
        fine_period: $Enums.Period;
        color: string | null;
        type: string | null;
        barcode: string | null;
        brand: string | null;
        size: string | null;
        stock: number;
        current_rented_stock: number;
        keywords: string[];
        media: string[];
        status: $Enums.Status;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["products"]
    >;
    composites: {};
  };

  type productsGetPayload<S extends boolean | null | undefined | productsDefaultArgs> = $Result.GetResult<
    Prisma.$productsPayload,
    S
  >;

  type productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    productsFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ProductsCountAggregateInputType | true;
  };

  export interface productsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["products"]; meta: { name: "products" } };
    /**
     * Find zero or one Products that matches the filter.
     * @param {productsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productsFindUniqueArgs>(
      args: SelectSubset<T, productsFindUniqueArgs<ExtArgs>>,
    ): Prisma__productsClient<
      $Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, productsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__productsClient<
      $Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productsFindFirstArgs>(
      args?: SelectSubset<T, productsFindFirstArgs<ExtArgs>>,
    ): Prisma__productsClient<
      $Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, productsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__productsClient<
      $Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     *
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     *
     */
    findMany<T extends productsFindManyArgs>(
      args?: SelectSubset<T, productsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Products.
     * @param {productsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     *
     */
    create<T extends productsCreateArgs>(
      args: SelectSubset<T, productsCreateArgs<ExtArgs>>,
    ): Prisma__productsClient<
      $Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Products.
     * @param {productsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends productsCreateManyArgs>(
      args?: SelectSubset<T, productsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Products and returns the data saved in the database.
     * @param {productsCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends productsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, productsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Products.
     * @param {productsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     *
     */
    delete<T extends productsDeleteArgs>(
      args: SelectSubset<T, productsDeleteArgs<ExtArgs>>,
    ): Prisma__productsClient<
      $Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Products.
     * @param {productsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends productsUpdateArgs>(
      args: SelectSubset<T, productsUpdateArgs<ExtArgs>>,
    ): Prisma__productsClient<
      $Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Products.
     * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends productsDeleteManyArgs>(
      args?: SelectSubset<T, productsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends productsUpdateManyArgs>(
      args: SelectSubset<T, productsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {productsUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends productsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, productsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Products.
     * @param {productsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends productsUpsertArgs>(
      args: SelectSubset<T, productsUpsertArgs<ExtArgs>>,
    ): Prisma__productsClient<
      $Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
     **/
    count<T extends productsCountArgs>(
      args?: Subset<T, productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ProductsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProductsAggregateArgs>(
      args: Subset<T, ProductsAggregateArgs>,
    ): Prisma.PrismaPromise<GetProductsAggregateType<T>>;

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends productsGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productsGroupByArgs["orderBy"] }
        : { orderBy?: productsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, productsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the products model
     */
    readonly fields: productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    firm<T extends firmsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, firmsDefaultArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the products model
   */
  interface productsFieldRefs {
    readonly id: FieldRef<"products", "String">;
    readonly firm_id: FieldRef<"products", "String">;
    readonly name: FieldRef<"products", "String">;
    readonly code: FieldRef<"products", "String">;
    readonly price: FieldRef<"products", "Float">;
    readonly sales_price: FieldRef<"products", "Float">;
    readonly fine: FieldRef<"products", "Float">;
    readonly deposit: FieldRef<"products", "Float">;
    readonly description: FieldRef<"products", "String">;
    readonly rental_period: FieldRef<"products", "Period">;
    readonly fine_period: FieldRef<"products", "Period">;
    readonly color: FieldRef<"products", "String">;
    readonly type: FieldRef<"products", "String">;
    readonly barcode: FieldRef<"products", "String">;
    readonly brand: FieldRef<"products", "String">;
    readonly size: FieldRef<"products", "String">;
    readonly stock: FieldRef<"products", "Float">;
    readonly current_rented_stock: FieldRef<"products", "Float">;
    readonly keywords: FieldRef<"products", "String[]">;
    readonly media: FieldRef<"products", "String[]">;
    readonly status: FieldRef<"products", "Status">;
    readonly active_flag: FieldRef<"products", "Boolean">;
    readonly delete_flag: FieldRef<"products", "Boolean">;
    readonly modified_at: FieldRef<"products", "DateTime">;
    readonly created_at: FieldRef<"products", "DateTime">;
    readonly created_by: FieldRef<"products", "String">;
    readonly modified_by: FieldRef<"products", "String">;
  }

  // Custom InputTypes
  /**
   * products findUnique
   */
  export type productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null;
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput;
  };

  /**
   * products findUniqueOrThrow
   */
  export type productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null;
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput;
  };

  /**
   * products findFirst
   */
  export type productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null;
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` products from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` products.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[];
  };

  /**
   * products findFirstOrThrow
   */
  export type productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null;
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` products from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` products.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[];
  };

  /**
   * products findMany
   */
  export type productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null;
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing products.
     */
    cursor?: productsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` products from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` products.
     */
    skip?: number;
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[];
  };

  /**
   * products create
   */
  export type productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null;
    /**
     * The data needed to create a products.
     */
    data: XOR<productsCreateInput, productsUncheckedCreateInput>;
  };

  /**
   * products createMany
   */
  export type productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * products createManyAndReturn
   */
  export type productsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * products update
   */
  export type productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null;
    /**
     * The data needed to update a products.
     */
    data: XOR<productsUpdateInput, productsUncheckedUpdateInput>;
    /**
     * Choose, which products to update.
     */
    where: productsWhereUniqueInput;
  };

  /**
   * products updateMany
   */
  export type productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>;
    /**
     * Filter which products to update
     */
    where?: productsWhereInput;
    /**
     * Limit how many products to update.
     */
    limit?: number;
  };

  /**
   * products updateManyAndReturn
   */
  export type productsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>;
    /**
     * Filter which products to update
     */
    where?: productsWhereInput;
    /**
     * Limit how many products to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * products upsert
   */
  export type productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null;
    /**
     * The filter to search for the products to update in case it exists.
     */
    where: productsWhereUniqueInput;
    /**
     * In case the products found by the `where` argument doesn't exist, create a new products with this data.
     */
    create: XOR<productsCreateInput, productsUncheckedCreateInput>;
    /**
     * In case the products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productsUpdateInput, productsUncheckedUpdateInput>;
  };

  /**
   * products delete
   */
  export type productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null;
    /**
     * Filter which products to delete.
     */
    where: productsWhereUniqueInput;
  };

  /**
   * products deleteMany
   */
  export type productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productsWhereInput;
    /**
     * Limit how many products to delete.
     */
    limit?: number;
  };

  /**
   * products without action
   */
  export type productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null;
  };

  /**
   * Model provider_configurations
   */

  export type AggregateProvider_configurations = {
    _count: Provider_configurationsCountAggregateOutputType | null;
    _min: Provider_configurationsMinAggregateOutputType | null;
    _max: Provider_configurationsMaxAggregateOutputType | null;
  };

  export type Provider_configurationsMinAggregateOutputType = {
    id: string | null;
    provider_type: string | null;
    name: string | null;
    description: string | null;
    contact_number: string | null;
    email: string | null;
    identifier: string | null;
    url: string | null;
    type: string | null;
    user_name: string | null;
    password: string | null;
    client_id: string | null;
    client_password: string | null;
    api_key: string | null;
    api_secret: string | null;
    status: string | null;
    outlet_reference: string | null;
    redirect_url: string | null;
    sender_id: string | null;
    account_usage_type_id: string | null;
    access_key_id: string | null;
    secret_access_key: string | null;
    region: string | null;
    bucket: string | null;
    cdn: string | null;
    project_id: string | null;
    key_file_name: string | null;
    cloud_name: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    created_by: string | null;
    created_at: Date | null;
    modified_at: Date | null;
    modified_by: string | null;
  };

  export type Provider_configurationsMaxAggregateOutputType = {
    id: string | null;
    provider_type: string | null;
    name: string | null;
    description: string | null;
    contact_number: string | null;
    email: string | null;
    identifier: string | null;
    url: string | null;
    type: string | null;
    user_name: string | null;
    password: string | null;
    client_id: string | null;
    client_password: string | null;
    api_key: string | null;
    api_secret: string | null;
    status: string | null;
    outlet_reference: string | null;
    redirect_url: string | null;
    sender_id: string | null;
    account_usage_type_id: string | null;
    access_key_id: string | null;
    secret_access_key: string | null;
    region: string | null;
    bucket: string | null;
    cdn: string | null;
    project_id: string | null;
    key_file_name: string | null;
    cloud_name: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    created_by: string | null;
    created_at: Date | null;
    modified_at: Date | null;
    modified_by: string | null;
  };

  export type Provider_configurationsCountAggregateOutputType = {
    id: number;
    provider_type: number;
    name: number;
    description: number;
    contact_number: number;
    email: number;
    identifier: number;
    url: number;
    type: number;
    user_name: number;
    password: number;
    client_id: number;
    client_password: number;
    api_key: number;
    api_secret: number;
    status: number;
    sender_details: number;
    outlet_reference: number;
    redirect_url: number;
    additional_properties: number;
    sender_id: number;
    account_usage_type_id: number;
    access_key_id: number;
    secret_access_key: number;
    region: number;
    bucket: number;
    cdn: number;
    project_id: number;
    key_file_name: number;
    cloud_name: number;
    active_flag: number;
    delete_flag: number;
    created_by: number;
    created_at: number;
    modified_at: number;
    modified_by: number;
    _all: number;
  };

  export type Provider_configurationsMinAggregateInputType = {
    id?: true;
    provider_type?: true;
    name?: true;
    description?: true;
    contact_number?: true;
    email?: true;
    identifier?: true;
    url?: true;
    type?: true;
    user_name?: true;
    password?: true;
    client_id?: true;
    client_password?: true;
    api_key?: true;
    api_secret?: true;
    status?: true;
    outlet_reference?: true;
    redirect_url?: true;
    sender_id?: true;
    account_usage_type_id?: true;
    access_key_id?: true;
    secret_access_key?: true;
    region?: true;
    bucket?: true;
    cdn?: true;
    project_id?: true;
    key_file_name?: true;
    cloud_name?: true;
    active_flag?: true;
    delete_flag?: true;
    created_by?: true;
    created_at?: true;
    modified_at?: true;
    modified_by?: true;
  };

  export type Provider_configurationsMaxAggregateInputType = {
    id?: true;
    provider_type?: true;
    name?: true;
    description?: true;
    contact_number?: true;
    email?: true;
    identifier?: true;
    url?: true;
    type?: true;
    user_name?: true;
    password?: true;
    client_id?: true;
    client_password?: true;
    api_key?: true;
    api_secret?: true;
    status?: true;
    outlet_reference?: true;
    redirect_url?: true;
    sender_id?: true;
    account_usage_type_id?: true;
    access_key_id?: true;
    secret_access_key?: true;
    region?: true;
    bucket?: true;
    cdn?: true;
    project_id?: true;
    key_file_name?: true;
    cloud_name?: true;
    active_flag?: true;
    delete_flag?: true;
    created_by?: true;
    created_at?: true;
    modified_at?: true;
    modified_by?: true;
  };

  export type Provider_configurationsCountAggregateInputType = {
    id?: true;
    provider_type?: true;
    name?: true;
    description?: true;
    contact_number?: true;
    email?: true;
    identifier?: true;
    url?: true;
    type?: true;
    user_name?: true;
    password?: true;
    client_id?: true;
    client_password?: true;
    api_key?: true;
    api_secret?: true;
    status?: true;
    sender_details?: true;
    outlet_reference?: true;
    redirect_url?: true;
    additional_properties?: true;
    sender_id?: true;
    account_usage_type_id?: true;
    access_key_id?: true;
    secret_access_key?: true;
    region?: true;
    bucket?: true;
    cdn?: true;
    project_id?: true;
    key_file_name?: true;
    cloud_name?: true;
    active_flag?: true;
    delete_flag?: true;
    created_by?: true;
    created_at?: true;
    modified_at?: true;
    modified_by?: true;
    _all?: true;
  };

  export type Provider_configurationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Filter which provider_configurations to aggregate.
       */
      where?: provider_configurationsWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of provider_configurations to fetch.
       */
      orderBy?: provider_configurationsOrderByWithRelationInput | provider_configurationsOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: provider_configurationsWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` provider_configurations from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` provider_configurations.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned provider_configurations
       **/
      _count?: true | Provider_configurationsCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: Provider_configurationsMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: Provider_configurationsMaxAggregateInputType;
    };

  export type GetProvider_configurationsAggregateType<T extends Provider_configurationsAggregateArgs> = {
    [P in keyof T & keyof AggregateProvider_configurations]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider_configurations[P]>
      : GetScalarType<T[P], AggregateProvider_configurations[P]>;
  };

  export type provider_configurationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_configurationsWhereInput;
    orderBy?: provider_configurationsOrderByWithAggregationInput | provider_configurationsOrderByWithAggregationInput[];
    by: Provider_configurationsScalarFieldEnum[] | Provider_configurationsScalarFieldEnum;
    having?: provider_configurationsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Provider_configurationsCountAggregateInputType | true;
    _min?: Provider_configurationsMinAggregateInputType;
    _max?: Provider_configurationsMaxAggregateInputType;
  };

  export type Provider_configurationsGroupByOutputType = {
    id: string;
    provider_type: string;
    name: string;
    description: string | null;
    contact_number: string | null;
    email: string | null;
    identifier: string | null;
    url: string | null;
    type: string | null;
    user_name: string | null;
    password: string | null;
    client_id: string | null;
    client_password: string | null;
    api_key: string | null;
    api_secret: string | null;
    status: string | null;
    sender_details: JsonValue | null;
    outlet_reference: string | null;
    redirect_url: string | null;
    additional_properties: JsonValue[];
    sender_id: string | null;
    account_usage_type_id: string | null;
    access_key_id: string | null;
    secret_access_key: string | null;
    region: string | null;
    bucket: string | null;
    cdn: string | null;
    project_id: string | null;
    key_file_name: string | null;
    cloud_name: string | null;
    active_flag: boolean;
    delete_flag: boolean;
    created_by: string | null;
    created_at: Date;
    modified_at: Date;
    modified_by: string | null;
    _count: Provider_configurationsCountAggregateOutputType | null;
    _min: Provider_configurationsMinAggregateOutputType | null;
    _max: Provider_configurationsMaxAggregateOutputType | null;
  };

  type GetProvider_configurationsGroupByPayload<T extends provider_configurationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Provider_configurationsGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof Provider_configurationsGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], Provider_configurationsGroupByOutputType[P]>
          : GetScalarType<T[P], Provider_configurationsGroupByOutputType[P]>;
      }
    >
  >;

  export type provider_configurationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        provider_type?: boolean;
        name?: boolean;
        description?: boolean;
        contact_number?: boolean;
        email?: boolean;
        identifier?: boolean;
        url?: boolean;
        type?: boolean;
        user_name?: boolean;
        password?: boolean;
        client_id?: boolean;
        client_password?: boolean;
        api_key?: boolean;
        api_secret?: boolean;
        status?: boolean;
        sender_details?: boolean;
        outlet_reference?: boolean;
        redirect_url?: boolean;
        additional_properties?: boolean;
        sender_id?: boolean;
        account_usage_type_id?: boolean;
        access_key_id?: boolean;
        secret_access_key?: boolean;
        region?: boolean;
        bucket?: boolean;
        cdn?: boolean;
        project_id?: boolean;
        key_file_name?: boolean;
        cloud_name?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        created_by?: boolean;
        created_at?: boolean;
        modified_at?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["provider_configurations"]
    >;

  export type provider_configurationsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      provider_type?: boolean;
      name?: boolean;
      description?: boolean;
      contact_number?: boolean;
      email?: boolean;
      identifier?: boolean;
      url?: boolean;
      type?: boolean;
      user_name?: boolean;
      password?: boolean;
      client_id?: boolean;
      client_password?: boolean;
      api_key?: boolean;
      api_secret?: boolean;
      status?: boolean;
      sender_details?: boolean;
      outlet_reference?: boolean;
      redirect_url?: boolean;
      additional_properties?: boolean;
      sender_id?: boolean;
      account_usage_type_id?: boolean;
      access_key_id?: boolean;
      secret_access_key?: boolean;
      region?: boolean;
      bucket?: boolean;
      cdn?: boolean;
      project_id?: boolean;
      key_file_name?: boolean;
      cloud_name?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      created_by?: boolean;
      created_at?: boolean;
      modified_at?: boolean;
      modified_by?: boolean;
    },
    ExtArgs["result"]["provider_configurations"]
  >;

  export type provider_configurationsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      provider_type?: boolean;
      name?: boolean;
      description?: boolean;
      contact_number?: boolean;
      email?: boolean;
      identifier?: boolean;
      url?: boolean;
      type?: boolean;
      user_name?: boolean;
      password?: boolean;
      client_id?: boolean;
      client_password?: boolean;
      api_key?: boolean;
      api_secret?: boolean;
      status?: boolean;
      sender_details?: boolean;
      outlet_reference?: boolean;
      redirect_url?: boolean;
      additional_properties?: boolean;
      sender_id?: boolean;
      account_usage_type_id?: boolean;
      access_key_id?: boolean;
      secret_access_key?: boolean;
      region?: boolean;
      bucket?: boolean;
      cdn?: boolean;
      project_id?: boolean;
      key_file_name?: boolean;
      cloud_name?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      created_by?: boolean;
      created_at?: boolean;
      modified_at?: boolean;
      modified_by?: boolean;
    },
    ExtArgs["result"]["provider_configurations"]
  >;

  export type provider_configurationsSelectScalar = {
    id?: boolean;
    provider_type?: boolean;
    name?: boolean;
    description?: boolean;
    contact_number?: boolean;
    email?: boolean;
    identifier?: boolean;
    url?: boolean;
    type?: boolean;
    user_name?: boolean;
    password?: boolean;
    client_id?: boolean;
    client_password?: boolean;
    api_key?: boolean;
    api_secret?: boolean;
    status?: boolean;
    sender_details?: boolean;
    outlet_reference?: boolean;
    redirect_url?: boolean;
    additional_properties?: boolean;
    sender_id?: boolean;
    account_usage_type_id?: boolean;
    access_key_id?: boolean;
    secret_access_key?: boolean;
    region?: boolean;
    bucket?: boolean;
    cdn?: boolean;
    project_id?: boolean;
    key_file_name?: boolean;
    cloud_name?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: boolean;
    created_at?: boolean;
    modified_at?: boolean;
    modified_by?: boolean;
  };

  export type provider_configurationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "provider_type"
      | "name"
      | "description"
      | "contact_number"
      | "email"
      | "identifier"
      | "url"
      | "type"
      | "user_name"
      | "password"
      | "client_id"
      | "client_password"
      | "api_key"
      | "api_secret"
      | "status"
      | "sender_details"
      | "outlet_reference"
      | "redirect_url"
      | "additional_properties"
      | "sender_id"
      | "account_usage_type_id"
      | "access_key_id"
      | "secret_access_key"
      | "region"
      | "bucket"
      | "cdn"
      | "project_id"
      | "key_file_name"
      | "cloud_name"
      | "active_flag"
      | "delete_flag"
      | "created_by"
      | "created_at"
      | "modified_at"
      | "modified_by",
      ExtArgs["result"]["provider_configurations"]
    >;

  export type $provider_configurationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "provider_configurations";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        provider_type: string;
        name: string;
        description: string | null;
        contact_number: string | null;
        email: string | null;
        identifier: string | null;
        url: string | null;
        type: string | null;
        user_name: string | null;
        password: string | null;
        client_id: string | null;
        client_password: string | null;
        api_key: string | null;
        api_secret: string | null;
        status: string | null;
        sender_details: Prisma.JsonValue | null;
        outlet_reference: string | null;
        redirect_url: string | null;
        additional_properties: Prisma.JsonValue[];
        sender_id: string | null;
        account_usage_type_id: string | null;
        access_key_id: string | null;
        secret_access_key: string | null;
        region: string | null;
        bucket: string | null;
        cdn: string | null;
        project_id: string | null;
        key_file_name: string | null;
        cloud_name: string | null;
        active_flag: boolean;
        delete_flag: boolean;
        created_by: string | null;
        created_at: Date;
        modified_at: Date;
        modified_by: string | null;
      },
      ExtArgs["result"]["provider_configurations"]
    >;
    composites: {};
  };

  type provider_configurationsGetPayload<S extends boolean | null | undefined | provider_configurationsDefaultArgs> =
    $Result.GetResult<Prisma.$provider_configurationsPayload, S>;

  type provider_configurationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    provider_configurationsFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: Provider_configurationsCountAggregateInputType | true;
  };

  export interface provider_configurationsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["provider_configurations"];
      meta: { name: "provider_configurations" };
    };
    /**
     * Find zero or one Provider_configurations that matches the filter.
     * @param {provider_configurationsFindUniqueArgs} args - Arguments to find a Provider_configurations
     * @example
     * // Get one Provider_configurations
     * const provider_configurations = await prisma.provider_configurations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends provider_configurationsFindUniqueArgs>(
      args: SelectSubset<T, provider_configurationsFindUniqueArgs<ExtArgs>>,
    ): Prisma__provider_configurationsClient<
      $Result.GetResult<Prisma.$provider_configurationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Provider_configurations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {provider_configurationsFindUniqueOrThrowArgs} args - Arguments to find a Provider_configurations
     * @example
     * // Get one Provider_configurations
     * const provider_configurations = await prisma.provider_configurations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends provider_configurationsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, provider_configurationsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__provider_configurationsClient<
      $Result.GetResult<Prisma.$provider_configurationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Provider_configurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_configurationsFindFirstArgs} args - Arguments to find a Provider_configurations
     * @example
     * // Get one Provider_configurations
     * const provider_configurations = await prisma.provider_configurations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends provider_configurationsFindFirstArgs>(
      args?: SelectSubset<T, provider_configurationsFindFirstArgs<ExtArgs>>,
    ): Prisma__provider_configurationsClient<
      $Result.GetResult<Prisma.$provider_configurationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Provider_configurations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_configurationsFindFirstOrThrowArgs} args - Arguments to find a Provider_configurations
     * @example
     * // Get one Provider_configurations
     * const provider_configurations = await prisma.provider_configurations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends provider_configurationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, provider_configurationsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__provider_configurationsClient<
      $Result.GetResult<Prisma.$provider_configurationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Provider_configurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_configurationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provider_configurations
     * const provider_configurations = await prisma.provider_configurations.findMany()
     *
     * // Get first 10 Provider_configurations
     * const provider_configurations = await prisma.provider_configurations.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const provider_configurationsWithIdOnly = await prisma.provider_configurations.findMany({ select: { id: true } })
     *
     */
    findMany<T extends provider_configurationsFindManyArgs>(
      args?: SelectSubset<T, provider_configurationsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$provider_configurationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Provider_configurations.
     * @param {provider_configurationsCreateArgs} args - Arguments to create a Provider_configurations.
     * @example
     * // Create one Provider_configurations
     * const Provider_configurations = await prisma.provider_configurations.create({
     *   data: {
     *     // ... data to create a Provider_configurations
     *   }
     * })
     *
     */
    create<T extends provider_configurationsCreateArgs>(
      args: SelectSubset<T, provider_configurationsCreateArgs<ExtArgs>>,
    ): Prisma__provider_configurationsClient<
      $Result.GetResult<Prisma.$provider_configurationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Provider_configurations.
     * @param {provider_configurationsCreateManyArgs} args - Arguments to create many Provider_configurations.
     * @example
     * // Create many Provider_configurations
     * const provider_configurations = await prisma.provider_configurations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends provider_configurationsCreateManyArgs>(
      args?: SelectSubset<T, provider_configurationsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Provider_configurations and returns the data saved in the database.
     * @param {provider_configurationsCreateManyAndReturnArgs} args - Arguments to create many Provider_configurations.
     * @example
     * // Create many Provider_configurations
     * const provider_configurations = await prisma.provider_configurations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Provider_configurations and only return the `id`
     * const provider_configurationsWithIdOnly = await prisma.provider_configurations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends provider_configurationsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, provider_configurationsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$provider_configurationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Provider_configurations.
     * @param {provider_configurationsDeleteArgs} args - Arguments to delete one Provider_configurations.
     * @example
     * // Delete one Provider_configurations
     * const Provider_configurations = await prisma.provider_configurations.delete({
     *   where: {
     *     // ... filter to delete one Provider_configurations
     *   }
     * })
     *
     */
    delete<T extends provider_configurationsDeleteArgs>(
      args: SelectSubset<T, provider_configurationsDeleteArgs<ExtArgs>>,
    ): Prisma__provider_configurationsClient<
      $Result.GetResult<Prisma.$provider_configurationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Provider_configurations.
     * @param {provider_configurationsUpdateArgs} args - Arguments to update one Provider_configurations.
     * @example
     * // Update one Provider_configurations
     * const provider_configurations = await prisma.provider_configurations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends provider_configurationsUpdateArgs>(
      args: SelectSubset<T, provider_configurationsUpdateArgs<ExtArgs>>,
    ): Prisma__provider_configurationsClient<
      $Result.GetResult<Prisma.$provider_configurationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Provider_configurations.
     * @param {provider_configurationsDeleteManyArgs} args - Arguments to filter Provider_configurations to delete.
     * @example
     * // Delete a few Provider_configurations
     * const { count } = await prisma.provider_configurations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends provider_configurationsDeleteManyArgs>(
      args?: SelectSubset<T, provider_configurationsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Provider_configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_configurationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provider_configurations
     * const provider_configurations = await prisma.provider_configurations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends provider_configurationsUpdateManyArgs>(
      args: SelectSubset<T, provider_configurationsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Provider_configurations and returns the data updated in the database.
     * @param {provider_configurationsUpdateManyAndReturnArgs} args - Arguments to update many Provider_configurations.
     * @example
     * // Update many Provider_configurations
     * const provider_configurations = await prisma.provider_configurations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Provider_configurations and only return the `id`
     * const provider_configurationsWithIdOnly = await prisma.provider_configurations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends provider_configurationsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, provider_configurationsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$provider_configurationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Provider_configurations.
     * @param {provider_configurationsUpsertArgs} args - Arguments to update or create a Provider_configurations.
     * @example
     * // Update or create a Provider_configurations
     * const provider_configurations = await prisma.provider_configurations.upsert({
     *   create: {
     *     // ... data to create a Provider_configurations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider_configurations we want to update
     *   }
     * })
     */
    upsert<T extends provider_configurationsUpsertArgs>(
      args: SelectSubset<T, provider_configurationsUpsertArgs<ExtArgs>>,
    ): Prisma__provider_configurationsClient<
      $Result.GetResult<Prisma.$provider_configurationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Provider_configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_configurationsCountArgs} args - Arguments to filter Provider_configurations to count.
     * @example
     * // Count the number of Provider_configurations
     * const count = await prisma.provider_configurations.count({
     *   where: {
     *     // ... the filter for the Provider_configurations we want to count
     *   }
     * })
     **/
    count<T extends provider_configurationsCountArgs>(
      args?: Subset<T, provider_configurationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], Provider_configurationsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Provider_configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Provider_configurationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Provider_configurationsAggregateArgs>(
      args: Subset<T, Provider_configurationsAggregateArgs>,
    ): Prisma.PrismaPromise<GetProvider_configurationsAggregateType<T>>;

    /**
     * Group by Provider_configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_configurationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends provider_configurationsGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: provider_configurationsGroupByArgs["orderBy"] }
        : { orderBy?: provider_configurationsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, provider_configurationsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetProvider_configurationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the provider_configurations model
     */
    readonly fields: provider_configurationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for provider_configurations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__provider_configurationsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the provider_configurations model
   */
  interface provider_configurationsFieldRefs {
    readonly id: FieldRef<"provider_configurations", "String">;
    readonly provider_type: FieldRef<"provider_configurations", "String">;
    readonly name: FieldRef<"provider_configurations", "String">;
    readonly description: FieldRef<"provider_configurations", "String">;
    readonly contact_number: FieldRef<"provider_configurations", "String">;
    readonly email: FieldRef<"provider_configurations", "String">;
    readonly identifier: FieldRef<"provider_configurations", "String">;
    readonly url: FieldRef<"provider_configurations", "String">;
    readonly type: FieldRef<"provider_configurations", "String">;
    readonly user_name: FieldRef<"provider_configurations", "String">;
    readonly password: FieldRef<"provider_configurations", "String">;
    readonly client_id: FieldRef<"provider_configurations", "String">;
    readonly client_password: FieldRef<"provider_configurations", "String">;
    readonly api_key: FieldRef<"provider_configurations", "String">;
    readonly api_secret: FieldRef<"provider_configurations", "String">;
    readonly status: FieldRef<"provider_configurations", "String">;
    readonly sender_details: FieldRef<"provider_configurations", "Json">;
    readonly outlet_reference: FieldRef<"provider_configurations", "String">;
    readonly redirect_url: FieldRef<"provider_configurations", "String">;
    readonly additional_properties: FieldRef<"provider_configurations", "Json[]">;
    readonly sender_id: FieldRef<"provider_configurations", "String">;
    readonly account_usage_type_id: FieldRef<"provider_configurations", "String">;
    readonly access_key_id: FieldRef<"provider_configurations", "String">;
    readonly secret_access_key: FieldRef<"provider_configurations", "String">;
    readonly region: FieldRef<"provider_configurations", "String">;
    readonly bucket: FieldRef<"provider_configurations", "String">;
    readonly cdn: FieldRef<"provider_configurations", "String">;
    readonly project_id: FieldRef<"provider_configurations", "String">;
    readonly key_file_name: FieldRef<"provider_configurations", "String">;
    readonly cloud_name: FieldRef<"provider_configurations", "String">;
    readonly active_flag: FieldRef<"provider_configurations", "Boolean">;
    readonly delete_flag: FieldRef<"provider_configurations", "Boolean">;
    readonly created_by: FieldRef<"provider_configurations", "String">;
    readonly created_at: FieldRef<"provider_configurations", "DateTime">;
    readonly modified_at: FieldRef<"provider_configurations", "DateTime">;
    readonly modified_by: FieldRef<"provider_configurations", "String">;
  }

  // Custom InputTypes
  /**
   * provider_configurations findUnique
   */
  export type provider_configurationsFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the provider_configurations
     */
    select?: provider_configurationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the provider_configurations
     */
    omit?: provider_configurationsOmit<ExtArgs> | null;
    /**
     * Filter, which provider_configurations to fetch.
     */
    where: provider_configurationsWhereUniqueInput;
  };

  /**
   * provider_configurations findUniqueOrThrow
   */
  export type provider_configurationsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the provider_configurations
     */
    select?: provider_configurationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the provider_configurations
     */
    omit?: provider_configurationsOmit<ExtArgs> | null;
    /**
     * Filter, which provider_configurations to fetch.
     */
    where: provider_configurationsWhereUniqueInput;
  };

  /**
   * provider_configurations findFirst
   */
  export type provider_configurationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the provider_configurations
       */
      select?: provider_configurationsSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the provider_configurations
       */
      omit?: provider_configurationsOmit<ExtArgs> | null;
      /**
       * Filter, which provider_configurations to fetch.
       */
      where?: provider_configurationsWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of provider_configurations to fetch.
       */
      orderBy?: provider_configurationsOrderByWithRelationInput | provider_configurationsOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for provider_configurations.
       */
      cursor?: provider_configurationsWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` provider_configurations from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` provider_configurations.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of provider_configurations.
       */
      distinct?: Provider_configurationsScalarFieldEnum | Provider_configurationsScalarFieldEnum[];
    };

  /**
   * provider_configurations findFirstOrThrow
   */
  export type provider_configurationsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the provider_configurations
     */
    select?: provider_configurationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the provider_configurations
     */
    omit?: provider_configurationsOmit<ExtArgs> | null;
    /**
     * Filter, which provider_configurations to fetch.
     */
    where?: provider_configurationsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of provider_configurations to fetch.
     */
    orderBy?: provider_configurationsOrderByWithRelationInput | provider_configurationsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for provider_configurations.
     */
    cursor?: provider_configurationsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` provider_configurations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` provider_configurations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of provider_configurations.
     */
    distinct?: Provider_configurationsScalarFieldEnum | Provider_configurationsScalarFieldEnum[];
  };

  /**
   * provider_configurations findMany
   */
  export type provider_configurationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the provider_configurations
       */
      select?: provider_configurationsSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the provider_configurations
       */
      omit?: provider_configurationsOmit<ExtArgs> | null;
      /**
       * Filter, which provider_configurations to fetch.
       */
      where?: provider_configurationsWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of provider_configurations to fetch.
       */
      orderBy?: provider_configurationsOrderByWithRelationInput | provider_configurationsOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing provider_configurations.
       */
      cursor?: provider_configurationsWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` provider_configurations from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` provider_configurations.
       */
      skip?: number;
      distinct?: Provider_configurationsScalarFieldEnum | Provider_configurationsScalarFieldEnum[];
    };

  /**
   * provider_configurations create
   */
  export type provider_configurationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_configurations
     */
    select?: provider_configurationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the provider_configurations
     */
    omit?: provider_configurationsOmit<ExtArgs> | null;
    /**
     * The data needed to create a provider_configurations.
     */
    data: XOR<provider_configurationsCreateInput, provider_configurationsUncheckedCreateInput>;
  };

  /**
   * provider_configurations createMany
   */
  export type provider_configurationsCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many provider_configurations.
     */
    data: provider_configurationsCreateManyInput | provider_configurationsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * provider_configurations createManyAndReturn
   */
  export type provider_configurationsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the provider_configurations
     */
    select?: provider_configurationsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the provider_configurations
     */
    omit?: provider_configurationsOmit<ExtArgs> | null;
    /**
     * The data used to create many provider_configurations.
     */
    data: provider_configurationsCreateManyInput | provider_configurationsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * provider_configurations update
   */
  export type provider_configurationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_configurations
     */
    select?: provider_configurationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the provider_configurations
     */
    omit?: provider_configurationsOmit<ExtArgs> | null;
    /**
     * The data needed to update a provider_configurations.
     */
    data: XOR<provider_configurationsUpdateInput, provider_configurationsUncheckedUpdateInput>;
    /**
     * Choose, which provider_configurations to update.
     */
    where: provider_configurationsWhereUniqueInput;
  };

  /**
   * provider_configurations updateMany
   */
  export type provider_configurationsUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update provider_configurations.
     */
    data: XOR<provider_configurationsUpdateManyMutationInput, provider_configurationsUncheckedUpdateManyInput>;
    /**
     * Filter which provider_configurations to update
     */
    where?: provider_configurationsWhereInput;
    /**
     * Limit how many provider_configurations to update.
     */
    limit?: number;
  };

  /**
   * provider_configurations updateManyAndReturn
   */
  export type provider_configurationsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the provider_configurations
     */
    select?: provider_configurationsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the provider_configurations
     */
    omit?: provider_configurationsOmit<ExtArgs> | null;
    /**
     * The data used to update provider_configurations.
     */
    data: XOR<provider_configurationsUpdateManyMutationInput, provider_configurationsUncheckedUpdateManyInput>;
    /**
     * Filter which provider_configurations to update
     */
    where?: provider_configurationsWhereInput;
    /**
     * Limit how many provider_configurations to update.
     */
    limit?: number;
  };

  /**
   * provider_configurations upsert
   */
  export type provider_configurationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_configurations
     */
    select?: provider_configurationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the provider_configurations
     */
    omit?: provider_configurationsOmit<ExtArgs> | null;
    /**
     * The filter to search for the provider_configurations to update in case it exists.
     */
    where: provider_configurationsWhereUniqueInput;
    /**
     * In case the provider_configurations found by the `where` argument doesn't exist, create a new provider_configurations with this data.
     */
    create: XOR<provider_configurationsCreateInput, provider_configurationsUncheckedCreateInput>;
    /**
     * In case the provider_configurations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<provider_configurationsUpdateInput, provider_configurationsUncheckedUpdateInput>;
  };

  /**
   * provider_configurations delete
   */
  export type provider_configurationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_configurations
     */
    select?: provider_configurationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the provider_configurations
     */
    omit?: provider_configurationsOmit<ExtArgs> | null;
    /**
     * Filter which provider_configurations to delete.
     */
    where: provider_configurationsWhereUniqueInput;
  };

  /**
   * provider_configurations deleteMany
   */
  export type provider_configurationsDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which provider_configurations to delete
     */
    where?: provider_configurationsWhereInput;
    /**
     * Limit how many provider_configurations to delete.
     */
    limit?: number;
  };

  /**
   * provider_configurations without action
   */
  export type provider_configurationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_configurations
     */
    select?: provider_configurationsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the provider_configurations
     */
    omit?: provider_configurationsOmit<ExtArgs> | null;
  };

  /**
   * Model rentals
   */

  export type AggregateRentals = {
    _count: RentalsCountAggregateOutputType | null;
    _avg: RentalsAvgAggregateOutputType | null;
    _sum: RentalsSumAggregateOutputType | null;
    _min: RentalsMinAggregateOutputType | null;
    _max: RentalsMaxAggregateOutputType | null;
  };

  export type RentalsAvgAggregateOutputType = {
    discount_amount: number | null;
    pending_amount: number | null;
    advance_amount: number | null;
    deposit_amount: number | null;
    paid_amount: number | null;
    total_amount: number | null;
    fine_amount: number | null;
  };

  export type RentalsSumAggregateOutputType = {
    discount_amount: number | null;
    pending_amount: number | null;
    advance_amount: number | null;
    deposit_amount: number | null;
    paid_amount: number | null;
    total_amount: number | null;
    fine_amount: number | null;
  };

  export type RentalsMinAggregateOutputType = {
    id: string | null;
    user_id: string | null;
    payment_mode_id: string | null;
    invoice_id: string | null;
    invoice_date: Date | null;
    invoice_status: $Enums.InvoiceStatus | null;
    rental_period: $Enums.Period | null;
    discount_amount: number | null;
    pending_amount: number | null;
    advance_amount: number | null;
    deposit_amount: number | null;
    paid_amount: number | null;
    total_amount: number | null;
    fine_amount: number | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    created_by: string | null;
    created_at: Date | null;
    modified_at: Date | null;
    modified_by: string | null;
  };

  export type RentalsMaxAggregateOutputType = {
    id: string | null;
    user_id: string | null;
    payment_mode_id: string | null;
    invoice_id: string | null;
    invoice_date: Date | null;
    invoice_status: $Enums.InvoiceStatus | null;
    rental_period: $Enums.Period | null;
    discount_amount: number | null;
    pending_amount: number | null;
    advance_amount: number | null;
    deposit_amount: number | null;
    paid_amount: number | null;
    total_amount: number | null;
    fine_amount: number | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    created_by: string | null;
    created_at: Date | null;
    modified_at: Date | null;
    modified_by: string | null;
  };

  export type RentalsCountAggregateOutputType = {
    id: number;
    user_id: number;
    payment_mode_id: number;
    invoice_id: number;
    invoice_date: number;
    invoice_status: number;
    rental_period: number;
    discount_amount: number;
    pending_amount: number;
    advance_amount: number;
    deposit_amount: number;
    paid_amount: number;
    total_amount: number;
    fine_amount: number;
    rental_products: number;
    active_flag: number;
    delete_flag: number;
    created_by: number;
    created_at: number;
    modified_at: number;
    modified_by: number;
    _all: number;
  };

  export type RentalsAvgAggregateInputType = {
    discount_amount?: true;
    pending_amount?: true;
    advance_amount?: true;
    deposit_amount?: true;
    paid_amount?: true;
    total_amount?: true;
    fine_amount?: true;
  };

  export type RentalsSumAggregateInputType = {
    discount_amount?: true;
    pending_amount?: true;
    advance_amount?: true;
    deposit_amount?: true;
    paid_amount?: true;
    total_amount?: true;
    fine_amount?: true;
  };

  export type RentalsMinAggregateInputType = {
    id?: true;
    user_id?: true;
    payment_mode_id?: true;
    invoice_id?: true;
    invoice_date?: true;
    invoice_status?: true;
    rental_period?: true;
    discount_amount?: true;
    pending_amount?: true;
    advance_amount?: true;
    deposit_amount?: true;
    paid_amount?: true;
    total_amount?: true;
    fine_amount?: true;
    active_flag?: true;
    delete_flag?: true;
    created_by?: true;
    created_at?: true;
    modified_at?: true;
    modified_by?: true;
  };

  export type RentalsMaxAggregateInputType = {
    id?: true;
    user_id?: true;
    payment_mode_id?: true;
    invoice_id?: true;
    invoice_date?: true;
    invoice_status?: true;
    rental_period?: true;
    discount_amount?: true;
    pending_amount?: true;
    advance_amount?: true;
    deposit_amount?: true;
    paid_amount?: true;
    total_amount?: true;
    fine_amount?: true;
    active_flag?: true;
    delete_flag?: true;
    created_by?: true;
    created_at?: true;
    modified_at?: true;
    modified_by?: true;
  };

  export type RentalsCountAggregateInputType = {
    id?: true;
    user_id?: true;
    payment_mode_id?: true;
    invoice_id?: true;
    invoice_date?: true;
    invoice_status?: true;
    rental_period?: true;
    discount_amount?: true;
    pending_amount?: true;
    advance_amount?: true;
    deposit_amount?: true;
    paid_amount?: true;
    total_amount?: true;
    fine_amount?: true;
    rental_products?: true;
    active_flag?: true;
    delete_flag?: true;
    created_by?: true;
    created_at?: true;
    modified_at?: true;
    modified_by?: true;
    _all?: true;
  };

  export type RentalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rentals to aggregate.
     */
    where?: rentalsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of rentals to fetch.
     */
    orderBy?: rentalsOrderByWithRelationInput | rentalsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: rentalsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` rentals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` rentals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned rentals
     **/
    _count?: true | RentalsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RentalsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RentalsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RentalsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RentalsMaxAggregateInputType;
  };

  export type GetRentalsAggregateType<T extends RentalsAggregateArgs> = {
    [P in keyof T & keyof AggregateRentals]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRentals[P]>
      : GetScalarType<T[P], AggregateRentals[P]>;
  };

  export type rentalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rentalsWhereInput;
    orderBy?: rentalsOrderByWithAggregationInput | rentalsOrderByWithAggregationInput[];
    by: RentalsScalarFieldEnum[] | RentalsScalarFieldEnum;
    having?: rentalsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RentalsCountAggregateInputType | true;
    _avg?: RentalsAvgAggregateInputType;
    _sum?: RentalsSumAggregateInputType;
    _min?: RentalsMinAggregateInputType;
    _max?: RentalsMaxAggregateInputType;
  };

  export type RentalsGroupByOutputType = {
    id: string;
    user_id: string;
    payment_mode_id: string;
    invoice_id: string;
    invoice_date: Date;
    invoice_status: $Enums.InvoiceStatus;
    rental_period: $Enums.Period;
    discount_amount: number;
    pending_amount: number;
    advance_amount: number;
    deposit_amount: number;
    paid_amount: number;
    total_amount: number;
    fine_amount: number;
    rental_products: JsonValue[];
    active_flag: boolean;
    delete_flag: boolean;
    created_by: string | null;
    created_at: Date;
    modified_at: Date;
    modified_by: string | null;
    _count: RentalsCountAggregateOutputType | null;
    _avg: RentalsAvgAggregateOutputType | null;
    _sum: RentalsSumAggregateOutputType | null;
    _min: RentalsMinAggregateOutputType | null;
    _max: RentalsMaxAggregateOutputType | null;
  };

  type GetRentalsGroupByPayload<T extends rentalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RentalsGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof RentalsGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RentalsGroupByOutputType[P]>
          : GetScalarType<T[P], RentalsGroupByOutputType[P]>;
      }
    >
  >;

  export type rentalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<
    {
      id?: boolean;
      user_id?: boolean;
      payment_mode_id?: boolean;
      invoice_id?: boolean;
      invoice_date?: boolean;
      invoice_status?: boolean;
      rental_period?: boolean;
      discount_amount?: boolean;
      pending_amount?: boolean;
      advance_amount?: boolean;
      deposit_amount?: boolean;
      paid_amount?: boolean;
      total_amount?: boolean;
      fine_amount?: boolean;
      rental_products?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      created_by?: boolean;
      created_at?: boolean;
      modified_at?: boolean;
      modified_by?: boolean;
      payment_collections?: boolean | rentals$payment_collectionsArgs<ExtArgs>;
      user?: boolean | rentals$userArgs<ExtArgs>;
      payment_mode?: boolean | rentals$payment_modeArgs<ExtArgs>;
      _count?: boolean | RentalsCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["rentals"]
  >;

  export type rentalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        user_id?: boolean;
        payment_mode_id?: boolean;
        invoice_id?: boolean;
        invoice_date?: boolean;
        invoice_status?: boolean;
        rental_period?: boolean;
        discount_amount?: boolean;
        pending_amount?: boolean;
        advance_amount?: boolean;
        deposit_amount?: boolean;
        paid_amount?: boolean;
        total_amount?: boolean;
        fine_amount?: boolean;
        rental_products?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        created_by?: boolean;
        created_at?: boolean;
        modified_at?: boolean;
        modified_by?: boolean;
        user?: boolean | rentals$userArgs<ExtArgs>;
        payment_mode?: boolean | rentals$payment_modeArgs<ExtArgs>;
      },
      ExtArgs["result"]["rentals"]
    >;

  export type rentalsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        user_id?: boolean;
        payment_mode_id?: boolean;
        invoice_id?: boolean;
        invoice_date?: boolean;
        invoice_status?: boolean;
        rental_period?: boolean;
        discount_amount?: boolean;
        pending_amount?: boolean;
        advance_amount?: boolean;
        deposit_amount?: boolean;
        paid_amount?: boolean;
        total_amount?: boolean;
        fine_amount?: boolean;
        rental_products?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        created_by?: boolean;
        created_at?: boolean;
        modified_at?: boolean;
        modified_by?: boolean;
        user?: boolean | rentals$userArgs<ExtArgs>;
        payment_mode?: boolean | rentals$payment_modeArgs<ExtArgs>;
      },
      ExtArgs["result"]["rentals"]
    >;

  export type rentalsSelectScalar = {
    id?: boolean;
    user_id?: boolean;
    payment_mode_id?: boolean;
    invoice_id?: boolean;
    invoice_date?: boolean;
    invoice_status?: boolean;
    rental_period?: boolean;
    discount_amount?: boolean;
    pending_amount?: boolean;
    advance_amount?: boolean;
    deposit_amount?: boolean;
    paid_amount?: boolean;
    total_amount?: boolean;
    fine_amount?: boolean;
    rental_products?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: boolean;
    created_at?: boolean;
    modified_at?: boolean;
    modified_by?: boolean;
  };

  export type rentalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "user_id"
    | "payment_mode_id"
    | "invoice_id"
    | "invoice_date"
    | "invoice_status"
    | "rental_period"
    | "discount_amount"
    | "pending_amount"
    | "advance_amount"
    | "deposit_amount"
    | "paid_amount"
    | "total_amount"
    | "fine_amount"
    | "rental_products"
    | "active_flag"
    | "delete_flag"
    | "created_by"
    | "created_at"
    | "modified_at"
    | "modified_by",
    ExtArgs["result"]["rentals"]
  >;
  export type rentalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment_collections?: boolean | rentals$payment_collectionsArgs<ExtArgs>;
    user?: boolean | rentals$userArgs<ExtArgs>;
    payment_mode?: boolean | rentals$payment_modeArgs<ExtArgs>;
    _count?: boolean | RentalsCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type rentalsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | rentals$userArgs<ExtArgs>;
    payment_mode?: boolean | rentals$payment_modeArgs<ExtArgs>;
  };
  export type rentalsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | rentals$userArgs<ExtArgs>;
    payment_mode?: boolean | rentals$payment_modeArgs<ExtArgs>;
  };

  export type $rentalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rentals";
    objects: {
      payment_collections: Prisma.$payment_collectionsPayload<ExtArgs>[];
      user: Prisma.$customersPayload<ExtArgs> | null;
      payment_mode: Prisma.$payment_modesPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        user_id: string;
        payment_mode_id: string;
        invoice_id: string;
        invoice_date: Date;
        invoice_status: $Enums.InvoiceStatus;
        rental_period: $Enums.Period;
        discount_amount: number;
        pending_amount: number;
        advance_amount: number;
        deposit_amount: number;
        paid_amount: number;
        total_amount: number;
        fine_amount: number;
        rental_products: Prisma.JsonValue[];
        active_flag: boolean;
        delete_flag: boolean;
        created_by: string | null;
        created_at: Date;
        modified_at: Date;
        modified_by: string | null;
      },
      ExtArgs["result"]["rentals"]
    >;
    composites: {};
  };

  type rentalsGetPayload<S extends boolean | null | undefined | rentalsDefaultArgs> = $Result.GetResult<
    Prisma.$rentalsPayload,
    S
  >;

  type rentalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    rentalsFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: RentalsCountAggregateInputType | true;
  };

  export interface rentalsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["rentals"]; meta: { name: "rentals" } };
    /**
     * Find zero or one Rentals that matches the filter.
     * @param {rentalsFindUniqueArgs} args - Arguments to find a Rentals
     * @example
     * // Get one Rentals
     * const rentals = await prisma.rentals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rentalsFindUniqueArgs>(
      args: SelectSubset<T, rentalsFindUniqueArgs<ExtArgs>>,
    ): Prisma__rentalsClient<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Rentals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rentalsFindUniqueOrThrowArgs} args - Arguments to find a Rentals
     * @example
     * // Get one Rentals
     * const rentals = await prisma.rentals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rentalsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, rentalsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__rentalsClient<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Rentals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rentalsFindFirstArgs} args - Arguments to find a Rentals
     * @example
     * // Get one Rentals
     * const rentals = await prisma.rentals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rentalsFindFirstArgs>(
      args?: SelectSubset<T, rentalsFindFirstArgs<ExtArgs>>,
    ): Prisma__rentalsClient<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Rentals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rentalsFindFirstOrThrowArgs} args - Arguments to find a Rentals
     * @example
     * // Get one Rentals
     * const rentals = await prisma.rentals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rentalsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, rentalsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__rentalsClient<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Rentals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rentalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rentals
     * const rentals = await prisma.rentals.findMany()
     *
     * // Get first 10 Rentals
     * const rentals = await prisma.rentals.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const rentalsWithIdOnly = await prisma.rentals.findMany({ select: { id: true } })
     *
     */
    findMany<T extends rentalsFindManyArgs>(
      args?: SelectSubset<T, rentalsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Rentals.
     * @param {rentalsCreateArgs} args - Arguments to create a Rentals.
     * @example
     * // Create one Rentals
     * const Rentals = await prisma.rentals.create({
     *   data: {
     *     // ... data to create a Rentals
     *   }
     * })
     *
     */
    create<T extends rentalsCreateArgs>(
      args: SelectSubset<T, rentalsCreateArgs<ExtArgs>>,
    ): Prisma__rentalsClient<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Rentals.
     * @param {rentalsCreateManyArgs} args - Arguments to create many Rentals.
     * @example
     * // Create many Rentals
     * const rentals = await prisma.rentals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends rentalsCreateManyArgs>(
      args?: SelectSubset<T, rentalsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Rentals and returns the data saved in the database.
     * @param {rentalsCreateManyAndReturnArgs} args - Arguments to create many Rentals.
     * @example
     * // Create many Rentals
     * const rentals = await prisma.rentals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Rentals and only return the `id`
     * const rentalsWithIdOnly = await prisma.rentals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends rentalsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, rentalsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Rentals.
     * @param {rentalsDeleteArgs} args - Arguments to delete one Rentals.
     * @example
     * // Delete one Rentals
     * const Rentals = await prisma.rentals.delete({
     *   where: {
     *     // ... filter to delete one Rentals
     *   }
     * })
     *
     */
    delete<T extends rentalsDeleteArgs>(
      args: SelectSubset<T, rentalsDeleteArgs<ExtArgs>>,
    ): Prisma__rentalsClient<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Rentals.
     * @param {rentalsUpdateArgs} args - Arguments to update one Rentals.
     * @example
     * // Update one Rentals
     * const rentals = await prisma.rentals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends rentalsUpdateArgs>(
      args: SelectSubset<T, rentalsUpdateArgs<ExtArgs>>,
    ): Prisma__rentalsClient<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Rentals.
     * @param {rentalsDeleteManyArgs} args - Arguments to filter Rentals to delete.
     * @example
     * // Delete a few Rentals
     * const { count } = await prisma.rentals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends rentalsDeleteManyArgs>(
      args?: SelectSubset<T, rentalsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Rentals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rentalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rentals
     * const rentals = await prisma.rentals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends rentalsUpdateManyArgs>(
      args: SelectSubset<T, rentalsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Rentals and returns the data updated in the database.
     * @param {rentalsUpdateManyAndReturnArgs} args - Arguments to update many Rentals.
     * @example
     * // Update many Rentals
     * const rentals = await prisma.rentals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Rentals and only return the `id`
     * const rentalsWithIdOnly = await prisma.rentals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends rentalsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, rentalsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Rentals.
     * @param {rentalsUpsertArgs} args - Arguments to update or create a Rentals.
     * @example
     * // Update or create a Rentals
     * const rentals = await prisma.rentals.upsert({
     *   create: {
     *     // ... data to create a Rentals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rentals we want to update
     *   }
     * })
     */
    upsert<T extends rentalsUpsertArgs>(
      args: SelectSubset<T, rentalsUpsertArgs<ExtArgs>>,
    ): Prisma__rentalsClient<
      $Result.GetResult<Prisma.$rentalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Rentals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rentalsCountArgs} args - Arguments to filter Rentals to count.
     * @example
     * // Count the number of Rentals
     * const count = await prisma.rentals.count({
     *   where: {
     *     // ... the filter for the Rentals we want to count
     *   }
     * })
     **/
    count<T extends rentalsCountArgs>(
      args?: Subset<T, rentalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], RentalsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Rentals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RentalsAggregateArgs>(
      args: Subset<T, RentalsAggregateArgs>,
    ): Prisma.PrismaPromise<GetRentalsAggregateType<T>>;

    /**
     * Group by Rentals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rentalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends rentalsGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rentalsGroupByArgs["orderBy"] }
        : { orderBy?: rentalsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, rentalsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetRentalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the rentals model
     */
    readonly fields: rentalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rentals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rentalsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    payment_collections<T extends rentals$payment_collectionsArgs<ExtArgs> = {}>(
      args?: Subset<T, rentals$payment_collectionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$payment_collectionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null
    >;
    user<T extends rentals$userArgs<ExtArgs> = {}>(
      args?: Subset<T, rentals$userArgs<ExtArgs>>,
    ): Prisma__customersClient<
      $Result.GetResult<Prisma.$customersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    payment_mode<T extends rentals$payment_modeArgs<ExtArgs> = {}>(
      args?: Subset<T, rentals$payment_modeArgs<ExtArgs>>,
    ): Prisma__payment_modesClient<
      $Result.GetResult<Prisma.$payment_modesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the rentals model
   */
  interface rentalsFieldRefs {
    readonly id: FieldRef<"rentals", "String">;
    readonly user_id: FieldRef<"rentals", "String">;
    readonly payment_mode_id: FieldRef<"rentals", "String">;
    readonly invoice_id: FieldRef<"rentals", "String">;
    readonly invoice_date: FieldRef<"rentals", "DateTime">;
    readonly invoice_status: FieldRef<"rentals", "InvoiceStatus">;
    readonly rental_period: FieldRef<"rentals", "Period">;
    readonly discount_amount: FieldRef<"rentals", "Float">;
    readonly pending_amount: FieldRef<"rentals", "Float">;
    readonly advance_amount: FieldRef<"rentals", "Float">;
    readonly deposit_amount: FieldRef<"rentals", "Float">;
    readonly paid_amount: FieldRef<"rentals", "Float">;
    readonly total_amount: FieldRef<"rentals", "Float">;
    readonly fine_amount: FieldRef<"rentals", "Float">;
    readonly rental_products: FieldRef<"rentals", "Json[]">;
    readonly active_flag: FieldRef<"rentals", "Boolean">;
    readonly delete_flag: FieldRef<"rentals", "Boolean">;
    readonly created_by: FieldRef<"rentals", "String">;
    readonly created_at: FieldRef<"rentals", "DateTime">;
    readonly modified_at: FieldRef<"rentals", "DateTime">;
    readonly modified_by: FieldRef<"rentals", "String">;
  }

  // Custom InputTypes
  /**
   * rentals findUnique
   */
  export type rentalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
    /**
     * Filter, which rentals to fetch.
     */
    where: rentalsWhereUniqueInput;
  };

  /**
   * rentals findUniqueOrThrow
   */
  export type rentalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
    /**
     * Filter, which rentals to fetch.
     */
    where: rentalsWhereUniqueInput;
  };

  /**
   * rentals findFirst
   */
  export type rentalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
    /**
     * Filter, which rentals to fetch.
     */
    where?: rentalsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of rentals to fetch.
     */
    orderBy?: rentalsOrderByWithRelationInput | rentalsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for rentals.
     */
    cursor?: rentalsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` rentals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` rentals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of rentals.
     */
    distinct?: RentalsScalarFieldEnum | RentalsScalarFieldEnum[];
  };

  /**
   * rentals findFirstOrThrow
   */
  export type rentalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
    /**
     * Filter, which rentals to fetch.
     */
    where?: rentalsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of rentals to fetch.
     */
    orderBy?: rentalsOrderByWithRelationInput | rentalsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for rentals.
     */
    cursor?: rentalsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` rentals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` rentals.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of rentals.
     */
    distinct?: RentalsScalarFieldEnum | RentalsScalarFieldEnum[];
  };

  /**
   * rentals findMany
   */
  export type rentalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
    /**
     * Filter, which rentals to fetch.
     */
    where?: rentalsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of rentals to fetch.
     */
    orderBy?: rentalsOrderByWithRelationInput | rentalsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing rentals.
     */
    cursor?: rentalsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` rentals from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` rentals.
     */
    skip?: number;
    distinct?: RentalsScalarFieldEnum | RentalsScalarFieldEnum[];
  };

  /**
   * rentals create
   */
  export type rentalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
    /**
     * The data needed to create a rentals.
     */
    data: XOR<rentalsCreateInput, rentalsUncheckedCreateInput>;
  };

  /**
   * rentals createMany
   */
  export type rentalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rentals.
     */
    data: rentalsCreateManyInput | rentalsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * rentals createManyAndReturn
   */
  export type rentalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * The data used to create many rentals.
     */
    data: rentalsCreateManyInput | rentalsCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * rentals update
   */
  export type rentalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
    /**
     * The data needed to update a rentals.
     */
    data: XOR<rentalsUpdateInput, rentalsUncheckedUpdateInput>;
    /**
     * Choose, which rentals to update.
     */
    where: rentalsWhereUniqueInput;
  };

  /**
   * rentals updateMany
   */
  export type rentalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rentals.
     */
    data: XOR<rentalsUpdateManyMutationInput, rentalsUncheckedUpdateManyInput>;
    /**
     * Filter which rentals to update
     */
    where?: rentalsWhereInput;
    /**
     * Limit how many rentals to update.
     */
    limit?: number;
  };

  /**
   * rentals updateManyAndReturn
   */
  export type rentalsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * The data used to update rentals.
     */
    data: XOR<rentalsUpdateManyMutationInput, rentalsUncheckedUpdateManyInput>;
    /**
     * Filter which rentals to update
     */
    where?: rentalsWhereInput;
    /**
     * Limit how many rentals to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * rentals upsert
   */
  export type rentalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
    /**
     * The filter to search for the rentals to update in case it exists.
     */
    where: rentalsWhereUniqueInput;
    /**
     * In case the rentals found by the `where` argument doesn't exist, create a new rentals with this data.
     */
    create: XOR<rentalsCreateInput, rentalsUncheckedCreateInput>;
    /**
     * In case the rentals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rentalsUpdateInput, rentalsUncheckedUpdateInput>;
  };

  /**
   * rentals delete
   */
  export type rentalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
    /**
     * Filter which rentals to delete.
     */
    where: rentalsWhereUniqueInput;
  };

  /**
   * rentals deleteMany
   */
  export type rentalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rentals to delete
     */
    where?: rentalsWhereInput;
    /**
     * Limit how many rentals to delete.
     */
    limit?: number;
  };

  /**
   * rentals.payment_collections
   */
  export type rentals$payment_collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_collections
     */
    select?: payment_collectionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_collections
     */
    omit?: payment_collectionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_collectionsInclude<ExtArgs> | null;
    where?: payment_collectionsWhereInput;
    orderBy?: payment_collectionsOrderByWithRelationInput | payment_collectionsOrderByWithRelationInput[];
    cursor?: payment_collectionsWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: Payment_collectionsScalarFieldEnum | Payment_collectionsScalarFieldEnum[];
  };

  /**
   * rentals.user
   */
  export type rentals$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customers
     */
    select?: customersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the customers
     */
    omit?: customersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customersInclude<ExtArgs> | null;
    where?: customersWhereInput;
  };

  /**
   * rentals.payment_mode
   */
  export type rentals$payment_modeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_modes
     */
    select?: payment_modesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the payment_modes
     */
    omit?: payment_modesOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payment_modesInclude<ExtArgs> | null;
    where?: payment_modesWhereInput;
  };

  /**
   * rentals without action
   */
  export type rentalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rentals
     */
    select?: rentalsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the rentals
     */
    omit?: rentalsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rentalsInclude<ExtArgs> | null;
  };

  /**
   * Model settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null;
    _min: SettingsMinAggregateOutputType | null;
    _max: SettingsMaxAggregateOutputType | null;
  };

  export type SettingsMinAggregateOutputType = {
    id: string | null;
    is_sms_otp_mode_live: boolean | null;
    is_email_otp_mode_live: boolean | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type SettingsMaxAggregateOutputType = {
    id: string | null;
    is_sms_otp_mode_live: boolean | null;
    is_email_otp_mode_live: boolean | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type SettingsCountAggregateOutputType = {
    id: number;
    is_sms_otp_mode_live: number;
    is_email_otp_mode_live: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type SettingsMinAggregateInputType = {
    id?: true;
    is_sms_otp_mode_live?: true;
    is_email_otp_mode_live?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type SettingsMaxAggregateInputType = {
    id?: true;
    is_sms_otp_mode_live?: true;
    is_email_otp_mode_live?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type SettingsCountAggregateInputType = {
    id?: true;
    is_sms_otp_mode_live?: true;
    is_email_otp_mode_live?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to aggregate.
     */
    where?: settingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: settingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` settings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` settings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned settings
     **/
    _count?: true | SettingsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SettingsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SettingsMaxAggregateInputType;
  };

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
    [P in keyof T & keyof AggregateSettings]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>;
  };

  export type settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: settingsWhereInput;
    orderBy?: settingsOrderByWithAggregationInput | settingsOrderByWithAggregationInput[];
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum;
    having?: settingsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SettingsCountAggregateInputType | true;
    _min?: SettingsMinAggregateInputType;
    _max?: SettingsMaxAggregateInputType;
  };

  export type SettingsGroupByOutputType = {
    id: string;
    is_sms_otp_mode_live: boolean;
    is_email_otp_mode_live: boolean;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: SettingsCountAggregateOutputType | null;
    _min: SettingsMinAggregateOutputType | null;
    _max: SettingsMaxAggregateOutputType | null;
  };

  type GetSettingsGroupByPayload<T extends settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof SettingsGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
          : GetScalarType<T[P], SettingsGroupByOutputType[P]>;
      }
    >
  >;

  export type settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        is_sms_otp_mode_live?: boolean;
        is_email_otp_mode_live?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["settings"]
    >;

  export type settingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        is_sms_otp_mode_live?: boolean;
        is_email_otp_mode_live?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["settings"]
    >;

  export type settingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        is_sms_otp_mode_live?: boolean;
        is_email_otp_mode_live?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["settings"]
    >;

  export type settingsSelectScalar = {
    id?: boolean;
    is_sms_otp_mode_live?: boolean;
    is_email_otp_mode_live?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "is_sms_otp_mode_live"
    | "is_email_otp_mode_live"
    | "active_flag"
    | "delete_flag"
    | "modified_at"
    | "created_at"
    | "created_by"
    | "modified_by",
    ExtArgs["result"]["settings"]
  >;

  export type $settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "settings";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        is_sms_otp_mode_live: boolean;
        is_email_otp_mode_live: boolean;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["settings"]
    >;
    composites: {};
  };

  type settingsGetPayload<S extends boolean | null | undefined | settingsDefaultArgs> = $Result.GetResult<
    Prisma.$settingsPayload,
    S
  >;

  type settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    settingsFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: SettingsCountAggregateInputType | true;
  };

  export interface settingsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["settings"]; meta: { name: "settings" } };
    /**
     * Find zero or one Settings that matches the filter.
     * @param {settingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends settingsFindUniqueArgs>(
      args: SelectSubset<T, settingsFindUniqueArgs<ExtArgs>>,
    ): Prisma__settingsClient<
      $Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {settingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends settingsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, settingsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__settingsClient<
      $Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends settingsFindFirstArgs>(
      args?: SelectSubset<T, settingsFindFirstArgs<ExtArgs>>,
    ): Prisma__settingsClient<
      $Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends settingsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, settingsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__settingsClient<
      $Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     *
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     *
     */
    findMany<T extends settingsFindManyArgs>(
      args?: SelectSubset<T, settingsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Settings.
     * @param {settingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     *
     */
    create<T extends settingsCreateArgs>(
      args: SelectSubset<T, settingsCreateArgs<ExtArgs>>,
    ): Prisma__settingsClient<
      $Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Settings.
     * @param {settingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends settingsCreateManyArgs>(
      args?: SelectSubset<T, settingsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {settingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends settingsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, settingsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Settings.
     * @param {settingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     *
     */
    delete<T extends settingsDeleteArgs>(
      args: SelectSubset<T, settingsDeleteArgs<ExtArgs>>,
    ): Prisma__settingsClient<
      $Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Settings.
     * @param {settingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends settingsUpdateArgs>(
      args: SelectSubset<T, settingsUpdateArgs<ExtArgs>>,
    ): Prisma__settingsClient<
      $Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Settings.
     * @param {settingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends settingsDeleteManyArgs>(
      args?: SelectSubset<T, settingsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends settingsUpdateManyArgs>(
      args: SelectSubset<T, settingsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {settingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends settingsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, settingsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Settings.
     * @param {settingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends settingsUpsertArgs>(
      args: SelectSubset<T, settingsUpsertArgs<ExtArgs>>,
    ): Prisma__settingsClient<
      $Result.GetResult<Prisma.$settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
     **/
    count<T extends settingsCountArgs>(
      args?: Subset<T, settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SettingsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SettingsAggregateArgs>(
      args: Subset<T, SettingsAggregateArgs>,
    ): Prisma.PrismaPromise<GetSettingsAggregateType<T>>;

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends settingsGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: settingsGroupByArgs["orderBy"] }
        : { orderBy?: settingsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, settingsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the settings model
     */
    readonly fields: settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__settingsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the settings model
   */
  interface settingsFieldRefs {
    readonly id: FieldRef<"settings", "String">;
    readonly is_sms_otp_mode_live: FieldRef<"settings", "Boolean">;
    readonly is_email_otp_mode_live: FieldRef<"settings", "Boolean">;
    readonly active_flag: FieldRef<"settings", "Boolean">;
    readonly delete_flag: FieldRef<"settings", "Boolean">;
    readonly modified_at: FieldRef<"settings", "DateTime">;
    readonly created_at: FieldRef<"settings", "DateTime">;
    readonly created_by: FieldRef<"settings", "String">;
    readonly modified_by: FieldRef<"settings", "String">;
  }

  // Custom InputTypes
  /**
   * settings findUnique
   */
  export type settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null;
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput;
  };

  /**
   * settings findUniqueOrThrow
   */
  export type settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null;
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput;
  };

  /**
   * settings findFirst
   */
  export type settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null;
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` settings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` settings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[];
  };

  /**
   * settings findFirstOrThrow
   */
  export type settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null;
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` settings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` settings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[];
  };

  /**
   * settings findMany
   */
  export type settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null;
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of settings to fetch.
     */
    orderBy?: settingsOrderByWithRelationInput | settingsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing settings.
     */
    cursor?: settingsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` settings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` settings.
     */
    skip?: number;
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[];
  };

  /**
   * settings create
   */
  export type settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null;
    /**
     * The data needed to create a settings.
     */
    data: XOR<settingsCreateInput, settingsUncheckedCreateInput>;
  };

  /**
   * settings createMany
   */
  export type settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many settings.
     */
    data: settingsCreateManyInput | settingsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * settings createManyAndReturn
   */
  export type settingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null;
    /**
     * The data used to create many settings.
     */
    data: settingsCreateManyInput | settingsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * settings update
   */
  export type settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null;
    /**
     * The data needed to update a settings.
     */
    data: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>;
    /**
     * Choose, which settings to update.
     */
    where: settingsWhereUniqueInput;
  };

  /**
   * settings updateMany
   */
  export type settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update settings.
     */
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>;
    /**
     * Filter which settings to update
     */
    where?: settingsWhereInput;
    /**
     * Limit how many settings to update.
     */
    limit?: number;
  };

  /**
   * settings updateManyAndReturn
   */
  export type settingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null;
    /**
     * The data used to update settings.
     */
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>;
    /**
     * Filter which settings to update
     */
    where?: settingsWhereInput;
    /**
     * Limit how many settings to update.
     */
    limit?: number;
  };

  /**
   * settings upsert
   */
  export type settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null;
    /**
     * The filter to search for the settings to update in case it exists.
     */
    where: settingsWhereUniqueInput;
    /**
     * In case the settings found by the `where` argument doesn't exist, create a new settings with this data.
     */
    create: XOR<settingsCreateInput, settingsUncheckedCreateInput>;
    /**
     * In case the settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>;
  };

  /**
   * settings delete
   */
  export type settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null;
    /**
     * Filter which settings to delete.
     */
    where: settingsWhereUniqueInput;
  };

  /**
   * settings deleteMany
   */
  export type settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which settings to delete
     */
    where?: settingsWhereInput;
    /**
     * Limit how many settings to delete.
     */
    limit?: number;
  };

  /**
   * settings without action
   */
  export type settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the settings
     */
    omit?: settingsOmit<ExtArgs> | null;
  };

  /**
   * Model subscriptions
   */

  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null;
    _avg: SubscriptionsAvgAggregateOutputType | null;
    _sum: SubscriptionsSumAggregateOutputType | null;
    _min: SubscriptionsMinAggregateOutputType | null;
    _max: SubscriptionsMaxAggregateOutputType | null;
  };

  export type SubscriptionsAvgAggregateOutputType = {
    price: number | null;
  };

  export type SubscriptionsSumAggregateOutputType = {
    price: number | null;
  };

  export type SubscriptionsMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    price: number | null;
    validity: string | null;
    description: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type SubscriptionsMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    price: number | null;
    validity: string | null;
    description: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type SubscriptionsCountAggregateOutputType = {
    id: number;
    name: number;
    price: number;
    validity: number;
    description: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type SubscriptionsAvgAggregateInputType = {
    price?: true;
  };

  export type SubscriptionsSumAggregateInputType = {
    price?: true;
  };

  export type SubscriptionsMinAggregateInputType = {
    id?: true;
    name?: true;
    price?: true;
    validity?: true;
    description?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type SubscriptionsMaxAggregateInputType = {
    id?: true;
    name?: true;
    price?: true;
    validity?: true;
    description?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type SubscriptionsCountAggregateInputType = {
    id?: true;
    name?: true;
    price?: true;
    validity?: true;
    description?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type SubscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to aggregate.
     */
    where?: subscriptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: subscriptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned subscriptions
     **/
    _count?: true | SubscriptionsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: SubscriptionsAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: SubscriptionsSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SubscriptionsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SubscriptionsMaxAggregateInputType;
  };

  export type GetSubscriptionsAggregateType<T extends SubscriptionsAggregateArgs> = {
    [P in keyof T & keyof AggregateSubscriptions]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>;
  };

  export type subscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionsWhereInput;
    orderBy?: subscriptionsOrderByWithAggregationInput | subscriptionsOrderByWithAggregationInput[];
    by: SubscriptionsScalarFieldEnum[] | SubscriptionsScalarFieldEnum;
    having?: subscriptionsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SubscriptionsCountAggregateInputType | true;
    _avg?: SubscriptionsAvgAggregateInputType;
    _sum?: SubscriptionsSumAggregateInputType;
    _min?: SubscriptionsMinAggregateInputType;
    _max?: SubscriptionsMaxAggregateInputType;
  };

  export type SubscriptionsGroupByOutputType = {
    id: string;
    name: string;
    price: number;
    validity: string | null;
    description: string | null;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: SubscriptionsCountAggregateOutputType | null;
    _avg: SubscriptionsAvgAggregateOutputType | null;
    _sum: SubscriptionsSumAggregateOutputType | null;
    _min: SubscriptionsMinAggregateOutputType | null;
    _max: SubscriptionsMaxAggregateOutputType | null;
  };

  type GetSubscriptionsGroupByPayload<T extends subscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionsGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof SubscriptionsGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
          : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>;
      }
    >
  >;

  export type subscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        price?: boolean;
        validity?: boolean;
        description?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["subscriptions"]
    >;

  export type subscriptionsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      price?: boolean;
      validity?: boolean;
      description?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      modified_at?: boolean;
      created_at?: boolean;
      created_by?: boolean;
      modified_by?: boolean;
    },
    ExtArgs["result"]["subscriptions"]
  >;

  export type subscriptionsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      price?: boolean;
      validity?: boolean;
      description?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      modified_at?: boolean;
      created_at?: boolean;
      created_by?: boolean;
      modified_by?: boolean;
    },
    ExtArgs["result"]["subscriptions"]
  >;

  export type subscriptionsSelectScalar = {
    id?: boolean;
    name?: boolean;
    price?: boolean;
    validity?: boolean;
    description?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type subscriptionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "name"
      | "price"
      | "validity"
      | "description"
      | "active_flag"
      | "delete_flag"
      | "modified_at"
      | "created_at"
      | "created_by"
      | "modified_by",
      ExtArgs["result"]["subscriptions"]
    >;

  export type $subscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subscriptions";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        price: number;
        validity: string | null;
        description: string | null;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["subscriptions"]
    >;
    composites: {};
  };

  type subscriptionsGetPayload<S extends boolean | null | undefined | subscriptionsDefaultArgs> = $Result.GetResult<
    Prisma.$subscriptionsPayload,
    S
  >;

  type subscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    subscriptionsFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: SubscriptionsCountAggregateInputType | true;
  };

  export interface subscriptionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["subscriptions"]; meta: { name: "subscriptions" } };
    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {subscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscriptionsFindUniqueArgs>(
      args: SelectSubset<T, subscriptionsFindUniqueArgs<ExtArgs>>,
    ): Prisma__subscriptionsClient<
      $Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Subscriptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscriptionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, subscriptionsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__subscriptionsClient<
      $Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscriptionsFindFirstArgs>(
      args?: SelectSubset<T, subscriptionsFindFirstArgs<ExtArgs>>,
    ): Prisma__subscriptionsClient<
      $Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscriptionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subscriptionsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__subscriptionsClient<
      $Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     *
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.findMany({ select: { id: true } })
     *
     */
    findMany<T extends subscriptionsFindManyArgs>(
      args?: SelectSubset<T, subscriptionsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Subscriptions.
     * @param {subscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     *
     */
    create<T extends subscriptionsCreateArgs>(
      args: SelectSubset<T, subscriptionsCreateArgs<ExtArgs>>,
    ): Prisma__subscriptionsClient<
      $Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Subscriptions.
     * @param {subscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends subscriptionsCreateManyArgs>(
      args?: SelectSubset<T, subscriptionsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {subscriptionsCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Subscriptions and only return the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends subscriptionsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, subscriptionsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Subscriptions.
     * @param {subscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     *
     */
    delete<T extends subscriptionsDeleteArgs>(
      args: SelectSubset<T, subscriptionsDeleteArgs<ExtArgs>>,
    ): Prisma__subscriptionsClient<
      $Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Subscriptions.
     * @param {subscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends subscriptionsUpdateArgs>(
      args: SelectSubset<T, subscriptionsUpdateArgs<ExtArgs>>,
    ): Prisma__subscriptionsClient<
      $Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends subscriptionsDeleteManyArgs>(
      args?: SelectSubset<T, subscriptionsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends subscriptionsUpdateManyArgs>(
      args: SelectSubset<T, subscriptionsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {subscriptionsUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends subscriptionsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, subscriptionsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Subscriptions.
     * @param {subscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends subscriptionsUpsertArgs>(
      args: SelectSubset<T, subscriptionsUpsertArgs<ExtArgs>>,
    ): Prisma__subscriptionsClient<
      $Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
     **/
    count<T extends subscriptionsCountArgs>(
      args?: Subset<T, subscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SubscriptionsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SubscriptionsAggregateArgs>(
      args: Subset<T, SubscriptionsAggregateArgs>,
    ): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>;

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends subscriptionsGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionsGroupByArgs["orderBy"] }
        : { orderBy?: subscriptionsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, subscriptionsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetSubscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the subscriptions model
     */
    readonly fields: subscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the subscriptions model
   */
  interface subscriptionsFieldRefs {
    readonly id: FieldRef<"subscriptions", "String">;
    readonly name: FieldRef<"subscriptions", "String">;
    readonly price: FieldRef<"subscriptions", "Float">;
    readonly validity: FieldRef<"subscriptions", "String">;
    readonly description: FieldRef<"subscriptions", "String">;
    readonly active_flag: FieldRef<"subscriptions", "Boolean">;
    readonly delete_flag: FieldRef<"subscriptions", "Boolean">;
    readonly modified_at: FieldRef<"subscriptions", "DateTime">;
    readonly created_at: FieldRef<"subscriptions", "DateTime">;
    readonly created_by: FieldRef<"subscriptions", "String">;
    readonly modified_by: FieldRef<"subscriptions", "String">;
  }

  // Custom InputTypes
  /**
   * subscriptions findUnique
   */
  export type subscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput;
  };

  /**
   * subscriptions findUniqueOrThrow
   */
  export type subscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput;
  };

  /**
   * subscriptions findFirst
   */
  export type subscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[];
  };

  /**
   * subscriptions findFirstOrThrow
   */
  export type subscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` subscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[];
  };

  /**
   * subscriptions findMany
   */
  export type subscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` subscriptions.
     */
    skip?: number;
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[];
  };

  /**
   * subscriptions create
   */
  export type subscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * The data needed to create a subscriptions.
     */
    data: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>;
  };

  /**
   * subscriptions createMany
   */
  export type subscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * subscriptions createManyAndReturn
   */
  export type subscriptionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the subscriptions
       */
      select?: subscriptionsSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the subscriptions
       */
      omit?: subscriptionsOmit<ExtArgs> | null;
      /**
       * The data used to create many subscriptions.
       */
      data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[];
      skipDuplicates?: boolean;
    };

  /**
   * subscriptions update
   */
  export type subscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * The data needed to update a subscriptions.
     */
    data: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>;
    /**
     * Choose, which subscriptions to update.
     */
    where: subscriptionsWhereUniqueInput;
  };

  /**
   * subscriptions updateMany
   */
  export type subscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionsUpdateManyMutationInput, subscriptionsUncheckedUpdateManyInput>;
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionsWhereInput;
    /**
     * Limit how many subscriptions to update.
     */
    limit?: number;
  };

  /**
   * subscriptions updateManyAndReturn
   */
  export type subscriptionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the subscriptions
       */
      select?: subscriptionsSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the subscriptions
       */
      omit?: subscriptionsOmit<ExtArgs> | null;
      /**
       * The data used to update subscriptions.
       */
      data: XOR<subscriptionsUpdateManyMutationInput, subscriptionsUncheckedUpdateManyInput>;
      /**
       * Filter which subscriptions to update
       */
      where?: subscriptionsWhereInput;
      /**
       * Limit how many subscriptions to update.
       */
      limit?: number;
    };

  /**
   * subscriptions upsert
   */
  export type subscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * The filter to search for the subscriptions to update in case it exists.
     */
    where: subscriptionsWhereUniqueInput;
    /**
     * In case the subscriptions found by the `where` argument doesn't exist, create a new subscriptions with this data.
     */
    create: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>;
    /**
     * In case the subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>;
  };

  /**
   * subscriptions delete
   */
  export type subscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
    /**
     * Filter which subscriptions to delete.
     */
    where: subscriptionsWhereUniqueInput;
  };

  /**
   * subscriptions deleteMany
   */
  export type subscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionsWhereInput;
    /**
     * Limit how many subscriptions to delete.
     */
    limit?: number;
  };

  /**
   * subscriptions without action
   */
  export type subscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null;
  };

  /**
   * Model templates
   */

  export type AggregateTemplates = {
    _count: TemplatesCountAggregateOutputType | null;
    _avg: TemplatesAvgAggregateOutputType | null;
    _sum: TemplatesSumAggregateOutputType | null;
    _min: TemplatesMinAggregateOutputType | null;
    _max: TemplatesMaxAggregateOutputType | null;
  };

  export type TemplatesAvgAggregateOutputType = {
    parameters: number | null;
  };

  export type TemplatesSumAggregateOutputType = {
    parameters: number | null;
  };

  export type TemplatesMinAggregateOutputType = {
    id: string | null;
    identifier: string | null;
    type: string | null;
    template_type: string | null;
    provider_name: string | null;
    name: string | null;
    subject: string | null;
    description: string | null;
    provider_template_code: string | null;
    template: string | null;
    instruction: string | null;
    parameters: number | null;
    is_html: boolean | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type TemplatesMaxAggregateOutputType = {
    id: string | null;
    identifier: string | null;
    type: string | null;
    template_type: string | null;
    provider_name: string | null;
    name: string | null;
    subject: string | null;
    description: string | null;
    provider_template_code: string | null;
    template: string | null;
    instruction: string | null;
    parameters: number | null;
    is_html: boolean | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type TemplatesCountAggregateOutputType = {
    id: number;
    identifier: number;
    type: number;
    template_type: number;
    provider_name: number;
    name: number;
    subject: number;
    description: number;
    provider_template_code: number;
    template: number;
    instruction: number;
    parameters: number;
    is_html: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type TemplatesAvgAggregateInputType = {
    parameters?: true;
  };

  export type TemplatesSumAggregateInputType = {
    parameters?: true;
  };

  export type TemplatesMinAggregateInputType = {
    id?: true;
    identifier?: true;
    type?: true;
    template_type?: true;
    provider_name?: true;
    name?: true;
    subject?: true;
    description?: true;
    provider_template_code?: true;
    template?: true;
    instruction?: true;
    parameters?: true;
    is_html?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type TemplatesMaxAggregateInputType = {
    id?: true;
    identifier?: true;
    type?: true;
    template_type?: true;
    provider_name?: true;
    name?: true;
    subject?: true;
    description?: true;
    provider_template_code?: true;
    template?: true;
    instruction?: true;
    parameters?: true;
    is_html?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type TemplatesCountAggregateInputType = {
    id?: true;
    identifier?: true;
    type?: true;
    template_type?: true;
    provider_name?: true;
    name?: true;
    subject?: true;
    description?: true;
    provider_template_code?: true;
    template?: true;
    instruction?: true;
    parameters?: true;
    is_html?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type TemplatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which templates to aggregate.
     */
    where?: templatesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of templates to fetch.
     */
    orderBy?: templatesOrderByWithRelationInput | templatesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: templatesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` templates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` templates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned templates
     **/
    _count?: true | TemplatesCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: TemplatesAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: TemplatesSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: TemplatesMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: TemplatesMaxAggregateInputType;
  };

  export type GetTemplatesAggregateType<T extends TemplatesAggregateArgs> = {
    [P in keyof T & keyof AggregateTemplates]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplates[P]>
      : GetScalarType<T[P], AggregateTemplates[P]>;
  };

  export type templatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: templatesWhereInput;
    orderBy?: templatesOrderByWithAggregationInput | templatesOrderByWithAggregationInput[];
    by: TemplatesScalarFieldEnum[] | TemplatesScalarFieldEnum;
    having?: templatesScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: TemplatesCountAggregateInputType | true;
    _avg?: TemplatesAvgAggregateInputType;
    _sum?: TemplatesSumAggregateInputType;
    _min?: TemplatesMinAggregateInputType;
    _max?: TemplatesMaxAggregateInputType;
  };

  export type TemplatesGroupByOutputType = {
    id: string;
    identifier: string;
    type: string | null;
    template_type: string | null;
    provider_name: string | null;
    name: string | null;
    subject: string | null;
    description: string | null;
    provider_template_code: string | null;
    template: string | null;
    instruction: string | null;
    parameters: number | null;
    is_html: boolean;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: TemplatesCountAggregateOutputType | null;
    _avg: TemplatesAvgAggregateOutputType | null;
    _sum: TemplatesSumAggregateOutputType | null;
    _min: TemplatesMinAggregateOutputType | null;
    _max: TemplatesMaxAggregateOutputType | null;
  };

  type GetTemplatesGroupByPayload<T extends templatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplatesGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof TemplatesGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], TemplatesGroupByOutputType[P]>
          : GetScalarType<T[P], TemplatesGroupByOutputType[P]>;
      }
    >
  >;

  export type templatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        identifier?: boolean;
        type?: boolean;
        template_type?: boolean;
        provider_name?: boolean;
        name?: boolean;
        subject?: boolean;
        description?: boolean;
        provider_template_code?: boolean;
        template?: boolean;
        instruction?: boolean;
        parameters?: boolean;
        is_html?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["templates"]
    >;

  export type templatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        identifier?: boolean;
        type?: boolean;
        template_type?: boolean;
        provider_name?: boolean;
        name?: boolean;
        subject?: boolean;
        description?: boolean;
        provider_template_code?: boolean;
        template?: boolean;
        instruction?: boolean;
        parameters?: boolean;
        is_html?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["templates"]
    >;

  export type templatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        identifier?: boolean;
        type?: boolean;
        template_type?: boolean;
        provider_name?: boolean;
        name?: boolean;
        subject?: boolean;
        description?: boolean;
        provider_template_code?: boolean;
        template?: boolean;
        instruction?: boolean;
        parameters?: boolean;
        is_html?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
      },
      ExtArgs["result"]["templates"]
    >;

  export type templatesSelectScalar = {
    id?: boolean;
    identifier?: boolean;
    type?: boolean;
    template_type?: boolean;
    provider_name?: boolean;
    name?: boolean;
    subject?: boolean;
    description?: boolean;
    provider_template_code?: boolean;
    template?: boolean;
    instruction?: boolean;
    parameters?: boolean;
    is_html?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type templatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<
    | "id"
    | "identifier"
    | "type"
    | "template_type"
    | "provider_name"
    | "name"
    | "subject"
    | "description"
    | "provider_template_code"
    | "template"
    | "instruction"
    | "parameters"
    | "is_html"
    | "active_flag"
    | "delete_flag"
    | "modified_at"
    | "created_at"
    | "created_by"
    | "modified_by",
    ExtArgs["result"]["templates"]
  >;

  export type $templatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "templates";
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        identifier: string;
        type: string | null;
        template_type: string | null;
        provider_name: string | null;
        name: string | null;
        subject: string | null;
        description: string | null;
        provider_template_code: string | null;
        template: string | null;
        instruction: string | null;
        parameters: number | null;
        is_html: boolean;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["templates"]
    >;
    composites: {};
  };

  type templatesGetPayload<S extends boolean | null | undefined | templatesDefaultArgs> = $Result.GetResult<
    Prisma.$templatesPayload,
    S
  >;

  type templatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    templatesFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: TemplatesCountAggregateInputType | true;
  };

  export interface templatesDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["templates"]; meta: { name: "templates" } };
    /**
     * Find zero or one Templates that matches the filter.
     * @param {templatesFindUniqueArgs} args - Arguments to find a Templates
     * @example
     * // Get one Templates
     * const templates = await prisma.templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends templatesFindUniqueArgs>(
      args: SelectSubset<T, templatesFindUniqueArgs<ExtArgs>>,
    ): Prisma__templatesClient<
      $Result.GetResult<Prisma.$templatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Templates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {templatesFindUniqueOrThrowArgs} args - Arguments to find a Templates
     * @example
     * // Get one Templates
     * const templates = await prisma.templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends templatesFindUniqueOrThrowArgs>(
      args: SelectSubset<T, templatesFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__templatesClient<
      $Result.GetResult<Prisma.$templatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {templatesFindFirstArgs} args - Arguments to find a Templates
     * @example
     * // Get one Templates
     * const templates = await prisma.templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends templatesFindFirstArgs>(
      args?: SelectSubset<T, templatesFindFirstArgs<ExtArgs>>,
    ): Prisma__templatesClient<
      $Result.GetResult<Prisma.$templatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Templates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {templatesFindFirstOrThrowArgs} args - Arguments to find a Templates
     * @example
     * // Get one Templates
     * const templates = await prisma.templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends templatesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, templatesFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__templatesClient<
      $Result.GetResult<Prisma.$templatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {templatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.templates.findMany()
     *
     * // Get first 10 Templates
     * const templates = await prisma.templates.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const templatesWithIdOnly = await prisma.templates.findMany({ select: { id: true } })
     *
     */
    findMany<T extends templatesFindManyArgs>(
      args?: SelectSubset<T, templatesFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$templatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>;

    /**
     * Create a Templates.
     * @param {templatesCreateArgs} args - Arguments to create a Templates.
     * @example
     * // Create one Templates
     * const Templates = await prisma.templates.create({
     *   data: {
     *     // ... data to create a Templates
     *   }
     * })
     *
     */
    create<T extends templatesCreateArgs>(
      args: SelectSubset<T, templatesCreateArgs<ExtArgs>>,
    ): Prisma__templatesClient<
      $Result.GetResult<Prisma.$templatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Templates.
     * @param {templatesCreateManyArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const templates = await prisma.templates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends templatesCreateManyArgs>(
      args?: SelectSubset<T, templatesCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Templates and returns the data saved in the database.
     * @param {templatesCreateManyAndReturnArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const templates = await prisma.templates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Templates and only return the `id`
     * const templatesWithIdOnly = await prisma.templates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends templatesCreateManyAndReturnArgs>(
      args?: SelectSubset<T, templatesCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$templatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Templates.
     * @param {templatesDeleteArgs} args - Arguments to delete one Templates.
     * @example
     * // Delete one Templates
     * const Templates = await prisma.templates.delete({
     *   where: {
     *     // ... filter to delete one Templates
     *   }
     * })
     *
     */
    delete<T extends templatesDeleteArgs>(
      args: SelectSubset<T, templatesDeleteArgs<ExtArgs>>,
    ): Prisma__templatesClient<
      $Result.GetResult<Prisma.$templatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Templates.
     * @param {templatesUpdateArgs} args - Arguments to update one Templates.
     * @example
     * // Update one Templates
     * const templates = await prisma.templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends templatesUpdateArgs>(
      args: SelectSubset<T, templatesUpdateArgs<ExtArgs>>,
    ): Prisma__templatesClient<
      $Result.GetResult<Prisma.$templatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Templates.
     * @param {templatesDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends templatesDeleteManyArgs>(
      args?: SelectSubset<T, templatesDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {templatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const templates = await prisma.templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends templatesUpdateManyArgs>(
      args: SelectSubset<T, templatesUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Templates and returns the data updated in the database.
     * @param {templatesUpdateManyAndReturnArgs} args - Arguments to update many Templates.
     * @example
     * // Update many Templates
     * const templates = await prisma.templates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Templates and only return the `id`
     * const templatesWithIdOnly = await prisma.templates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends templatesUpdateManyAndReturnArgs>(
      args: SelectSubset<T, templatesUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$templatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Templates.
     * @param {templatesUpsertArgs} args - Arguments to update or create a Templates.
     * @example
     * // Update or create a Templates
     * const templates = await prisma.templates.upsert({
     *   create: {
     *     // ... data to create a Templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Templates we want to update
     *   }
     * })
     */
    upsert<T extends templatesUpsertArgs>(
      args: SelectSubset<T, templatesUpsertArgs<ExtArgs>>,
    ): Prisma__templatesClient<
      $Result.GetResult<Prisma.$templatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {templatesCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.templates.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
     **/
    count<T extends templatesCountArgs>(
      args?: Subset<T, templatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], TemplatesCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends TemplatesAggregateArgs>(
      args: Subset<T, TemplatesAggregateArgs>,
    ): Prisma.PrismaPromise<GetTemplatesAggregateType<T>>;

    /**
     * Group by Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {templatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends templatesGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: templatesGroupByArgs["orderBy"] }
        : { orderBy?: templatesGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, templatesGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetTemplatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the templates model
     */
    readonly fields: templatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__templatesClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the templates model
   */
  interface templatesFieldRefs {
    readonly id: FieldRef<"templates", "String">;
    readonly identifier: FieldRef<"templates", "String">;
    readonly type: FieldRef<"templates", "String">;
    readonly template_type: FieldRef<"templates", "String">;
    readonly provider_name: FieldRef<"templates", "String">;
    readonly name: FieldRef<"templates", "String">;
    readonly subject: FieldRef<"templates", "String">;
    readonly description: FieldRef<"templates", "String">;
    readonly provider_template_code: FieldRef<"templates", "String">;
    readonly template: FieldRef<"templates", "String">;
    readonly instruction: FieldRef<"templates", "String">;
    readonly parameters: FieldRef<"templates", "Int">;
    readonly is_html: FieldRef<"templates", "Boolean">;
    readonly active_flag: FieldRef<"templates", "Boolean">;
    readonly delete_flag: FieldRef<"templates", "Boolean">;
    readonly modified_at: FieldRef<"templates", "DateTime">;
    readonly created_at: FieldRef<"templates", "DateTime">;
    readonly created_by: FieldRef<"templates", "String">;
    readonly modified_by: FieldRef<"templates", "String">;
  }

  // Custom InputTypes
  /**
   * templates findUnique
   */
  export type templatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the templates
     */
    select?: templatesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the templates
     */
    omit?: templatesOmit<ExtArgs> | null;
    /**
     * Filter, which templates to fetch.
     */
    where: templatesWhereUniqueInput;
  };

  /**
   * templates findUniqueOrThrow
   */
  export type templatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the templates
     */
    select?: templatesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the templates
     */
    omit?: templatesOmit<ExtArgs> | null;
    /**
     * Filter, which templates to fetch.
     */
    where: templatesWhereUniqueInput;
  };

  /**
   * templates findFirst
   */
  export type templatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the templates
     */
    select?: templatesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the templates
     */
    omit?: templatesOmit<ExtArgs> | null;
    /**
     * Filter, which templates to fetch.
     */
    where?: templatesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of templates to fetch.
     */
    orderBy?: templatesOrderByWithRelationInput | templatesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for templates.
     */
    cursor?: templatesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` templates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` templates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of templates.
     */
    distinct?: TemplatesScalarFieldEnum | TemplatesScalarFieldEnum[];
  };

  /**
   * templates findFirstOrThrow
   */
  export type templatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the templates
     */
    select?: templatesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the templates
     */
    omit?: templatesOmit<ExtArgs> | null;
    /**
     * Filter, which templates to fetch.
     */
    where?: templatesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of templates to fetch.
     */
    orderBy?: templatesOrderByWithRelationInput | templatesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for templates.
     */
    cursor?: templatesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` templates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` templates.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of templates.
     */
    distinct?: TemplatesScalarFieldEnum | TemplatesScalarFieldEnum[];
  };

  /**
   * templates findMany
   */
  export type templatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the templates
     */
    select?: templatesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the templates
     */
    omit?: templatesOmit<ExtArgs> | null;
    /**
     * Filter, which templates to fetch.
     */
    where?: templatesWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of templates to fetch.
     */
    orderBy?: templatesOrderByWithRelationInput | templatesOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing templates.
     */
    cursor?: templatesWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` templates from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` templates.
     */
    skip?: number;
    distinct?: TemplatesScalarFieldEnum | TemplatesScalarFieldEnum[];
  };

  /**
   * templates create
   */
  export type templatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the templates
     */
    select?: templatesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the templates
     */
    omit?: templatesOmit<ExtArgs> | null;
    /**
     * The data needed to create a templates.
     */
    data: XOR<templatesCreateInput, templatesUncheckedCreateInput>;
  };

  /**
   * templates createMany
   */
  export type templatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many templates.
     */
    data: templatesCreateManyInput | templatesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * templates createManyAndReturn
   */
  export type templatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the templates
     */
    select?: templatesSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the templates
     */
    omit?: templatesOmit<ExtArgs> | null;
    /**
     * The data used to create many templates.
     */
    data: templatesCreateManyInput | templatesCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * templates update
   */
  export type templatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the templates
     */
    select?: templatesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the templates
     */
    omit?: templatesOmit<ExtArgs> | null;
    /**
     * The data needed to update a templates.
     */
    data: XOR<templatesUpdateInput, templatesUncheckedUpdateInput>;
    /**
     * Choose, which templates to update.
     */
    where: templatesWhereUniqueInput;
  };

  /**
   * templates updateMany
   */
  export type templatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update templates.
     */
    data: XOR<templatesUpdateManyMutationInput, templatesUncheckedUpdateManyInput>;
    /**
     * Filter which templates to update
     */
    where?: templatesWhereInput;
    /**
     * Limit how many templates to update.
     */
    limit?: number;
  };

  /**
   * templates updateManyAndReturn
   */
  export type templatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the templates
     */
    select?: templatesSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the templates
     */
    omit?: templatesOmit<ExtArgs> | null;
    /**
     * The data used to update templates.
     */
    data: XOR<templatesUpdateManyMutationInput, templatesUncheckedUpdateManyInput>;
    /**
     * Filter which templates to update
     */
    where?: templatesWhereInput;
    /**
     * Limit how many templates to update.
     */
    limit?: number;
  };

  /**
   * templates upsert
   */
  export type templatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the templates
     */
    select?: templatesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the templates
     */
    omit?: templatesOmit<ExtArgs> | null;
    /**
     * The filter to search for the templates to update in case it exists.
     */
    where: templatesWhereUniqueInput;
    /**
     * In case the templates found by the `where` argument doesn't exist, create a new templates with this data.
     */
    create: XOR<templatesCreateInput, templatesUncheckedCreateInput>;
    /**
     * In case the templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<templatesUpdateInput, templatesUncheckedUpdateInput>;
  };

  /**
   * templates delete
   */
  export type templatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the templates
     */
    select?: templatesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the templates
     */
    omit?: templatesOmit<ExtArgs> | null;
    /**
     * Filter which templates to delete.
     */
    where: templatesWhereUniqueInput;
  };

  /**
   * templates deleteMany
   */
  export type templatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which templates to delete
     */
    where?: templatesWhereInput;
    /**
     * Limit how many templates to delete.
     */
    limit?: number;
  };

  /**
   * templates without action
   */
  export type templatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the templates
     */
    select?: templatesSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the templates
     */
    omit?: templatesOmit<ExtArgs> | null;
  };

  /**
   * Model terms_and_conditions
   */

  export type AggregateTerms_and_conditions = {
    _count: Terms_and_conditionsCountAggregateOutputType | null;
    _min: Terms_and_conditionsMinAggregateOutputType | null;
    _max: Terms_and_conditionsMaxAggregateOutputType | null;
  };

  export type Terms_and_conditionsMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    firm_id: string | null;
    description: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type Terms_and_conditionsMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    firm_id: string | null;
    description: string | null;
    active_flag: boolean | null;
    delete_flag: boolean | null;
    modified_at: Date | null;
    created_at: Date | null;
    created_by: string | null;
    modified_by: string | null;
  };

  export type Terms_and_conditionsCountAggregateOutputType = {
    id: number;
    name: number;
    firm_id: number;
    description: number;
    active_flag: number;
    delete_flag: number;
    modified_at: number;
    created_at: number;
    created_by: number;
    modified_by: number;
    _all: number;
  };

  export type Terms_and_conditionsMinAggregateInputType = {
    id?: true;
    name?: true;
    firm_id?: true;
    description?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type Terms_and_conditionsMaxAggregateInputType = {
    id?: true;
    name?: true;
    firm_id?: true;
    description?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
  };

  export type Terms_and_conditionsCountAggregateInputType = {
    id?: true;
    name?: true;
    firm_id?: true;
    description?: true;
    active_flag?: true;
    delete_flag?: true;
    modified_at?: true;
    created_at?: true;
    created_by?: true;
    modified_by?: true;
    _all?: true;
  };

  export type Terms_and_conditionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which terms_and_conditions to aggregate.
     */
    where?: terms_and_conditionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of terms_and_conditions to fetch.
     */
    orderBy?: terms_and_conditionsOrderByWithRelationInput | terms_and_conditionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: terms_and_conditionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` terms_and_conditions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` terms_and_conditions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned terms_and_conditions
     **/
    _count?: true | Terms_and_conditionsCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: Terms_and_conditionsMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: Terms_and_conditionsMaxAggregateInputType;
  };

  export type GetTerms_and_conditionsAggregateType<T extends Terms_and_conditionsAggregateArgs> = {
    [P in keyof T & keyof AggregateTerms_and_conditions]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerms_and_conditions[P]>
      : GetScalarType<T[P], AggregateTerms_and_conditions[P]>;
  };

  export type terms_and_conditionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: terms_and_conditionsWhereInput;
    orderBy?: terms_and_conditionsOrderByWithAggregationInput | terms_and_conditionsOrderByWithAggregationInput[];
    by: Terms_and_conditionsScalarFieldEnum[] | Terms_and_conditionsScalarFieldEnum;
    having?: terms_and_conditionsScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: Terms_and_conditionsCountAggregateInputType | true;
    _min?: Terms_and_conditionsMinAggregateInputType;
    _max?: Terms_and_conditionsMaxAggregateInputType;
  };

  export type Terms_and_conditionsGroupByOutputType = {
    id: string;
    name: string;
    firm_id: string;
    description: string | null;
    active_flag: boolean;
    delete_flag: boolean;
    modified_at: Date;
    created_at: Date;
    created_by: string | null;
    modified_by: string | null;
    _count: Terms_and_conditionsCountAggregateOutputType | null;
    _min: Terms_and_conditionsMinAggregateOutputType | null;
    _max: Terms_and_conditionsMaxAggregateOutputType | null;
  };

  type GetTerms_and_conditionsGroupByPayload<T extends terms_and_conditionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Terms_and_conditionsGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof Terms_and_conditionsGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], Terms_and_conditionsGroupByOutputType[P]>
          : GetScalarType<T[P], Terms_and_conditionsGroupByOutputType[P]>;
      }
    >
  >;

  export type terms_and_conditionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        firm_id?: boolean;
        description?: boolean;
        active_flag?: boolean;
        delete_flag?: boolean;
        modified_at?: boolean;
        created_at?: boolean;
        created_by?: boolean;
        modified_by?: boolean;
        firm?: boolean | firmsDefaultArgs<ExtArgs>;
      },
      ExtArgs["result"]["terms_and_conditions"]
    >;

  export type terms_and_conditionsSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      firm_id?: boolean;
      description?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      modified_at?: boolean;
      created_at?: boolean;
      created_by?: boolean;
      modified_by?: boolean;
      firm?: boolean | firmsDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["terms_and_conditions"]
  >;

  export type terms_and_conditionsSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      firm_id?: boolean;
      description?: boolean;
      active_flag?: boolean;
      delete_flag?: boolean;
      modified_at?: boolean;
      created_at?: boolean;
      created_by?: boolean;
      modified_by?: boolean;
      firm?: boolean | firmsDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["terms_and_conditions"]
  >;

  export type terms_and_conditionsSelectScalar = {
    id?: boolean;
    name?: boolean;
    firm_id?: boolean;
    description?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: boolean;
    created_at?: boolean;
    created_by?: boolean;
    modified_by?: boolean;
  };

  export type terms_and_conditionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | "id"
      | "name"
      | "firm_id"
      | "description"
      | "active_flag"
      | "delete_flag"
      | "modified_at"
      | "created_at"
      | "created_by"
      | "modified_by",
      ExtArgs["result"]["terms_and_conditions"]
    >;
  export type terms_and_conditionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    firm?: boolean | firmsDefaultArgs<ExtArgs>;
  };
  export type terms_and_conditionsIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    firm?: boolean | firmsDefaultArgs<ExtArgs>;
  };
  export type terms_and_conditionsIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    firm?: boolean | firmsDefaultArgs<ExtArgs>;
  };

  export type $terms_and_conditionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "terms_and_conditions";
    objects: {
      firm: Prisma.$firmsPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        firm_id: string;
        description: string | null;
        active_flag: boolean;
        delete_flag: boolean;
        modified_at: Date;
        created_at: Date;
        created_by: string | null;
        modified_by: string | null;
      },
      ExtArgs["result"]["terms_and_conditions"]
    >;
    composites: {};
  };

  type terms_and_conditionsGetPayload<S extends boolean | null | undefined | terms_and_conditionsDefaultArgs> =
    $Result.GetResult<Prisma.$terms_and_conditionsPayload, S>;

  type terms_and_conditionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    terms_and_conditionsFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: Terms_and_conditionsCountAggregateInputType | true;
  };

  export interface terms_and_conditionsDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["terms_and_conditions"];
      meta: { name: "terms_and_conditions" };
    };
    /**
     * Find zero or one Terms_and_conditions that matches the filter.
     * @param {terms_and_conditionsFindUniqueArgs} args - Arguments to find a Terms_and_conditions
     * @example
     * // Get one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends terms_and_conditionsFindUniqueArgs>(
      args: SelectSubset<T, terms_and_conditionsFindUniqueArgs<ExtArgs>>,
    ): Prisma__terms_and_conditionsClient<
      $Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Terms_and_conditions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {terms_and_conditionsFindUniqueOrThrowArgs} args - Arguments to find a Terms_and_conditions
     * @example
     * // Get one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends terms_and_conditionsFindUniqueOrThrowArgs>(
      args: SelectSubset<T, terms_and_conditionsFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__terms_and_conditionsClient<
      $Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Terms_and_conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terms_and_conditionsFindFirstArgs} args - Arguments to find a Terms_and_conditions
     * @example
     * // Get one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends terms_and_conditionsFindFirstArgs>(
      args?: SelectSubset<T, terms_and_conditionsFindFirstArgs<ExtArgs>>,
    ): Prisma__terms_and_conditionsClient<
      $Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Terms_and_conditions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terms_and_conditionsFindFirstOrThrowArgs} args - Arguments to find a Terms_and_conditions
     * @example
     * // Get one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends terms_and_conditionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, terms_and_conditionsFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__terms_and_conditionsClient<
      $Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Terms_and_conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terms_and_conditionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findMany()
     *
     * // Get first 10 Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const terms_and_conditionsWithIdOnly = await prisma.terms_and_conditions.findMany({ select: { id: true } })
     *
     */
    findMany<T extends terms_and_conditionsFindManyArgs>(
      args?: SelectSubset<T, terms_and_conditionsFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
    >;

    /**
     * Create a Terms_and_conditions.
     * @param {terms_and_conditionsCreateArgs} args - Arguments to create a Terms_and_conditions.
     * @example
     * // Create one Terms_and_conditions
     * const Terms_and_conditions = await prisma.terms_and_conditions.create({
     *   data: {
     *     // ... data to create a Terms_and_conditions
     *   }
     * })
     *
     */
    create<T extends terms_and_conditionsCreateArgs>(
      args: SelectSubset<T, terms_and_conditionsCreateArgs<ExtArgs>>,
    ): Prisma__terms_and_conditionsClient<
      $Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Terms_and_conditions.
     * @param {terms_and_conditionsCreateManyArgs} args - Arguments to create many Terms_and_conditions.
     * @example
     * // Create many Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends terms_and_conditionsCreateManyArgs>(
      args?: SelectSubset<T, terms_and_conditionsCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Terms_and_conditions and returns the data saved in the database.
     * @param {terms_and_conditionsCreateManyAndReturnArgs} args - Arguments to create many Terms_and_conditions.
     * @example
     * // Create many Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Terms_and_conditions and only return the `id`
     * const terms_and_conditionsWithIdOnly = await prisma.terms_and_conditions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends terms_and_conditionsCreateManyAndReturnArgs>(
      args?: SelectSubset<T, terms_and_conditionsCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Delete a Terms_and_conditions.
     * @param {terms_and_conditionsDeleteArgs} args - Arguments to delete one Terms_and_conditions.
     * @example
     * // Delete one Terms_and_conditions
     * const Terms_and_conditions = await prisma.terms_and_conditions.delete({
     *   where: {
     *     // ... filter to delete one Terms_and_conditions
     *   }
     * })
     *
     */
    delete<T extends terms_and_conditionsDeleteArgs>(
      args: SelectSubset<T, terms_and_conditionsDeleteArgs<ExtArgs>>,
    ): Prisma__terms_and_conditionsClient<
      $Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Terms_and_conditions.
     * @param {terms_and_conditionsUpdateArgs} args - Arguments to update one Terms_and_conditions.
     * @example
     * // Update one Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends terms_and_conditionsUpdateArgs>(
      args: SelectSubset<T, terms_and_conditionsUpdateArgs<ExtArgs>>,
    ): Prisma__terms_and_conditionsClient<
      $Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Terms_and_conditions.
     * @param {terms_and_conditionsDeleteManyArgs} args - Arguments to filter Terms_and_conditions to delete.
     * @example
     * // Delete a few Terms_and_conditions
     * const { count } = await prisma.terms_and_conditions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends terms_and_conditionsDeleteManyArgs>(
      args?: SelectSubset<T, terms_and_conditionsDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Terms_and_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terms_and_conditionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends terms_and_conditionsUpdateManyArgs>(
      args: SelectSubset<T, terms_and_conditionsUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Terms_and_conditions and returns the data updated in the database.
     * @param {terms_and_conditionsUpdateManyAndReturnArgs} args - Arguments to update many Terms_and_conditions.
     * @example
     * // Update many Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Terms_and_conditions and only return the `id`
     * const terms_and_conditionsWithIdOnly = await prisma.terms_and_conditions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends terms_and_conditionsUpdateManyAndReturnArgs>(
      args: SelectSubset<T, terms_and_conditionsUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>
    >;

    /**
     * Create or update one Terms_and_conditions.
     * @param {terms_and_conditionsUpsertArgs} args - Arguments to update or create a Terms_and_conditions.
     * @example
     * // Update or create a Terms_and_conditions
     * const terms_and_conditions = await prisma.terms_and_conditions.upsert({
     *   create: {
     *     // ... data to create a Terms_and_conditions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Terms_and_conditions we want to update
     *   }
     * })
     */
    upsert<T extends terms_and_conditionsUpsertArgs>(
      args: SelectSubset<T, terms_and_conditionsUpsertArgs<ExtArgs>>,
    ): Prisma__terms_and_conditionsClient<
      $Result.GetResult<Prisma.$terms_and_conditionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Terms_and_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terms_and_conditionsCountArgs} args - Arguments to filter Terms_and_conditions to count.
     * @example
     * // Count the number of Terms_and_conditions
     * const count = await prisma.terms_and_conditions.count({
     *   where: {
     *     // ... the filter for the Terms_and_conditions we want to count
     *   }
     * })
     **/
    count<T extends terms_and_conditionsCountArgs>(
      args?: Subset<T, terms_and_conditionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], Terms_and_conditionsCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Terms_and_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Terms_and_conditionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends Terms_and_conditionsAggregateArgs>(
      args: Subset<T, Terms_and_conditionsAggregateArgs>,
    ): Prisma.PrismaPromise<GetTerms_and_conditionsAggregateType<T>>;

    /**
     * Group by Terms_and_conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terms_and_conditionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends terms_and_conditionsGroupByArgs,
      HasSelectOrTake extends Or<Extends<"skip", Keys<T>>, Extends<"take", Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: terms_and_conditionsGroupByArgs["orderBy"] }
        : { orderBy?: terms_and_conditionsGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T["orderBy"]>>>,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, terms_and_conditionsGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors ? GetTerms_and_conditionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the terms_and_conditions model
     */
    readonly fields: terms_and_conditionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for terms_and_conditions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__terms_and_conditionsClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    firm<T extends firmsDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, firmsDefaultArgs<ExtArgs>>,
    ): Prisma__firmsClient<
      $Result.GetResult<Prisma.$firmsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the terms_and_conditions model
   */
  interface terms_and_conditionsFieldRefs {
    readonly id: FieldRef<"terms_and_conditions", "String">;
    readonly name: FieldRef<"terms_and_conditions", "String">;
    readonly firm_id: FieldRef<"terms_and_conditions", "String">;
    readonly description: FieldRef<"terms_and_conditions", "String">;
    readonly active_flag: FieldRef<"terms_and_conditions", "Boolean">;
    readonly delete_flag: FieldRef<"terms_and_conditions", "Boolean">;
    readonly modified_at: FieldRef<"terms_and_conditions", "DateTime">;
    readonly created_at: FieldRef<"terms_and_conditions", "DateTime">;
    readonly created_by: FieldRef<"terms_and_conditions", "String">;
    readonly modified_by: FieldRef<"terms_and_conditions", "String">;
  }

  // Custom InputTypes
  /**
   * terms_and_conditions findUnique
   */
  export type terms_and_conditionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null;
    /**
     * Filter, which terms_and_conditions to fetch.
     */
    where: terms_and_conditionsWhereUniqueInput;
  };

  /**
   * terms_and_conditions findUniqueOrThrow
   */
  export type terms_and_conditionsFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null;
    /**
     * Filter, which terms_and_conditions to fetch.
     */
    where: terms_and_conditionsWhereUniqueInput;
  };

  /**
   * terms_and_conditions findFirst
   */
  export type terms_and_conditionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null;
    /**
     * Filter, which terms_and_conditions to fetch.
     */
    where?: terms_and_conditionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of terms_and_conditions to fetch.
     */
    orderBy?: terms_and_conditionsOrderByWithRelationInput | terms_and_conditionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for terms_and_conditions.
     */
    cursor?: terms_and_conditionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` terms_and_conditions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` terms_and_conditions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of terms_and_conditions.
     */
    distinct?: Terms_and_conditionsScalarFieldEnum | Terms_and_conditionsScalarFieldEnum[];
  };

  /**
   * terms_and_conditions findFirstOrThrow
   */
  export type terms_and_conditionsFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null;
    /**
     * Filter, which terms_and_conditions to fetch.
     */
    where?: terms_and_conditionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of terms_and_conditions to fetch.
     */
    orderBy?: terms_and_conditionsOrderByWithRelationInput | terms_and_conditionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for terms_and_conditions.
     */
    cursor?: terms_and_conditionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` terms_and_conditions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` terms_and_conditions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of terms_and_conditions.
     */
    distinct?: Terms_and_conditionsScalarFieldEnum | Terms_and_conditionsScalarFieldEnum[];
  };

  /**
   * terms_and_conditions findMany
   */
  export type terms_and_conditionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null;
    /**
     * Filter, which terms_and_conditions to fetch.
     */
    where?: terms_and_conditionsWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of terms_and_conditions to fetch.
     */
    orderBy?: terms_and_conditionsOrderByWithRelationInput | terms_and_conditionsOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing terms_and_conditions.
     */
    cursor?: terms_and_conditionsWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` terms_and_conditions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` terms_and_conditions.
     */
    skip?: number;
    distinct?: Terms_and_conditionsScalarFieldEnum | Terms_and_conditionsScalarFieldEnum[];
  };

  /**
   * terms_and_conditions create
   */
  export type terms_and_conditionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null;
    /**
     * The data needed to create a terms_and_conditions.
     */
    data: XOR<terms_and_conditionsCreateInput, terms_and_conditionsUncheckedCreateInput>;
  };

  /**
   * terms_and_conditions createMany
   */
  export type terms_and_conditionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many terms_and_conditions.
     */
    data: terms_and_conditionsCreateManyInput | terms_and_conditionsCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * terms_and_conditions createManyAndReturn
   */
  export type terms_and_conditionsCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * The data used to create many terms_and_conditions.
     */
    data: terms_and_conditionsCreateManyInput | terms_and_conditionsCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * terms_and_conditions update
   */
  export type terms_and_conditionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null;
    /**
     * The data needed to update a terms_and_conditions.
     */
    data: XOR<terms_and_conditionsUpdateInput, terms_and_conditionsUncheckedUpdateInput>;
    /**
     * Choose, which terms_and_conditions to update.
     */
    where: terms_and_conditionsWhereUniqueInput;
  };

  /**
   * terms_and_conditions updateMany
   */
  export type terms_and_conditionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update terms_and_conditions.
     */
    data: XOR<terms_and_conditionsUpdateManyMutationInput, terms_and_conditionsUncheckedUpdateManyInput>;
    /**
     * Filter which terms_and_conditions to update
     */
    where?: terms_and_conditionsWhereInput;
    /**
     * Limit how many terms_and_conditions to update.
     */
    limit?: number;
  };

  /**
   * terms_and_conditions updateManyAndReturn
   */
  export type terms_and_conditionsUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * The data used to update terms_and_conditions.
     */
    data: XOR<terms_and_conditionsUpdateManyMutationInput, terms_and_conditionsUncheckedUpdateManyInput>;
    /**
     * Filter which terms_and_conditions to update
     */
    where?: terms_and_conditionsWhereInput;
    /**
     * Limit how many terms_and_conditions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * terms_and_conditions upsert
   */
  export type terms_and_conditionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null;
    /**
     * The filter to search for the terms_and_conditions to update in case it exists.
     */
    where: terms_and_conditionsWhereUniqueInput;
    /**
     * In case the terms_and_conditions found by the `where` argument doesn't exist, create a new terms_and_conditions with this data.
     */
    create: XOR<terms_and_conditionsCreateInput, terms_and_conditionsUncheckedCreateInput>;
    /**
     * In case the terms_and_conditions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<terms_and_conditionsUpdateInput, terms_and_conditionsUncheckedUpdateInput>;
  };

  /**
   * terms_and_conditions delete
   */
  export type terms_and_conditionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null;
    /**
     * Filter which terms_and_conditions to delete.
     */
    where: terms_and_conditionsWhereUniqueInput;
  };

  /**
   * terms_and_conditions deleteMany
   */
  export type terms_and_conditionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which terms_and_conditions to delete
     */
    where?: terms_and_conditionsWhereInput;
    /**
     * Limit how many terms_and_conditions to delete.
     */
    limit?: number;
  };

  /**
   * terms_and_conditions without action
   */
  export type terms_and_conditionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the terms_and_conditions
     */
    select?: terms_and_conditionsSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the terms_and_conditions
     */
    omit?: terms_and_conditionsOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terms_and_conditionsInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: "ReadUncommitted";
    ReadCommitted: "ReadCommitted";
    RepeatableRead: "RepeatableRead";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const AdminsScalarFieldEnum: {
    id: "id";
    full_name: "full_name";
    mobile: "mobile";
    email: "email";
    image: "image";
    username: "username";
    alternate_mobile: "alternate_mobile";
    address: "address";
    documents: "documents";
    city: "city";
    state: "state";
    country: "country";
    pin_code: "pin_code";
    adhaar_number: "adhaar_number";
    driving_license_number: "driving_license_number";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type AdminsScalarFieldEnum = (typeof AdminsScalarFieldEnum)[keyof typeof AdminsScalarFieldEnum];

  export const BlacklistsScalarFieldEnum: {
    id: "id";
    refresh_token: "refresh_token";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type BlacklistsScalarFieldEnum = (typeof BlacklistsScalarFieldEnum)[keyof typeof BlacklistsScalarFieldEnum];

  export const CustomersScalarFieldEnum: {
    id: "id";
    firm_id: "firm_id";
    full_name: "full_name";
    mobile: "mobile";
    email: "email";
    image: "image";
    username: "username";
    alternate_mobile: "alternate_mobile";
    address: "address";
    documents: "documents";
    city: "city";
    state: "state";
    country: "country";
    pin_code: "pin_code";
    adhaar_number: "adhaar_number";
    driving_license_number: "driving_license_number";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum];

  export const FirmsScalarFieldEnum: {
    id: "id";
    name: "name";
    mobile: "mobile";
    email: "email";
    media: "media";
    gst_number: "gst_number";
    address: "address";
    city: "city";
    state: "state";
    country: "country";
    pin_code: "pin_code";
    description: "description";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type FirmsScalarFieldEnum = (typeof FirmsScalarFieldEnum)[keyof typeof FirmsScalarFieldEnum];

  export const OwnersScalarFieldEnum: {
    id: "id";
    firm_id: "firm_id";
    full_name: "full_name";
    mobile: "mobile";
    email: "email";
    image: "image";
    username: "username";
    alternate_mobile: "alternate_mobile";
    address: "address";
    documents: "documents";
    city: "city";
    state: "state";
    country: "country";
    pin_code: "pin_code";
    adhaar_number: "adhaar_number";
    driving_license_number: "driving_license_number";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type OwnersScalarFieldEnum = (typeof OwnersScalarFieldEnum)[keyof typeof OwnersScalarFieldEnum];

  export const Payment_collectionsScalarFieldEnum: {
    id: "id";
    rental_id: "rental_id";
    firm_id: "firm_id";
    payment_mode_id: "payment_mode_id";
    amount: "amount";
    description: "description";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type Payment_collectionsScalarFieldEnum =
    (typeof Payment_collectionsScalarFieldEnum)[keyof typeof Payment_collectionsScalarFieldEnum];

  export const Payment_modesScalarFieldEnum: {
    id: "id";
    name: "name";
    description: "description";
    firm_id: "firm_id";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type Payment_modesScalarFieldEnum =
    (typeof Payment_modesScalarFieldEnum)[keyof typeof Payment_modesScalarFieldEnum];

  export const PrefixesScalarFieldEnum: {
    id: "id";
    object_type: "object_type";
    name: "name";
    start: "start";
    end: "end";
    current: "current";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type PrefixesScalarFieldEnum = (typeof PrefixesScalarFieldEnum)[keyof typeof PrefixesScalarFieldEnum];

  export const ProductsScalarFieldEnum: {
    id: "id";
    firm_id: "firm_id";
    name: "name";
    code: "code";
    price: "price";
    sales_price: "sales_price";
    fine: "fine";
    deposit: "deposit";
    description: "description";
    rental_period: "rental_period";
    fine_period: "fine_period";
    color: "color";
    type: "type";
    barcode: "barcode";
    brand: "brand";
    size: "size";
    stock: "stock";
    current_rented_stock: "current_rented_stock";
    keywords: "keywords";
    media: "media";
    status: "status";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum];

  export const Provider_configurationsScalarFieldEnum: {
    id: "id";
    provider_type: "provider_type";
    name: "name";
    description: "description";
    contact_number: "contact_number";
    email: "email";
    identifier: "identifier";
    url: "url";
    type: "type";
    user_name: "user_name";
    password: "password";
    client_id: "client_id";
    client_password: "client_password";
    api_key: "api_key";
    api_secret: "api_secret";
    status: "status";
    sender_details: "sender_details";
    outlet_reference: "outlet_reference";
    redirect_url: "redirect_url";
    additional_properties: "additional_properties";
    sender_id: "sender_id";
    account_usage_type_id: "account_usage_type_id";
    access_key_id: "access_key_id";
    secret_access_key: "secret_access_key";
    region: "region";
    bucket: "bucket";
    cdn: "cdn";
    project_id: "project_id";
    key_file_name: "key_file_name";
    cloud_name: "cloud_name";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    created_by: "created_by";
    created_at: "created_at";
    modified_at: "modified_at";
    modified_by: "modified_by";
  };

  export type Provider_configurationsScalarFieldEnum =
    (typeof Provider_configurationsScalarFieldEnum)[keyof typeof Provider_configurationsScalarFieldEnum];

  export const RentalsScalarFieldEnum: {
    id: "id";
    user_id: "user_id";
    payment_mode_id: "payment_mode_id";
    invoice_id: "invoice_id";
    invoice_date: "invoice_date";
    invoice_status: "invoice_status";
    rental_period: "rental_period";
    discount_amount: "discount_amount";
    pending_amount: "pending_amount";
    advance_amount: "advance_amount";
    deposit_amount: "deposit_amount";
    paid_amount: "paid_amount";
    total_amount: "total_amount";
    fine_amount: "fine_amount";
    rental_products: "rental_products";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    created_by: "created_by";
    created_at: "created_at";
    modified_at: "modified_at";
    modified_by: "modified_by";
  };

  export type RentalsScalarFieldEnum = (typeof RentalsScalarFieldEnum)[keyof typeof RentalsScalarFieldEnum];

  export const SettingsScalarFieldEnum: {
    id: "id";
    is_sms_otp_mode_live: "is_sms_otp_mode_live";
    is_email_otp_mode_live: "is_email_otp_mode_live";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum];

  export const SubscriptionsScalarFieldEnum: {
    id: "id";
    name: "name";
    price: "price";
    validity: "validity";
    description: "description";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type SubscriptionsScalarFieldEnum =
    (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum];

  export const TemplatesScalarFieldEnum: {
    id: "id";
    identifier: "identifier";
    type: "type";
    template_type: "template_type";
    provider_name: "provider_name";
    name: "name";
    subject: "subject";
    description: "description";
    provider_template_code: "provider_template_code";
    template: "template";
    instruction: "instruction";
    parameters: "parameters";
    is_html: "is_html";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type TemplatesScalarFieldEnum = (typeof TemplatesScalarFieldEnum)[keyof typeof TemplatesScalarFieldEnum];

  export const Terms_and_conditionsScalarFieldEnum: {
    id: "id";
    name: "name";
    firm_id: "firm_id";
    description: "description";
    active_flag: "active_flag";
    delete_flag: "delete_flag";
    modified_at: "modified_at";
    created_at: "created_at";
    created_by: "created_by";
    modified_by: "modified_by";
  };

  export type Terms_and_conditionsScalarFieldEnum =
    (typeof Terms_and_conditionsScalarFieldEnum)[keyof typeof Terms_and_conditionsScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "String">;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "String[]">;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Boolean">;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "DateTime">;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "DateTime[]">;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Float">;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Float[]">;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Int">;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Int[]">;

  /**
   * Reference to a field of type 'Period'
   */
  export type EnumPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Period">;

  /**
   * Reference to a field of type 'Period[]'
   */
  export type ListEnumPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Period[]">;

  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Status">;

  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Status[]">;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Json">;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "QueryMode">;

  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "Json[]">;

  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "InvoiceStatus">;

  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, "InvoiceStatus[]">;

  /**
   * Deep Input Types
   */

  export type adminsWhereInput = {
    AND?: adminsWhereInput | adminsWhereInput[];
    OR?: adminsWhereInput[];
    NOT?: adminsWhereInput | adminsWhereInput[];
    id?: StringFilter<"admins"> | string;
    full_name?: StringNullableFilter<"admins"> | string | null;
    mobile?: StringNullableFilter<"admins"> | string | null;
    email?: StringNullableFilter<"admins"> | string | null;
    image?: StringNullableFilter<"admins"> | string | null;
    username?: StringNullableFilter<"admins"> | string | null;
    alternate_mobile?: StringNullableFilter<"admins"> | string | null;
    address?: StringNullableFilter<"admins"> | string | null;
    documents?: StringNullableListFilter<"admins">;
    city?: StringNullableFilter<"admins"> | string | null;
    state?: StringNullableFilter<"admins"> | string | null;
    country?: StringNullableFilter<"admins"> | string | null;
    pin_code?: StringNullableFilter<"admins"> | string | null;
    adhaar_number?: StringNullableFilter<"admins"> | string | null;
    driving_license_number?: StringNullableFilter<"admins"> | string | null;
    active_flag?: BoolFilter<"admins"> | boolean;
    delete_flag?: BoolFilter<"admins"> | boolean;
    modified_at?: DateTimeFilter<"admins"> | Date | string;
    created_at?: DateTimeFilter<"admins"> | Date | string;
    created_by?: StringNullableFilter<"admins"> | string | null;
    modified_by?: StringNullableFilter<"admins"> | string | null;
  };

  export type adminsOrderByWithRelationInput = {
    id?: SortOrder;
    full_name?: SortOrderInput | SortOrder;
    mobile?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    username?: SortOrderInput | SortOrder;
    alternate_mobile?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    documents?: SortOrder;
    city?: SortOrderInput | SortOrder;
    state?: SortOrderInput | SortOrder;
    country?: SortOrderInput | SortOrder;
    pin_code?: SortOrderInput | SortOrder;
    adhaar_number?: SortOrderInput | SortOrder;
    driving_license_number?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
  };

  export type adminsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: adminsWhereInput | adminsWhereInput[];
      OR?: adminsWhereInput[];
      NOT?: adminsWhereInput | adminsWhereInput[];
      full_name?: StringNullableFilter<"admins"> | string | null;
      mobile?: StringNullableFilter<"admins"> | string | null;
      email?: StringNullableFilter<"admins"> | string | null;
      image?: StringNullableFilter<"admins"> | string | null;
      username?: StringNullableFilter<"admins"> | string | null;
      alternate_mobile?: StringNullableFilter<"admins"> | string | null;
      address?: StringNullableFilter<"admins"> | string | null;
      documents?: StringNullableListFilter<"admins">;
      city?: StringNullableFilter<"admins"> | string | null;
      state?: StringNullableFilter<"admins"> | string | null;
      country?: StringNullableFilter<"admins"> | string | null;
      pin_code?: StringNullableFilter<"admins"> | string | null;
      adhaar_number?: StringNullableFilter<"admins"> | string | null;
      driving_license_number?: StringNullableFilter<"admins"> | string | null;
      active_flag?: BoolFilter<"admins"> | boolean;
      delete_flag?: BoolFilter<"admins"> | boolean;
      modified_at?: DateTimeFilter<"admins"> | Date | string;
      created_at?: DateTimeFilter<"admins"> | Date | string;
      created_by?: StringNullableFilter<"admins"> | string | null;
      modified_by?: StringNullableFilter<"admins"> | string | null;
    },
    "id"
  >;

  export type adminsOrderByWithAggregationInput = {
    id?: SortOrder;
    full_name?: SortOrderInput | SortOrder;
    mobile?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    username?: SortOrderInput | SortOrder;
    alternate_mobile?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    documents?: SortOrder;
    city?: SortOrderInput | SortOrder;
    state?: SortOrderInput | SortOrder;
    country?: SortOrderInput | SortOrder;
    pin_code?: SortOrderInput | SortOrder;
    adhaar_number?: SortOrderInput | SortOrder;
    driving_license_number?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: adminsCountOrderByAggregateInput;
    _max?: adminsMaxOrderByAggregateInput;
    _min?: adminsMinOrderByAggregateInput;
  };

  export type adminsScalarWhereWithAggregatesInput = {
    AND?: adminsScalarWhereWithAggregatesInput | adminsScalarWhereWithAggregatesInput[];
    OR?: adminsScalarWhereWithAggregatesInput[];
    NOT?: adminsScalarWhereWithAggregatesInput | adminsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"admins"> | string;
    full_name?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    mobile?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    email?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    image?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    username?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    alternate_mobile?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    address?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    documents?: StringNullableListFilter<"admins">;
    city?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    state?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    country?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    pin_code?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    adhaar_number?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    driving_license_number?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    active_flag?: BoolWithAggregatesFilter<"admins"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"admins"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"admins"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"admins"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"admins"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"admins"> | string | null;
  };

  export type blacklistsWhereInput = {
    AND?: blacklistsWhereInput | blacklistsWhereInput[];
    OR?: blacklistsWhereInput[];
    NOT?: blacklistsWhereInput | blacklistsWhereInput[];
    id?: StringFilter<"blacklists"> | string;
    refresh_token?: StringFilter<"blacklists"> | string;
    active_flag?: BoolFilter<"blacklists"> | boolean;
    delete_flag?: BoolFilter<"blacklists"> | boolean;
    modified_at?: DateTimeFilter<"blacklists"> | Date | string;
    created_at?: DateTimeFilter<"blacklists"> | Date | string;
    created_by?: StringNullableFilter<"blacklists"> | string | null;
    modified_by?: StringNullableFilter<"blacklists"> | string | null;
  };

  export type blacklistsOrderByWithRelationInput = {
    id?: SortOrder;
    refresh_token?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
  };

  export type blacklistsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      refresh_token?: string;
      AND?: blacklistsWhereInput | blacklistsWhereInput[];
      OR?: blacklistsWhereInput[];
      NOT?: blacklistsWhereInput | blacklistsWhereInput[];
      active_flag?: BoolFilter<"blacklists"> | boolean;
      delete_flag?: BoolFilter<"blacklists"> | boolean;
      modified_at?: DateTimeFilter<"blacklists"> | Date | string;
      created_at?: DateTimeFilter<"blacklists"> | Date | string;
      created_by?: StringNullableFilter<"blacklists"> | string | null;
      modified_by?: StringNullableFilter<"blacklists"> | string | null;
    },
    "id" | "refresh_token"
  >;

  export type blacklistsOrderByWithAggregationInput = {
    id?: SortOrder;
    refresh_token?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: blacklistsCountOrderByAggregateInput;
    _max?: blacklistsMaxOrderByAggregateInput;
    _min?: blacklistsMinOrderByAggregateInput;
  };

  export type blacklistsScalarWhereWithAggregatesInput = {
    AND?: blacklistsScalarWhereWithAggregatesInput | blacklistsScalarWhereWithAggregatesInput[];
    OR?: blacklistsScalarWhereWithAggregatesInput[];
    NOT?: blacklistsScalarWhereWithAggregatesInput | blacklistsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"blacklists"> | string;
    refresh_token?: StringWithAggregatesFilter<"blacklists"> | string;
    active_flag?: BoolWithAggregatesFilter<"blacklists"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"blacklists"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"blacklists"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"blacklists"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"blacklists"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"blacklists"> | string | null;
  };

  export type customersWhereInput = {
    AND?: customersWhereInput | customersWhereInput[];
    OR?: customersWhereInput[];
    NOT?: customersWhereInput | customersWhereInput[];
    id?: StringFilter<"customers"> | string;
    firm_id?: StringFilter<"customers"> | string;
    full_name?: StringNullableFilter<"customers"> | string | null;
    mobile?: StringNullableFilter<"customers"> | string | null;
    email?: StringNullableFilter<"customers"> | string | null;
    image?: StringNullableFilter<"customers"> | string | null;
    username?: StringNullableFilter<"customers"> | string | null;
    alternate_mobile?: StringNullableFilter<"customers"> | string | null;
    address?: StringNullableFilter<"customers"> | string | null;
    documents?: StringNullableListFilter<"customers">;
    city?: StringNullableFilter<"customers"> | string | null;
    state?: StringNullableFilter<"customers"> | string | null;
    country?: StringNullableFilter<"customers"> | string | null;
    pin_code?: StringNullableFilter<"customers"> | string | null;
    adhaar_number?: StringNullableFilter<"customers"> | string | null;
    driving_license_number?: StringNullableFilter<"customers"> | string | null;
    active_flag?: BoolFilter<"customers"> | boolean;
    delete_flag?: BoolFilter<"customers"> | boolean;
    modified_at?: DateTimeFilter<"customers"> | Date | string;
    created_at?: DateTimeFilter<"customers"> | Date | string;
    created_by?: StringNullableFilter<"customers"> | string | null;
    modified_by?: StringNullableFilter<"customers"> | string | null;
    firm?: XOR<FirmsScalarRelationFilter, firmsWhereInput>;
    rentals?: RentalsListRelationFilter;
  };

  export type customersOrderByWithRelationInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    full_name?: SortOrderInput | SortOrder;
    mobile?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    username?: SortOrderInput | SortOrder;
    alternate_mobile?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    documents?: SortOrder;
    city?: SortOrderInput | SortOrder;
    state?: SortOrderInput | SortOrder;
    country?: SortOrderInput | SortOrder;
    pin_code?: SortOrderInput | SortOrder;
    adhaar_number?: SortOrderInput | SortOrder;
    driving_license_number?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    firm?: firmsOrderByWithRelationInput;
    rentals?: rentalsOrderByRelationAggregateInput;
  };

  export type customersWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: customersWhereInput | customersWhereInput[];
      OR?: customersWhereInput[];
      NOT?: customersWhereInput | customersWhereInput[];
      firm_id?: StringFilter<"customers"> | string;
      full_name?: StringNullableFilter<"customers"> | string | null;
      mobile?: StringNullableFilter<"customers"> | string | null;
      email?: StringNullableFilter<"customers"> | string | null;
      image?: StringNullableFilter<"customers"> | string | null;
      username?: StringNullableFilter<"customers"> | string | null;
      alternate_mobile?: StringNullableFilter<"customers"> | string | null;
      address?: StringNullableFilter<"customers"> | string | null;
      documents?: StringNullableListFilter<"customers">;
      city?: StringNullableFilter<"customers"> | string | null;
      state?: StringNullableFilter<"customers"> | string | null;
      country?: StringNullableFilter<"customers"> | string | null;
      pin_code?: StringNullableFilter<"customers"> | string | null;
      adhaar_number?: StringNullableFilter<"customers"> | string | null;
      driving_license_number?: StringNullableFilter<"customers"> | string | null;
      active_flag?: BoolFilter<"customers"> | boolean;
      delete_flag?: BoolFilter<"customers"> | boolean;
      modified_at?: DateTimeFilter<"customers"> | Date | string;
      created_at?: DateTimeFilter<"customers"> | Date | string;
      created_by?: StringNullableFilter<"customers"> | string | null;
      modified_by?: StringNullableFilter<"customers"> | string | null;
      firm?: XOR<FirmsScalarRelationFilter, firmsWhereInput>;
      rentals?: RentalsListRelationFilter;
    },
    "id"
  >;

  export type customersOrderByWithAggregationInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    full_name?: SortOrderInput | SortOrder;
    mobile?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    username?: SortOrderInput | SortOrder;
    alternate_mobile?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    documents?: SortOrder;
    city?: SortOrderInput | SortOrder;
    state?: SortOrderInput | SortOrder;
    country?: SortOrderInput | SortOrder;
    pin_code?: SortOrderInput | SortOrder;
    adhaar_number?: SortOrderInput | SortOrder;
    driving_license_number?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: customersCountOrderByAggregateInput;
    _max?: customersMaxOrderByAggregateInput;
    _min?: customersMinOrderByAggregateInput;
  };

  export type customersScalarWhereWithAggregatesInput = {
    AND?: customersScalarWhereWithAggregatesInput | customersScalarWhereWithAggregatesInput[];
    OR?: customersScalarWhereWithAggregatesInput[];
    NOT?: customersScalarWhereWithAggregatesInput | customersScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"customers"> | string;
    firm_id?: StringWithAggregatesFilter<"customers"> | string;
    full_name?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    mobile?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    email?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    image?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    username?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    alternate_mobile?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    address?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    documents?: StringNullableListFilter<"customers">;
    city?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    state?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    country?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    pin_code?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    adhaar_number?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    driving_license_number?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    active_flag?: BoolWithAggregatesFilter<"customers"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"customers"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"customers"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"customers"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"customers"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"customers"> | string | null;
  };

  export type firmsWhereInput = {
    AND?: firmsWhereInput | firmsWhereInput[];
    OR?: firmsWhereInput[];
    NOT?: firmsWhereInput | firmsWhereInput[];
    id?: StringFilter<"firms"> | string;
    name?: StringFilter<"firms"> | string;
    mobile?: StringNullableFilter<"firms"> | string | null;
    email?: StringNullableFilter<"firms"> | string | null;
    media?: StringNullableListFilter<"firms">;
    gst_number?: StringNullableFilter<"firms"> | string | null;
    address?: StringNullableFilter<"firms"> | string | null;
    city?: StringNullableFilter<"firms"> | string | null;
    state?: StringNullableFilter<"firms"> | string | null;
    country?: StringNullableFilter<"firms"> | string | null;
    pin_code?: StringNullableFilter<"firms"> | string | null;
    description?: StringNullableFilter<"firms"> | string | null;
    active_flag?: BoolFilter<"firms"> | boolean;
    delete_flag?: BoolFilter<"firms"> | boolean;
    modified_at?: DateTimeFilter<"firms"> | Date | string;
    created_at?: DateTimeFilter<"firms"> | Date | string;
    created_by?: StringNullableFilter<"firms"> | string | null;
    modified_by?: StringNullableFilter<"firms"> | string | null;
    products?: ProductsListRelationFilter;
    terms_and_conditions?: Terms_and_conditionsListRelationFilter;
    payment_collections?: Payment_collectionsListRelationFilter;
    payment_modes?: Payment_modesListRelationFilter;
    customers?: CustomersListRelationFilter;
    owners?: OwnersListRelationFilter;
  };

  export type firmsOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    mobile?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    media?: SortOrder;
    gst_number?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    city?: SortOrderInput | SortOrder;
    state?: SortOrderInput | SortOrder;
    country?: SortOrderInput | SortOrder;
    pin_code?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    products?: productsOrderByRelationAggregateInput;
    terms_and_conditions?: terms_and_conditionsOrderByRelationAggregateInput;
    payment_collections?: payment_collectionsOrderByRelationAggregateInput;
    payment_modes?: payment_modesOrderByRelationAggregateInput;
    customers?: customersOrderByRelationAggregateInput;
    owners?: ownersOrderByRelationAggregateInput;
  };

  export type firmsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: firmsWhereInput | firmsWhereInput[];
      OR?: firmsWhereInput[];
      NOT?: firmsWhereInput | firmsWhereInput[];
      name?: StringFilter<"firms"> | string;
      mobile?: StringNullableFilter<"firms"> | string | null;
      email?: StringNullableFilter<"firms"> | string | null;
      media?: StringNullableListFilter<"firms">;
      gst_number?: StringNullableFilter<"firms"> | string | null;
      address?: StringNullableFilter<"firms"> | string | null;
      city?: StringNullableFilter<"firms"> | string | null;
      state?: StringNullableFilter<"firms"> | string | null;
      country?: StringNullableFilter<"firms"> | string | null;
      pin_code?: StringNullableFilter<"firms"> | string | null;
      description?: StringNullableFilter<"firms"> | string | null;
      active_flag?: BoolFilter<"firms"> | boolean;
      delete_flag?: BoolFilter<"firms"> | boolean;
      modified_at?: DateTimeFilter<"firms"> | Date | string;
      created_at?: DateTimeFilter<"firms"> | Date | string;
      created_by?: StringNullableFilter<"firms"> | string | null;
      modified_by?: StringNullableFilter<"firms"> | string | null;
      products?: ProductsListRelationFilter;
      terms_and_conditions?: Terms_and_conditionsListRelationFilter;
      payment_collections?: Payment_collectionsListRelationFilter;
      payment_modes?: Payment_modesListRelationFilter;
      customers?: CustomersListRelationFilter;
      owners?: OwnersListRelationFilter;
    },
    "id"
  >;

  export type firmsOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    mobile?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    media?: SortOrder;
    gst_number?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    city?: SortOrderInput | SortOrder;
    state?: SortOrderInput | SortOrder;
    country?: SortOrderInput | SortOrder;
    pin_code?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: firmsCountOrderByAggregateInput;
    _max?: firmsMaxOrderByAggregateInput;
    _min?: firmsMinOrderByAggregateInput;
  };

  export type firmsScalarWhereWithAggregatesInput = {
    AND?: firmsScalarWhereWithAggregatesInput | firmsScalarWhereWithAggregatesInput[];
    OR?: firmsScalarWhereWithAggregatesInput[];
    NOT?: firmsScalarWhereWithAggregatesInput | firmsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"firms"> | string;
    name?: StringWithAggregatesFilter<"firms"> | string;
    mobile?: StringNullableWithAggregatesFilter<"firms"> | string | null;
    email?: StringNullableWithAggregatesFilter<"firms"> | string | null;
    media?: StringNullableListFilter<"firms">;
    gst_number?: StringNullableWithAggregatesFilter<"firms"> | string | null;
    address?: StringNullableWithAggregatesFilter<"firms"> | string | null;
    city?: StringNullableWithAggregatesFilter<"firms"> | string | null;
    state?: StringNullableWithAggregatesFilter<"firms"> | string | null;
    country?: StringNullableWithAggregatesFilter<"firms"> | string | null;
    pin_code?: StringNullableWithAggregatesFilter<"firms"> | string | null;
    description?: StringNullableWithAggregatesFilter<"firms"> | string | null;
    active_flag?: BoolWithAggregatesFilter<"firms"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"firms"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"firms"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"firms"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"firms"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"firms"> | string | null;
  };

  export type ownersWhereInput = {
    AND?: ownersWhereInput | ownersWhereInput[];
    OR?: ownersWhereInput[];
    NOT?: ownersWhereInput | ownersWhereInput[];
    id?: StringFilter<"owners"> | string;
    firm_id?: StringFilter<"owners"> | string;
    full_name?: StringNullableFilter<"owners"> | string | null;
    mobile?: StringNullableFilter<"owners"> | string | null;
    email?: StringNullableFilter<"owners"> | string | null;
    image?: StringNullableFilter<"owners"> | string | null;
    username?: StringNullableFilter<"owners"> | string | null;
    alternate_mobile?: StringNullableFilter<"owners"> | string | null;
    address?: StringNullableFilter<"owners"> | string | null;
    documents?: StringNullableListFilter<"owners">;
    city?: StringNullableFilter<"owners"> | string | null;
    state?: StringNullableFilter<"owners"> | string | null;
    country?: StringNullableFilter<"owners"> | string | null;
    pin_code?: StringNullableFilter<"owners"> | string | null;
    adhaar_number?: StringNullableFilter<"owners"> | string | null;
    driving_license_number?: StringNullableFilter<"owners"> | string | null;
    active_flag?: BoolFilter<"owners"> | boolean;
    delete_flag?: BoolFilter<"owners"> | boolean;
    modified_at?: DateTimeFilter<"owners"> | Date | string;
    created_at?: DateTimeFilter<"owners"> | Date | string;
    created_by?: StringNullableFilter<"owners"> | string | null;
    modified_by?: StringNullableFilter<"owners"> | string | null;
    firm?: XOR<FirmsNullableScalarRelationFilter, firmsWhereInput> | null;
  };

  export type ownersOrderByWithRelationInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    full_name?: SortOrderInput | SortOrder;
    mobile?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    username?: SortOrderInput | SortOrder;
    alternate_mobile?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    documents?: SortOrder;
    city?: SortOrderInput | SortOrder;
    state?: SortOrderInput | SortOrder;
    country?: SortOrderInput | SortOrder;
    pin_code?: SortOrderInput | SortOrder;
    adhaar_number?: SortOrderInput | SortOrder;
    driving_license_number?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    firm?: firmsOrderByWithRelationInput;
  };

  export type ownersWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ownersWhereInput | ownersWhereInput[];
      OR?: ownersWhereInput[];
      NOT?: ownersWhereInput | ownersWhereInput[];
      firm_id?: StringFilter<"owners"> | string;
      full_name?: StringNullableFilter<"owners"> | string | null;
      mobile?: StringNullableFilter<"owners"> | string | null;
      email?: StringNullableFilter<"owners"> | string | null;
      image?: StringNullableFilter<"owners"> | string | null;
      username?: StringNullableFilter<"owners"> | string | null;
      alternate_mobile?: StringNullableFilter<"owners"> | string | null;
      address?: StringNullableFilter<"owners"> | string | null;
      documents?: StringNullableListFilter<"owners">;
      city?: StringNullableFilter<"owners"> | string | null;
      state?: StringNullableFilter<"owners"> | string | null;
      country?: StringNullableFilter<"owners"> | string | null;
      pin_code?: StringNullableFilter<"owners"> | string | null;
      adhaar_number?: StringNullableFilter<"owners"> | string | null;
      driving_license_number?: StringNullableFilter<"owners"> | string | null;
      active_flag?: BoolFilter<"owners"> | boolean;
      delete_flag?: BoolFilter<"owners"> | boolean;
      modified_at?: DateTimeFilter<"owners"> | Date | string;
      created_at?: DateTimeFilter<"owners"> | Date | string;
      created_by?: StringNullableFilter<"owners"> | string | null;
      modified_by?: StringNullableFilter<"owners"> | string | null;
      firm?: XOR<FirmsNullableScalarRelationFilter, firmsWhereInput> | null;
    },
    "id"
  >;

  export type ownersOrderByWithAggregationInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    full_name?: SortOrderInput | SortOrder;
    mobile?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    image?: SortOrderInput | SortOrder;
    username?: SortOrderInput | SortOrder;
    alternate_mobile?: SortOrderInput | SortOrder;
    address?: SortOrderInput | SortOrder;
    documents?: SortOrder;
    city?: SortOrderInput | SortOrder;
    state?: SortOrderInput | SortOrder;
    country?: SortOrderInput | SortOrder;
    pin_code?: SortOrderInput | SortOrder;
    adhaar_number?: SortOrderInput | SortOrder;
    driving_license_number?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: ownersCountOrderByAggregateInput;
    _max?: ownersMaxOrderByAggregateInput;
    _min?: ownersMinOrderByAggregateInput;
  };

  export type ownersScalarWhereWithAggregatesInput = {
    AND?: ownersScalarWhereWithAggregatesInput | ownersScalarWhereWithAggregatesInput[];
    OR?: ownersScalarWhereWithAggregatesInput[];
    NOT?: ownersScalarWhereWithAggregatesInput | ownersScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"owners"> | string;
    firm_id?: StringWithAggregatesFilter<"owners"> | string;
    full_name?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    mobile?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    email?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    image?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    username?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    alternate_mobile?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    address?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    documents?: StringNullableListFilter<"owners">;
    city?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    state?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    country?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    pin_code?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    adhaar_number?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    driving_license_number?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    active_flag?: BoolWithAggregatesFilter<"owners"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"owners"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"owners"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"owners"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"owners"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"owners"> | string | null;
  };

  export type payment_collectionsWhereInput = {
    AND?: payment_collectionsWhereInput | payment_collectionsWhereInput[];
    OR?: payment_collectionsWhereInput[];
    NOT?: payment_collectionsWhereInput | payment_collectionsWhereInput[];
    id?: StringFilter<"payment_collections"> | string;
    rental_id?: StringFilter<"payment_collections"> | string;
    firm_id?: StringFilter<"payment_collections"> | string;
    payment_mode_id?: StringFilter<"payment_collections"> | string;
    amount?: FloatFilter<"payment_collections"> | number;
    description?: StringNullableFilter<"payment_collections"> | string | null;
    active_flag?: BoolFilter<"payment_collections"> | boolean;
    delete_flag?: BoolFilter<"payment_collections"> | boolean;
    modified_at?: DateTimeFilter<"payment_collections"> | Date | string;
    created_at?: DateTimeFilter<"payment_collections"> | Date | string;
    created_by?: StringNullableFilter<"payment_collections"> | string | null;
    modified_by?: StringNullableFilter<"payment_collections"> | string | null;
    firm?: XOR<FirmsNullableScalarRelationFilter, firmsWhereInput> | null;
    payment_mode?: XOR<Payment_modesNullableScalarRelationFilter, payment_modesWhereInput> | null;
    rental?: XOR<RentalsNullableScalarRelationFilter, rentalsWhereInput> | null;
  };

  export type payment_collectionsOrderByWithRelationInput = {
    id?: SortOrder;
    rental_id?: SortOrder;
    firm_id?: SortOrder;
    payment_mode_id?: SortOrder;
    amount?: SortOrder;
    description?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    firm?: firmsOrderByWithRelationInput;
    payment_mode?: payment_modesOrderByWithRelationInput;
    rental?: rentalsOrderByWithRelationInput;
  };

  export type payment_collectionsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: payment_collectionsWhereInput | payment_collectionsWhereInput[];
      OR?: payment_collectionsWhereInput[];
      NOT?: payment_collectionsWhereInput | payment_collectionsWhereInput[];
      rental_id?: StringFilter<"payment_collections"> | string;
      firm_id?: StringFilter<"payment_collections"> | string;
      payment_mode_id?: StringFilter<"payment_collections"> | string;
      amount?: FloatFilter<"payment_collections"> | number;
      description?: StringNullableFilter<"payment_collections"> | string | null;
      active_flag?: BoolFilter<"payment_collections"> | boolean;
      delete_flag?: BoolFilter<"payment_collections"> | boolean;
      modified_at?: DateTimeFilter<"payment_collections"> | Date | string;
      created_at?: DateTimeFilter<"payment_collections"> | Date | string;
      created_by?: StringNullableFilter<"payment_collections"> | string | null;
      modified_by?: StringNullableFilter<"payment_collections"> | string | null;
      firm?: XOR<FirmsNullableScalarRelationFilter, firmsWhereInput> | null;
      payment_mode?: XOR<Payment_modesNullableScalarRelationFilter, payment_modesWhereInput> | null;
      rental?: XOR<RentalsNullableScalarRelationFilter, rentalsWhereInput> | null;
    },
    "id"
  >;

  export type payment_collectionsOrderByWithAggregationInput = {
    id?: SortOrder;
    rental_id?: SortOrder;
    firm_id?: SortOrder;
    payment_mode_id?: SortOrder;
    amount?: SortOrder;
    description?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: payment_collectionsCountOrderByAggregateInput;
    _avg?: payment_collectionsAvgOrderByAggregateInput;
    _max?: payment_collectionsMaxOrderByAggregateInput;
    _min?: payment_collectionsMinOrderByAggregateInput;
    _sum?: payment_collectionsSumOrderByAggregateInput;
  };

  export type payment_collectionsScalarWhereWithAggregatesInput = {
    AND?: payment_collectionsScalarWhereWithAggregatesInput | payment_collectionsScalarWhereWithAggregatesInput[];
    OR?: payment_collectionsScalarWhereWithAggregatesInput[];
    NOT?: payment_collectionsScalarWhereWithAggregatesInput | payment_collectionsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"payment_collections"> | string;
    rental_id?: StringWithAggregatesFilter<"payment_collections"> | string;
    firm_id?: StringWithAggregatesFilter<"payment_collections"> | string;
    payment_mode_id?: StringWithAggregatesFilter<"payment_collections"> | string;
    amount?: FloatWithAggregatesFilter<"payment_collections"> | number;
    description?: StringNullableWithAggregatesFilter<"payment_collections"> | string | null;
    active_flag?: BoolWithAggregatesFilter<"payment_collections"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"payment_collections"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"payment_collections"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"payment_collections"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"payment_collections"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"payment_collections"> | string | null;
  };

  export type payment_modesWhereInput = {
    AND?: payment_modesWhereInput | payment_modesWhereInput[];
    OR?: payment_modesWhereInput[];
    NOT?: payment_modesWhereInput | payment_modesWhereInput[];
    id?: StringFilter<"payment_modes"> | string;
    name?: StringFilter<"payment_modes"> | string;
    description?: StringNullableFilter<"payment_modes"> | string | null;
    firm_id?: StringNullableFilter<"payment_modes"> | string | null;
    active_flag?: BoolFilter<"payment_modes"> | boolean;
    delete_flag?: BoolFilter<"payment_modes"> | boolean;
    modified_at?: DateTimeFilter<"payment_modes"> | Date | string;
    created_at?: DateTimeFilter<"payment_modes"> | Date | string;
    created_by?: StringNullableFilter<"payment_modes"> | string | null;
    modified_by?: StringNullableFilter<"payment_modes"> | string | null;
    firm?: XOR<FirmsNullableScalarRelationFilter, firmsWhereInput> | null;
    payment_collections?: Payment_collectionsListRelationFilter;
    rentals?: RentalsListRelationFilter;
  };

  export type payment_modesOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    firm_id?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    firm?: firmsOrderByWithRelationInput;
    payment_collections?: payment_collectionsOrderByRelationAggregateInput;
    rentals?: rentalsOrderByRelationAggregateInput;
  };

  export type payment_modesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: string;
      AND?: payment_modesWhereInput | payment_modesWhereInput[];
      OR?: payment_modesWhereInput[];
      NOT?: payment_modesWhereInput | payment_modesWhereInput[];
      description?: StringNullableFilter<"payment_modes"> | string | null;
      firm_id?: StringNullableFilter<"payment_modes"> | string | null;
      active_flag?: BoolFilter<"payment_modes"> | boolean;
      delete_flag?: BoolFilter<"payment_modes"> | boolean;
      modified_at?: DateTimeFilter<"payment_modes"> | Date | string;
      created_at?: DateTimeFilter<"payment_modes"> | Date | string;
      created_by?: StringNullableFilter<"payment_modes"> | string | null;
      modified_by?: StringNullableFilter<"payment_modes"> | string | null;
      firm?: XOR<FirmsNullableScalarRelationFilter, firmsWhereInput> | null;
      payment_collections?: Payment_collectionsListRelationFilter;
      rentals?: RentalsListRelationFilter;
    },
    "id" | "name"
  >;

  export type payment_modesOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    firm_id?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: payment_modesCountOrderByAggregateInput;
    _max?: payment_modesMaxOrderByAggregateInput;
    _min?: payment_modesMinOrderByAggregateInput;
  };

  export type payment_modesScalarWhereWithAggregatesInput = {
    AND?: payment_modesScalarWhereWithAggregatesInput | payment_modesScalarWhereWithAggregatesInput[];
    OR?: payment_modesScalarWhereWithAggregatesInput[];
    NOT?: payment_modesScalarWhereWithAggregatesInput | payment_modesScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"payment_modes"> | string;
    name?: StringWithAggregatesFilter<"payment_modes"> | string;
    description?: StringNullableWithAggregatesFilter<"payment_modes"> | string | null;
    firm_id?: StringNullableWithAggregatesFilter<"payment_modes"> | string | null;
    active_flag?: BoolWithAggregatesFilter<"payment_modes"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"payment_modes"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"payment_modes"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"payment_modes"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"payment_modes"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"payment_modes"> | string | null;
  };

  export type prefixesWhereInput = {
    AND?: prefixesWhereInput | prefixesWhereInput[];
    OR?: prefixesWhereInput[];
    NOT?: prefixesWhereInput | prefixesWhereInput[];
    id?: StringFilter<"prefixes"> | string;
    object_type?: StringFilter<"prefixes"> | string;
    name?: StringFilter<"prefixes"> | string;
    start?: IntFilter<"prefixes"> | number;
    end?: IntFilter<"prefixes"> | number;
    current?: IntFilter<"prefixes"> | number;
    active_flag?: BoolFilter<"prefixes"> | boolean;
    delete_flag?: BoolFilter<"prefixes"> | boolean;
    modified_at?: DateTimeFilter<"prefixes"> | Date | string;
    created_at?: DateTimeFilter<"prefixes"> | Date | string;
    created_by?: StringNullableFilter<"prefixes"> | string | null;
    modified_by?: StringNullableFilter<"prefixes"> | string | null;
  };

  export type prefixesOrderByWithRelationInput = {
    id?: SortOrder;
    object_type?: SortOrder;
    name?: SortOrder;
    start?: SortOrder;
    end?: SortOrder;
    current?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
  };

  export type prefixesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      object_type?: string;
      AND?: prefixesWhereInput | prefixesWhereInput[];
      OR?: prefixesWhereInput[];
      NOT?: prefixesWhereInput | prefixesWhereInput[];
      name?: StringFilter<"prefixes"> | string;
      start?: IntFilter<"prefixes"> | number;
      end?: IntFilter<"prefixes"> | number;
      current?: IntFilter<"prefixes"> | number;
      active_flag?: BoolFilter<"prefixes"> | boolean;
      delete_flag?: BoolFilter<"prefixes"> | boolean;
      modified_at?: DateTimeFilter<"prefixes"> | Date | string;
      created_at?: DateTimeFilter<"prefixes"> | Date | string;
      created_by?: StringNullableFilter<"prefixes"> | string | null;
      modified_by?: StringNullableFilter<"prefixes"> | string | null;
    },
    "id" | "object_type"
  >;

  export type prefixesOrderByWithAggregationInput = {
    id?: SortOrder;
    object_type?: SortOrder;
    name?: SortOrder;
    start?: SortOrder;
    end?: SortOrder;
    current?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: prefixesCountOrderByAggregateInput;
    _avg?: prefixesAvgOrderByAggregateInput;
    _max?: prefixesMaxOrderByAggregateInput;
    _min?: prefixesMinOrderByAggregateInput;
    _sum?: prefixesSumOrderByAggregateInput;
  };

  export type prefixesScalarWhereWithAggregatesInput = {
    AND?: prefixesScalarWhereWithAggregatesInput | prefixesScalarWhereWithAggregatesInput[];
    OR?: prefixesScalarWhereWithAggregatesInput[];
    NOT?: prefixesScalarWhereWithAggregatesInput | prefixesScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"prefixes"> | string;
    object_type?: StringWithAggregatesFilter<"prefixes"> | string;
    name?: StringWithAggregatesFilter<"prefixes"> | string;
    start?: IntWithAggregatesFilter<"prefixes"> | number;
    end?: IntWithAggregatesFilter<"prefixes"> | number;
    current?: IntWithAggregatesFilter<"prefixes"> | number;
    active_flag?: BoolWithAggregatesFilter<"prefixes"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"prefixes"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"prefixes"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"prefixes"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"prefixes"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"prefixes"> | string | null;
  };

  export type productsWhereInput = {
    AND?: productsWhereInput | productsWhereInput[];
    OR?: productsWhereInput[];
    NOT?: productsWhereInput | productsWhereInput[];
    id?: StringFilter<"products"> | string;
    firm_id?: StringFilter<"products"> | string;
    name?: StringFilter<"products"> | string;
    code?: StringFilter<"products"> | string;
    price?: FloatFilter<"products"> | number;
    sales_price?: FloatFilter<"products"> | number;
    fine?: FloatFilter<"products"> | number;
    deposit?: FloatFilter<"products"> | number;
    description?: StringNullableFilter<"products"> | string | null;
    rental_period?: EnumPeriodFilter<"products"> | $Enums.Period;
    fine_period?: EnumPeriodFilter<"products"> | $Enums.Period;
    color?: StringNullableFilter<"products"> | string | null;
    type?: StringNullableFilter<"products"> | string | null;
    barcode?: StringNullableFilter<"products"> | string | null;
    brand?: StringNullableFilter<"products"> | string | null;
    size?: StringNullableFilter<"products"> | string | null;
    stock?: FloatFilter<"products"> | number;
    current_rented_stock?: FloatFilter<"products"> | number;
    keywords?: StringNullableListFilter<"products">;
    media?: StringNullableListFilter<"products">;
    status?: EnumStatusFilter<"products"> | $Enums.Status;
    active_flag?: BoolFilter<"products"> | boolean;
    delete_flag?: BoolFilter<"products"> | boolean;
    modified_at?: DateTimeFilter<"products"> | Date | string;
    created_at?: DateTimeFilter<"products"> | Date | string;
    created_by?: StringNullableFilter<"products"> | string | null;
    modified_by?: StringNullableFilter<"products"> | string | null;
    firm?: XOR<FirmsScalarRelationFilter, firmsWhereInput>;
  };

  export type productsOrderByWithRelationInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    name?: SortOrder;
    code?: SortOrder;
    price?: SortOrder;
    sales_price?: SortOrder;
    fine?: SortOrder;
    deposit?: SortOrder;
    description?: SortOrderInput | SortOrder;
    rental_period?: SortOrder;
    fine_period?: SortOrder;
    color?: SortOrderInput | SortOrder;
    type?: SortOrderInput | SortOrder;
    barcode?: SortOrderInput | SortOrder;
    brand?: SortOrderInput | SortOrder;
    size?: SortOrderInput | SortOrder;
    stock?: SortOrder;
    current_rented_stock?: SortOrder;
    keywords?: SortOrder;
    media?: SortOrder;
    status?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    firm?: firmsOrderByWithRelationInput;
  };

  export type productsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      code_firm_id?: productsCodeFirm_idCompoundUniqueInput;
      AND?: productsWhereInput | productsWhereInput[];
      OR?: productsWhereInput[];
      NOT?: productsWhereInput | productsWhereInput[];
      firm_id?: StringFilter<"products"> | string;
      name?: StringFilter<"products"> | string;
      code?: StringFilter<"products"> | string;
      price?: FloatFilter<"products"> | number;
      sales_price?: FloatFilter<"products"> | number;
      fine?: FloatFilter<"products"> | number;
      deposit?: FloatFilter<"products"> | number;
      description?: StringNullableFilter<"products"> | string | null;
      rental_period?: EnumPeriodFilter<"products"> | $Enums.Period;
      fine_period?: EnumPeriodFilter<"products"> | $Enums.Period;
      color?: StringNullableFilter<"products"> | string | null;
      type?: StringNullableFilter<"products"> | string | null;
      barcode?: StringNullableFilter<"products"> | string | null;
      brand?: StringNullableFilter<"products"> | string | null;
      size?: StringNullableFilter<"products"> | string | null;
      stock?: FloatFilter<"products"> | number;
      current_rented_stock?: FloatFilter<"products"> | number;
      keywords?: StringNullableListFilter<"products">;
      media?: StringNullableListFilter<"products">;
      status?: EnumStatusFilter<"products"> | $Enums.Status;
      active_flag?: BoolFilter<"products"> | boolean;
      delete_flag?: BoolFilter<"products"> | boolean;
      modified_at?: DateTimeFilter<"products"> | Date | string;
      created_at?: DateTimeFilter<"products"> | Date | string;
      created_by?: StringNullableFilter<"products"> | string | null;
      modified_by?: StringNullableFilter<"products"> | string | null;
      firm?: XOR<FirmsScalarRelationFilter, firmsWhereInput>;
    },
    "id" | "code_firm_id"
  >;

  export type productsOrderByWithAggregationInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    name?: SortOrder;
    code?: SortOrder;
    price?: SortOrder;
    sales_price?: SortOrder;
    fine?: SortOrder;
    deposit?: SortOrder;
    description?: SortOrderInput | SortOrder;
    rental_period?: SortOrder;
    fine_period?: SortOrder;
    color?: SortOrderInput | SortOrder;
    type?: SortOrderInput | SortOrder;
    barcode?: SortOrderInput | SortOrder;
    brand?: SortOrderInput | SortOrder;
    size?: SortOrderInput | SortOrder;
    stock?: SortOrder;
    current_rented_stock?: SortOrder;
    keywords?: SortOrder;
    media?: SortOrder;
    status?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: productsCountOrderByAggregateInput;
    _avg?: productsAvgOrderByAggregateInput;
    _max?: productsMaxOrderByAggregateInput;
    _min?: productsMinOrderByAggregateInput;
    _sum?: productsSumOrderByAggregateInput;
  };

  export type productsScalarWhereWithAggregatesInput = {
    AND?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[];
    OR?: productsScalarWhereWithAggregatesInput[];
    NOT?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"products"> | string;
    firm_id?: StringWithAggregatesFilter<"products"> | string;
    name?: StringWithAggregatesFilter<"products"> | string;
    code?: StringWithAggregatesFilter<"products"> | string;
    price?: FloatWithAggregatesFilter<"products"> | number;
    sales_price?: FloatWithAggregatesFilter<"products"> | number;
    fine?: FloatWithAggregatesFilter<"products"> | number;
    deposit?: FloatWithAggregatesFilter<"products"> | number;
    description?: StringNullableWithAggregatesFilter<"products"> | string | null;
    rental_period?: EnumPeriodWithAggregatesFilter<"products"> | $Enums.Period;
    fine_period?: EnumPeriodWithAggregatesFilter<"products"> | $Enums.Period;
    color?: StringNullableWithAggregatesFilter<"products"> | string | null;
    type?: StringNullableWithAggregatesFilter<"products"> | string | null;
    barcode?: StringNullableWithAggregatesFilter<"products"> | string | null;
    brand?: StringNullableWithAggregatesFilter<"products"> | string | null;
    size?: StringNullableWithAggregatesFilter<"products"> | string | null;
    stock?: FloatWithAggregatesFilter<"products"> | number;
    current_rented_stock?: FloatWithAggregatesFilter<"products"> | number;
    keywords?: StringNullableListFilter<"products">;
    media?: StringNullableListFilter<"products">;
    status?: EnumStatusWithAggregatesFilter<"products"> | $Enums.Status;
    active_flag?: BoolWithAggregatesFilter<"products"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"products"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"products"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"products"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"products"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"products"> | string | null;
  };

  export type provider_configurationsWhereInput = {
    AND?: provider_configurationsWhereInput | provider_configurationsWhereInput[];
    OR?: provider_configurationsWhereInput[];
    NOT?: provider_configurationsWhereInput | provider_configurationsWhereInput[];
    id?: StringFilter<"provider_configurations"> | string;
    provider_type?: StringFilter<"provider_configurations"> | string;
    name?: StringFilter<"provider_configurations"> | string;
    description?: StringNullableFilter<"provider_configurations"> | string | null;
    contact_number?: StringNullableFilter<"provider_configurations"> | string | null;
    email?: StringNullableFilter<"provider_configurations"> | string | null;
    identifier?: StringNullableFilter<"provider_configurations"> | string | null;
    url?: StringNullableFilter<"provider_configurations"> | string | null;
    type?: StringNullableFilter<"provider_configurations"> | string | null;
    user_name?: StringNullableFilter<"provider_configurations"> | string | null;
    password?: StringNullableFilter<"provider_configurations"> | string | null;
    client_id?: StringNullableFilter<"provider_configurations"> | string | null;
    client_password?: StringNullableFilter<"provider_configurations"> | string | null;
    api_key?: StringNullableFilter<"provider_configurations"> | string | null;
    api_secret?: StringNullableFilter<"provider_configurations"> | string | null;
    status?: StringNullableFilter<"provider_configurations"> | string | null;
    sender_details?: JsonNullableFilter<"provider_configurations">;
    outlet_reference?: StringNullableFilter<"provider_configurations"> | string | null;
    redirect_url?: StringNullableFilter<"provider_configurations"> | string | null;
    additional_properties?: JsonNullableListFilter<"provider_configurations">;
    sender_id?: StringNullableFilter<"provider_configurations"> | string | null;
    account_usage_type_id?: StringNullableFilter<"provider_configurations"> | string | null;
    access_key_id?: StringNullableFilter<"provider_configurations"> | string | null;
    secret_access_key?: StringNullableFilter<"provider_configurations"> | string | null;
    region?: StringNullableFilter<"provider_configurations"> | string | null;
    bucket?: StringNullableFilter<"provider_configurations"> | string | null;
    cdn?: StringNullableFilter<"provider_configurations"> | string | null;
    project_id?: StringNullableFilter<"provider_configurations"> | string | null;
    key_file_name?: StringNullableFilter<"provider_configurations"> | string | null;
    cloud_name?: StringNullableFilter<"provider_configurations"> | string | null;
    active_flag?: BoolFilter<"provider_configurations"> | boolean;
    delete_flag?: BoolFilter<"provider_configurations"> | boolean;
    created_by?: StringNullableFilter<"provider_configurations"> | string | null;
    created_at?: DateTimeFilter<"provider_configurations"> | Date | string;
    modified_at?: DateTimeFilter<"provider_configurations"> | Date | string;
    modified_by?: StringNullableFilter<"provider_configurations"> | string | null;
  };

  export type provider_configurationsOrderByWithRelationInput = {
    id?: SortOrder;
    provider_type?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    contact_number?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    identifier?: SortOrderInput | SortOrder;
    url?: SortOrderInput | SortOrder;
    type?: SortOrderInput | SortOrder;
    user_name?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    client_id?: SortOrderInput | SortOrder;
    client_password?: SortOrderInput | SortOrder;
    api_key?: SortOrderInput | SortOrder;
    api_secret?: SortOrderInput | SortOrder;
    status?: SortOrderInput | SortOrder;
    sender_details?: SortOrderInput | SortOrder;
    outlet_reference?: SortOrderInput | SortOrder;
    redirect_url?: SortOrderInput | SortOrder;
    additional_properties?: SortOrder;
    sender_id?: SortOrderInput | SortOrder;
    account_usage_type_id?: SortOrderInput | SortOrder;
    access_key_id?: SortOrderInput | SortOrder;
    secret_access_key?: SortOrderInput | SortOrder;
    region?: SortOrderInput | SortOrder;
    bucket?: SortOrderInput | SortOrder;
    cdn?: SortOrderInput | SortOrder;
    project_id?: SortOrderInput | SortOrder;
    key_file_name?: SortOrderInput | SortOrder;
    cloud_name?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    modified_at?: SortOrder;
    modified_by?: SortOrderInput | SortOrder;
  };

  export type provider_configurationsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name_provider_type?: provider_configurationsNameProvider_typeCompoundUniqueInput;
      AND?: provider_configurationsWhereInput | provider_configurationsWhereInput[];
      OR?: provider_configurationsWhereInput[];
      NOT?: provider_configurationsWhereInput | provider_configurationsWhereInput[];
      provider_type?: StringFilter<"provider_configurations"> | string;
      name?: StringFilter<"provider_configurations"> | string;
      description?: StringNullableFilter<"provider_configurations"> | string | null;
      contact_number?: StringNullableFilter<"provider_configurations"> | string | null;
      email?: StringNullableFilter<"provider_configurations"> | string | null;
      identifier?: StringNullableFilter<"provider_configurations"> | string | null;
      url?: StringNullableFilter<"provider_configurations"> | string | null;
      type?: StringNullableFilter<"provider_configurations"> | string | null;
      user_name?: StringNullableFilter<"provider_configurations"> | string | null;
      password?: StringNullableFilter<"provider_configurations"> | string | null;
      client_id?: StringNullableFilter<"provider_configurations"> | string | null;
      client_password?: StringNullableFilter<"provider_configurations"> | string | null;
      api_key?: StringNullableFilter<"provider_configurations"> | string | null;
      api_secret?: StringNullableFilter<"provider_configurations"> | string | null;
      status?: StringNullableFilter<"provider_configurations"> | string | null;
      sender_details?: JsonNullableFilter<"provider_configurations">;
      outlet_reference?: StringNullableFilter<"provider_configurations"> | string | null;
      redirect_url?: StringNullableFilter<"provider_configurations"> | string | null;
      additional_properties?: JsonNullableListFilter<"provider_configurations">;
      sender_id?: StringNullableFilter<"provider_configurations"> | string | null;
      account_usage_type_id?: StringNullableFilter<"provider_configurations"> | string | null;
      access_key_id?: StringNullableFilter<"provider_configurations"> | string | null;
      secret_access_key?: StringNullableFilter<"provider_configurations"> | string | null;
      region?: StringNullableFilter<"provider_configurations"> | string | null;
      bucket?: StringNullableFilter<"provider_configurations"> | string | null;
      cdn?: StringNullableFilter<"provider_configurations"> | string | null;
      project_id?: StringNullableFilter<"provider_configurations"> | string | null;
      key_file_name?: StringNullableFilter<"provider_configurations"> | string | null;
      cloud_name?: StringNullableFilter<"provider_configurations"> | string | null;
      active_flag?: BoolFilter<"provider_configurations"> | boolean;
      delete_flag?: BoolFilter<"provider_configurations"> | boolean;
      created_by?: StringNullableFilter<"provider_configurations"> | string | null;
      created_at?: DateTimeFilter<"provider_configurations"> | Date | string;
      modified_at?: DateTimeFilter<"provider_configurations"> | Date | string;
      modified_by?: StringNullableFilter<"provider_configurations"> | string | null;
    },
    "id" | "name_provider_type"
  >;

  export type provider_configurationsOrderByWithAggregationInput = {
    id?: SortOrder;
    provider_type?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    contact_number?: SortOrderInput | SortOrder;
    email?: SortOrderInput | SortOrder;
    identifier?: SortOrderInput | SortOrder;
    url?: SortOrderInput | SortOrder;
    type?: SortOrderInput | SortOrder;
    user_name?: SortOrderInput | SortOrder;
    password?: SortOrderInput | SortOrder;
    client_id?: SortOrderInput | SortOrder;
    client_password?: SortOrderInput | SortOrder;
    api_key?: SortOrderInput | SortOrder;
    api_secret?: SortOrderInput | SortOrder;
    status?: SortOrderInput | SortOrder;
    sender_details?: SortOrderInput | SortOrder;
    outlet_reference?: SortOrderInput | SortOrder;
    redirect_url?: SortOrderInput | SortOrder;
    additional_properties?: SortOrder;
    sender_id?: SortOrderInput | SortOrder;
    account_usage_type_id?: SortOrderInput | SortOrder;
    access_key_id?: SortOrderInput | SortOrder;
    secret_access_key?: SortOrderInput | SortOrder;
    region?: SortOrderInput | SortOrder;
    bucket?: SortOrderInput | SortOrder;
    cdn?: SortOrderInput | SortOrder;
    project_id?: SortOrderInput | SortOrder;
    key_file_name?: SortOrderInput | SortOrder;
    cloud_name?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    modified_at?: SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: provider_configurationsCountOrderByAggregateInput;
    _max?: provider_configurationsMaxOrderByAggregateInput;
    _min?: provider_configurationsMinOrderByAggregateInput;
  };

  export type provider_configurationsScalarWhereWithAggregatesInput = {
    AND?:
      | provider_configurationsScalarWhereWithAggregatesInput
      | provider_configurationsScalarWhereWithAggregatesInput[];
    OR?: provider_configurationsScalarWhereWithAggregatesInput[];
    NOT?:
      | provider_configurationsScalarWhereWithAggregatesInput
      | provider_configurationsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"provider_configurations"> | string;
    provider_type?: StringWithAggregatesFilter<"provider_configurations"> | string;
    name?: StringWithAggregatesFilter<"provider_configurations"> | string;
    description?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    contact_number?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    email?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    identifier?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    url?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    type?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    user_name?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    password?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    client_id?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    client_password?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    api_key?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    api_secret?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    status?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    sender_details?: JsonNullableWithAggregatesFilter<"provider_configurations">;
    outlet_reference?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    redirect_url?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    additional_properties?: JsonNullableListFilter<"provider_configurations">;
    sender_id?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    account_usage_type_id?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    access_key_id?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    secret_access_key?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    region?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    bucket?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    cdn?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    project_id?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    key_file_name?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    cloud_name?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    active_flag?: BoolWithAggregatesFilter<"provider_configurations"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"provider_configurations"> | boolean;
    created_by?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
    created_at?: DateTimeWithAggregatesFilter<"provider_configurations"> | Date | string;
    modified_at?: DateTimeWithAggregatesFilter<"provider_configurations"> | Date | string;
    modified_by?: StringNullableWithAggregatesFilter<"provider_configurations"> | string | null;
  };

  export type rentalsWhereInput = {
    AND?: rentalsWhereInput | rentalsWhereInput[];
    OR?: rentalsWhereInput[];
    NOT?: rentalsWhereInput | rentalsWhereInput[];
    id?: StringFilter<"rentals"> | string;
    user_id?: StringFilter<"rentals"> | string;
    payment_mode_id?: StringFilter<"rentals"> | string;
    invoice_id?: StringFilter<"rentals"> | string;
    invoice_date?: DateTimeFilter<"rentals"> | Date | string;
    invoice_status?: EnumInvoiceStatusFilter<"rentals"> | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFilter<"rentals"> | $Enums.Period;
    discount_amount?: FloatFilter<"rentals"> | number;
    pending_amount?: FloatFilter<"rentals"> | number;
    advance_amount?: FloatFilter<"rentals"> | number;
    deposit_amount?: FloatFilter<"rentals"> | number;
    paid_amount?: FloatFilter<"rentals"> | number;
    total_amount?: FloatFilter<"rentals"> | number;
    fine_amount?: FloatFilter<"rentals"> | number;
    rental_products?: JsonNullableListFilter<"rentals">;
    active_flag?: BoolFilter<"rentals"> | boolean;
    delete_flag?: BoolFilter<"rentals"> | boolean;
    created_by?: StringNullableFilter<"rentals"> | string | null;
    created_at?: DateTimeFilter<"rentals"> | Date | string;
    modified_at?: DateTimeFilter<"rentals"> | Date | string;
    modified_by?: StringNullableFilter<"rentals"> | string | null;
    payment_collections?: Payment_collectionsListRelationFilter;
    user?: XOR<CustomersNullableScalarRelationFilter, customersWhereInput> | null;
    payment_mode?: XOR<Payment_modesNullableScalarRelationFilter, payment_modesWhereInput> | null;
  };

  export type rentalsOrderByWithRelationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    payment_mode_id?: SortOrder;
    invoice_id?: SortOrder;
    invoice_date?: SortOrder;
    invoice_status?: SortOrder;
    rental_period?: SortOrder;
    discount_amount?: SortOrder;
    pending_amount?: SortOrder;
    advance_amount?: SortOrder;
    deposit_amount?: SortOrder;
    paid_amount?: SortOrder;
    total_amount?: SortOrder;
    fine_amount?: SortOrder;
    rental_products?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    modified_at?: SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    payment_collections?: payment_collectionsOrderByRelationAggregateInput;
    user?: customersOrderByWithRelationInput;
    payment_mode?: payment_modesOrderByWithRelationInput;
  };

  export type rentalsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: rentalsWhereInput | rentalsWhereInput[];
      OR?: rentalsWhereInput[];
      NOT?: rentalsWhereInput | rentalsWhereInput[];
      user_id?: StringFilter<"rentals"> | string;
      payment_mode_id?: StringFilter<"rentals"> | string;
      invoice_id?: StringFilter<"rentals"> | string;
      invoice_date?: DateTimeFilter<"rentals"> | Date | string;
      invoice_status?: EnumInvoiceStatusFilter<"rentals"> | $Enums.InvoiceStatus;
      rental_period?: EnumPeriodFilter<"rentals"> | $Enums.Period;
      discount_amount?: FloatFilter<"rentals"> | number;
      pending_amount?: FloatFilter<"rentals"> | number;
      advance_amount?: FloatFilter<"rentals"> | number;
      deposit_amount?: FloatFilter<"rentals"> | number;
      paid_amount?: FloatFilter<"rentals"> | number;
      total_amount?: FloatFilter<"rentals"> | number;
      fine_amount?: FloatFilter<"rentals"> | number;
      rental_products?: JsonNullableListFilter<"rentals">;
      active_flag?: BoolFilter<"rentals"> | boolean;
      delete_flag?: BoolFilter<"rentals"> | boolean;
      created_by?: StringNullableFilter<"rentals"> | string | null;
      created_at?: DateTimeFilter<"rentals"> | Date | string;
      modified_at?: DateTimeFilter<"rentals"> | Date | string;
      modified_by?: StringNullableFilter<"rentals"> | string | null;
      payment_collections?: Payment_collectionsListRelationFilter;
      user?: XOR<CustomersNullableScalarRelationFilter, customersWhereInput> | null;
      payment_mode?: XOR<Payment_modesNullableScalarRelationFilter, payment_modesWhereInput> | null;
    },
    "id"
  >;

  export type rentalsOrderByWithAggregationInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    payment_mode_id?: SortOrder;
    invoice_id?: SortOrder;
    invoice_date?: SortOrder;
    invoice_status?: SortOrder;
    rental_period?: SortOrder;
    discount_amount?: SortOrder;
    pending_amount?: SortOrder;
    advance_amount?: SortOrder;
    deposit_amount?: SortOrder;
    paid_amount?: SortOrder;
    total_amount?: SortOrder;
    fine_amount?: SortOrder;
    rental_products?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    created_at?: SortOrder;
    modified_at?: SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: rentalsCountOrderByAggregateInput;
    _avg?: rentalsAvgOrderByAggregateInput;
    _max?: rentalsMaxOrderByAggregateInput;
    _min?: rentalsMinOrderByAggregateInput;
    _sum?: rentalsSumOrderByAggregateInput;
  };

  export type rentalsScalarWhereWithAggregatesInput = {
    AND?: rentalsScalarWhereWithAggregatesInput | rentalsScalarWhereWithAggregatesInput[];
    OR?: rentalsScalarWhereWithAggregatesInput[];
    NOT?: rentalsScalarWhereWithAggregatesInput | rentalsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"rentals"> | string;
    user_id?: StringWithAggregatesFilter<"rentals"> | string;
    payment_mode_id?: StringWithAggregatesFilter<"rentals"> | string;
    invoice_id?: StringWithAggregatesFilter<"rentals"> | string;
    invoice_date?: DateTimeWithAggregatesFilter<"rentals"> | Date | string;
    invoice_status?: EnumInvoiceStatusWithAggregatesFilter<"rentals"> | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodWithAggregatesFilter<"rentals"> | $Enums.Period;
    discount_amount?: FloatWithAggregatesFilter<"rentals"> | number;
    pending_amount?: FloatWithAggregatesFilter<"rentals"> | number;
    advance_amount?: FloatWithAggregatesFilter<"rentals"> | number;
    deposit_amount?: FloatWithAggregatesFilter<"rentals"> | number;
    paid_amount?: FloatWithAggregatesFilter<"rentals"> | number;
    total_amount?: FloatWithAggregatesFilter<"rentals"> | number;
    fine_amount?: FloatWithAggregatesFilter<"rentals"> | number;
    rental_products?: JsonNullableListFilter<"rentals">;
    active_flag?: BoolWithAggregatesFilter<"rentals"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"rentals"> | boolean;
    created_by?: StringNullableWithAggregatesFilter<"rentals"> | string | null;
    created_at?: DateTimeWithAggregatesFilter<"rentals"> | Date | string;
    modified_at?: DateTimeWithAggregatesFilter<"rentals"> | Date | string;
    modified_by?: StringNullableWithAggregatesFilter<"rentals"> | string | null;
  };

  export type settingsWhereInput = {
    AND?: settingsWhereInput | settingsWhereInput[];
    OR?: settingsWhereInput[];
    NOT?: settingsWhereInput | settingsWhereInput[];
    id?: StringFilter<"settings"> | string;
    is_sms_otp_mode_live?: BoolFilter<"settings"> | boolean;
    is_email_otp_mode_live?: BoolFilter<"settings"> | boolean;
    active_flag?: BoolFilter<"settings"> | boolean;
    delete_flag?: BoolFilter<"settings"> | boolean;
    modified_at?: DateTimeFilter<"settings"> | Date | string;
    created_at?: DateTimeFilter<"settings"> | Date | string;
    created_by?: StringNullableFilter<"settings"> | string | null;
    modified_by?: StringNullableFilter<"settings"> | string | null;
  };

  export type settingsOrderByWithRelationInput = {
    id?: SortOrder;
    is_sms_otp_mode_live?: SortOrder;
    is_email_otp_mode_live?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
  };

  export type settingsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: settingsWhereInput | settingsWhereInput[];
      OR?: settingsWhereInput[];
      NOT?: settingsWhereInput | settingsWhereInput[];
      is_sms_otp_mode_live?: BoolFilter<"settings"> | boolean;
      is_email_otp_mode_live?: BoolFilter<"settings"> | boolean;
      active_flag?: BoolFilter<"settings"> | boolean;
      delete_flag?: BoolFilter<"settings"> | boolean;
      modified_at?: DateTimeFilter<"settings"> | Date | string;
      created_at?: DateTimeFilter<"settings"> | Date | string;
      created_by?: StringNullableFilter<"settings"> | string | null;
      modified_by?: StringNullableFilter<"settings"> | string | null;
    },
    "id"
  >;

  export type settingsOrderByWithAggregationInput = {
    id?: SortOrder;
    is_sms_otp_mode_live?: SortOrder;
    is_email_otp_mode_live?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: settingsCountOrderByAggregateInput;
    _max?: settingsMaxOrderByAggregateInput;
    _min?: settingsMinOrderByAggregateInput;
  };

  export type settingsScalarWhereWithAggregatesInput = {
    AND?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[];
    OR?: settingsScalarWhereWithAggregatesInput[];
    NOT?: settingsScalarWhereWithAggregatesInput | settingsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"settings"> | string;
    is_sms_otp_mode_live?: BoolWithAggregatesFilter<"settings"> | boolean;
    is_email_otp_mode_live?: BoolWithAggregatesFilter<"settings"> | boolean;
    active_flag?: BoolWithAggregatesFilter<"settings"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"settings"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"settings"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"settings"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"settings"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"settings"> | string | null;
  };

  export type subscriptionsWhereInput = {
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[];
    OR?: subscriptionsWhereInput[];
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[];
    id?: StringFilter<"subscriptions"> | string;
    name?: StringFilter<"subscriptions"> | string;
    price?: FloatFilter<"subscriptions"> | number;
    validity?: StringNullableFilter<"subscriptions"> | string | null;
    description?: StringNullableFilter<"subscriptions"> | string | null;
    active_flag?: BoolFilter<"subscriptions"> | boolean;
    delete_flag?: BoolFilter<"subscriptions"> | boolean;
    modified_at?: DateTimeFilter<"subscriptions"> | Date | string;
    created_at?: DateTimeFilter<"subscriptions"> | Date | string;
    created_by?: StringNullableFilter<"subscriptions"> | string | null;
    modified_by?: StringNullableFilter<"subscriptions"> | string | null;
  };

  export type subscriptionsOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    validity?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
  };

  export type subscriptionsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: string;
      AND?: subscriptionsWhereInput | subscriptionsWhereInput[];
      OR?: subscriptionsWhereInput[];
      NOT?: subscriptionsWhereInput | subscriptionsWhereInput[];
      price?: FloatFilter<"subscriptions"> | number;
      validity?: StringNullableFilter<"subscriptions"> | string | null;
      description?: StringNullableFilter<"subscriptions"> | string | null;
      active_flag?: BoolFilter<"subscriptions"> | boolean;
      delete_flag?: BoolFilter<"subscriptions"> | boolean;
      modified_at?: DateTimeFilter<"subscriptions"> | Date | string;
      created_at?: DateTimeFilter<"subscriptions"> | Date | string;
      created_by?: StringNullableFilter<"subscriptions"> | string | null;
      modified_by?: StringNullableFilter<"subscriptions"> | string | null;
    },
    "id" | "name"
  >;

  export type subscriptionsOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    validity?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: subscriptionsCountOrderByAggregateInput;
    _avg?: subscriptionsAvgOrderByAggregateInput;
    _max?: subscriptionsMaxOrderByAggregateInput;
    _min?: subscriptionsMinOrderByAggregateInput;
    _sum?: subscriptionsSumOrderByAggregateInput;
  };

  export type subscriptionsScalarWhereWithAggregatesInput = {
    AND?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[];
    OR?: subscriptionsScalarWhereWithAggregatesInput[];
    NOT?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"subscriptions"> | string;
    name?: StringWithAggregatesFilter<"subscriptions"> | string;
    price?: FloatWithAggregatesFilter<"subscriptions"> | number;
    validity?: StringNullableWithAggregatesFilter<"subscriptions"> | string | null;
    description?: StringNullableWithAggregatesFilter<"subscriptions"> | string | null;
    active_flag?: BoolWithAggregatesFilter<"subscriptions"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"subscriptions"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"subscriptions"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"subscriptions"> | string | null;
  };

  export type templatesWhereInput = {
    AND?: templatesWhereInput | templatesWhereInput[];
    OR?: templatesWhereInput[];
    NOT?: templatesWhereInput | templatesWhereInput[];
    id?: StringFilter<"templates"> | string;
    identifier?: StringFilter<"templates"> | string;
    type?: StringNullableFilter<"templates"> | string | null;
    template_type?: StringNullableFilter<"templates"> | string | null;
    provider_name?: StringNullableFilter<"templates"> | string | null;
    name?: StringNullableFilter<"templates"> | string | null;
    subject?: StringNullableFilter<"templates"> | string | null;
    description?: StringNullableFilter<"templates"> | string | null;
    provider_template_code?: StringNullableFilter<"templates"> | string | null;
    template?: StringNullableFilter<"templates"> | string | null;
    instruction?: StringNullableFilter<"templates"> | string | null;
    parameters?: IntNullableFilter<"templates"> | number | null;
    is_html?: BoolFilter<"templates"> | boolean;
    active_flag?: BoolFilter<"templates"> | boolean;
    delete_flag?: BoolFilter<"templates"> | boolean;
    modified_at?: DateTimeFilter<"templates"> | Date | string;
    created_at?: DateTimeFilter<"templates"> | Date | string;
    created_by?: StringNullableFilter<"templates"> | string | null;
    modified_by?: StringNullableFilter<"templates"> | string | null;
  };

  export type templatesOrderByWithRelationInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    type?: SortOrderInput | SortOrder;
    template_type?: SortOrderInput | SortOrder;
    provider_name?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    subject?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    provider_template_code?: SortOrderInput | SortOrder;
    template?: SortOrderInput | SortOrder;
    instruction?: SortOrderInput | SortOrder;
    parameters?: SortOrderInput | SortOrder;
    is_html?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
  };

  export type templatesWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      provider_name_identifier?: templatesProvider_nameIdentifierCompoundUniqueInput;
      AND?: templatesWhereInput | templatesWhereInput[];
      OR?: templatesWhereInput[];
      NOT?: templatesWhereInput | templatesWhereInput[];
      identifier?: StringFilter<"templates"> | string;
      type?: StringNullableFilter<"templates"> | string | null;
      template_type?: StringNullableFilter<"templates"> | string | null;
      provider_name?: StringNullableFilter<"templates"> | string | null;
      name?: StringNullableFilter<"templates"> | string | null;
      subject?: StringNullableFilter<"templates"> | string | null;
      description?: StringNullableFilter<"templates"> | string | null;
      provider_template_code?: StringNullableFilter<"templates"> | string | null;
      template?: StringNullableFilter<"templates"> | string | null;
      instruction?: StringNullableFilter<"templates"> | string | null;
      parameters?: IntNullableFilter<"templates"> | number | null;
      is_html?: BoolFilter<"templates"> | boolean;
      active_flag?: BoolFilter<"templates"> | boolean;
      delete_flag?: BoolFilter<"templates"> | boolean;
      modified_at?: DateTimeFilter<"templates"> | Date | string;
      created_at?: DateTimeFilter<"templates"> | Date | string;
      created_by?: StringNullableFilter<"templates"> | string | null;
      modified_by?: StringNullableFilter<"templates"> | string | null;
    },
    "id" | "provider_name_identifier"
  >;

  export type templatesOrderByWithAggregationInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    type?: SortOrderInput | SortOrder;
    template_type?: SortOrderInput | SortOrder;
    provider_name?: SortOrderInput | SortOrder;
    name?: SortOrderInput | SortOrder;
    subject?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    provider_template_code?: SortOrderInput | SortOrder;
    template?: SortOrderInput | SortOrder;
    instruction?: SortOrderInput | SortOrder;
    parameters?: SortOrderInput | SortOrder;
    is_html?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: templatesCountOrderByAggregateInput;
    _avg?: templatesAvgOrderByAggregateInput;
    _max?: templatesMaxOrderByAggregateInput;
    _min?: templatesMinOrderByAggregateInput;
    _sum?: templatesSumOrderByAggregateInput;
  };

  export type templatesScalarWhereWithAggregatesInput = {
    AND?: templatesScalarWhereWithAggregatesInput | templatesScalarWhereWithAggregatesInput[];
    OR?: templatesScalarWhereWithAggregatesInput[];
    NOT?: templatesScalarWhereWithAggregatesInput | templatesScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"templates"> | string;
    identifier?: StringWithAggregatesFilter<"templates"> | string;
    type?: StringNullableWithAggregatesFilter<"templates"> | string | null;
    template_type?: StringNullableWithAggregatesFilter<"templates"> | string | null;
    provider_name?: StringNullableWithAggregatesFilter<"templates"> | string | null;
    name?: StringNullableWithAggregatesFilter<"templates"> | string | null;
    subject?: StringNullableWithAggregatesFilter<"templates"> | string | null;
    description?: StringNullableWithAggregatesFilter<"templates"> | string | null;
    provider_template_code?: StringNullableWithAggregatesFilter<"templates"> | string | null;
    template?: StringNullableWithAggregatesFilter<"templates"> | string | null;
    instruction?: StringNullableWithAggregatesFilter<"templates"> | string | null;
    parameters?: IntNullableWithAggregatesFilter<"templates"> | number | null;
    is_html?: BoolWithAggregatesFilter<"templates"> | boolean;
    active_flag?: BoolWithAggregatesFilter<"templates"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"templates"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"templates"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"templates"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"templates"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"templates"> | string | null;
  };

  export type terms_and_conditionsWhereInput = {
    AND?: terms_and_conditionsWhereInput | terms_and_conditionsWhereInput[];
    OR?: terms_and_conditionsWhereInput[];
    NOT?: terms_and_conditionsWhereInput | terms_and_conditionsWhereInput[];
    id?: StringFilter<"terms_and_conditions"> | string;
    name?: StringFilter<"terms_and_conditions"> | string;
    firm_id?: StringFilter<"terms_and_conditions"> | string;
    description?: StringNullableFilter<"terms_and_conditions"> | string | null;
    active_flag?: BoolFilter<"terms_and_conditions"> | boolean;
    delete_flag?: BoolFilter<"terms_and_conditions"> | boolean;
    modified_at?: DateTimeFilter<"terms_and_conditions"> | Date | string;
    created_at?: DateTimeFilter<"terms_and_conditions"> | Date | string;
    created_by?: StringNullableFilter<"terms_and_conditions"> | string | null;
    modified_by?: StringNullableFilter<"terms_and_conditions"> | string | null;
    firm?: XOR<FirmsScalarRelationFilter, firmsWhereInput>;
  };

  export type terms_and_conditionsOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    firm_id?: SortOrder;
    description?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    firm?: firmsOrderByWithRelationInput;
  };

  export type terms_and_conditionsWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: terms_and_conditionsWhereInput | terms_and_conditionsWhereInput[];
      OR?: terms_and_conditionsWhereInput[];
      NOT?: terms_and_conditionsWhereInput | terms_and_conditionsWhereInput[];
      name?: StringFilter<"terms_and_conditions"> | string;
      firm_id?: StringFilter<"terms_and_conditions"> | string;
      description?: StringNullableFilter<"terms_and_conditions"> | string | null;
      active_flag?: BoolFilter<"terms_and_conditions"> | boolean;
      delete_flag?: BoolFilter<"terms_and_conditions"> | boolean;
      modified_at?: DateTimeFilter<"terms_and_conditions"> | Date | string;
      created_at?: DateTimeFilter<"terms_and_conditions"> | Date | string;
      created_by?: StringNullableFilter<"terms_and_conditions"> | string | null;
      modified_by?: StringNullableFilter<"terms_and_conditions"> | string | null;
      firm?: XOR<FirmsScalarRelationFilter, firmsWhereInput>;
    },
    "id"
  >;

  export type terms_and_conditionsOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    firm_id?: SortOrder;
    description?: SortOrderInput | SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrderInput | SortOrder;
    modified_by?: SortOrderInput | SortOrder;
    _count?: terms_and_conditionsCountOrderByAggregateInput;
    _max?: terms_and_conditionsMaxOrderByAggregateInput;
    _min?: terms_and_conditionsMinOrderByAggregateInput;
  };

  export type terms_and_conditionsScalarWhereWithAggregatesInput = {
    AND?: terms_and_conditionsScalarWhereWithAggregatesInput | terms_and_conditionsScalarWhereWithAggregatesInput[];
    OR?: terms_and_conditionsScalarWhereWithAggregatesInput[];
    NOT?: terms_and_conditionsScalarWhereWithAggregatesInput | terms_and_conditionsScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<"terms_and_conditions"> | string;
    name?: StringWithAggregatesFilter<"terms_and_conditions"> | string;
    firm_id?: StringWithAggregatesFilter<"terms_and_conditions"> | string;
    description?: StringNullableWithAggregatesFilter<"terms_and_conditions"> | string | null;
    active_flag?: BoolWithAggregatesFilter<"terms_and_conditions"> | boolean;
    delete_flag?: BoolWithAggregatesFilter<"terms_and_conditions"> | boolean;
    modified_at?: DateTimeWithAggregatesFilter<"terms_and_conditions"> | Date | string;
    created_at?: DateTimeWithAggregatesFilter<"terms_and_conditions"> | Date | string;
    created_by?: StringNullableWithAggregatesFilter<"terms_and_conditions"> | string | null;
    modified_by?: StringNullableWithAggregatesFilter<"terms_and_conditions"> | string | null;
  };

  export type adminsCreateInput = {
    id?: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: adminsCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type adminsUncheckedCreateInput = {
    id?: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: adminsCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type adminsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: adminsUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type adminsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: adminsUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type adminsCreateManyInput = {
    id?: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: adminsCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type adminsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: adminsUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type adminsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: adminsUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type blacklistsCreateInput = {
    id?: string;
    refresh_token: string;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type blacklistsUncheckedCreateInput = {
    id?: string;
    refresh_token: string;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type blacklistsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    refresh_token?: StringFieldUpdateOperationsInput | string;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type blacklistsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    refresh_token?: StringFieldUpdateOperationsInput | string;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type blacklistsCreateManyInput = {
    id?: string;
    refresh_token: string;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type blacklistsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    refresh_token?: StringFieldUpdateOperationsInput | string;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type blacklistsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    refresh_token?: StringFieldUpdateOperationsInput | string;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type customersCreateInput = {
    id?: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: customersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    firm: firmsCreateNestedOneWithoutCustomersInput;
    rentals?: rentalsCreateNestedManyWithoutUserInput;
  };

  export type customersUncheckedCreateInput = {
    id?: string;
    firm_id: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: customersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    rentals?: rentalsUncheckedCreateNestedManyWithoutUserInput;
  };

  export type customersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: customersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    firm?: firmsUpdateOneRequiredWithoutCustomersNestedInput;
    rentals?: rentalsUpdateManyWithoutUserNestedInput;
  };

  export type customersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: customersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    rentals?: rentalsUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type customersCreateManyInput = {
    id?: string;
    firm_id: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: customersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type customersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: customersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type customersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: customersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type firmsCreateInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    products?: productsCreateNestedManyWithoutFirmInput;
    terms_and_conditions?: terms_and_conditionsCreateNestedManyWithoutFirmInput;
    payment_collections?: payment_collectionsCreateNestedManyWithoutFirmInput;
    payment_modes?: payment_modesCreateNestedManyWithoutFirmInput;
    customers?: customersCreateNestedManyWithoutFirmInput;
    owners?: ownersCreateNestedManyWithoutFirmInput;
  };

  export type firmsUncheckedCreateInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    products?: productsUncheckedCreateNestedManyWithoutFirmInput;
    terms_and_conditions?: terms_and_conditionsUncheckedCreateNestedManyWithoutFirmInput;
    payment_collections?: payment_collectionsUncheckedCreateNestedManyWithoutFirmInput;
    payment_modes?: payment_modesUncheckedCreateNestedManyWithoutFirmInput;
    customers?: customersUncheckedCreateNestedManyWithoutFirmInput;
    owners?: ownersUncheckedCreateNestedManyWithoutFirmInput;
  };

  export type firmsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    products?: productsUpdateManyWithoutFirmNestedInput;
    terms_and_conditions?: terms_and_conditionsUpdateManyWithoutFirmNestedInput;
    payment_collections?: payment_collectionsUpdateManyWithoutFirmNestedInput;
    payment_modes?: payment_modesUpdateManyWithoutFirmNestedInput;
    customers?: customersUpdateManyWithoutFirmNestedInput;
    owners?: ownersUpdateManyWithoutFirmNestedInput;
  };

  export type firmsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    products?: productsUncheckedUpdateManyWithoutFirmNestedInput;
    terms_and_conditions?: terms_and_conditionsUncheckedUpdateManyWithoutFirmNestedInput;
    payment_collections?: payment_collectionsUncheckedUpdateManyWithoutFirmNestedInput;
    payment_modes?: payment_modesUncheckedUpdateManyWithoutFirmNestedInput;
    customers?: customersUncheckedUpdateManyWithoutFirmNestedInput;
    owners?: ownersUncheckedUpdateManyWithoutFirmNestedInput;
  };

  export type firmsCreateManyInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type firmsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type firmsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ownersCreateInput = {
    id?: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: ownersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    firm?: firmsCreateNestedOneWithoutOwnersInput;
  };

  export type ownersUncheckedCreateInput = {
    id?: string;
    firm_id: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: ownersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type ownersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: ownersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    firm?: firmsUpdateOneWithoutOwnersNestedInput;
  };

  export type ownersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: ownersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ownersCreateManyInput = {
    id?: string;
    firm_id: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: ownersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type ownersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: ownersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ownersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: ownersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_collectionsCreateInput = {
    id?: string;
    amount?: number;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    firm?: firmsCreateNestedOneWithoutPayment_collectionsInput;
    payment_mode?: payment_modesCreateNestedOneWithoutPayment_collectionsInput;
    rental?: rentalsCreateNestedOneWithoutPayment_collectionsInput;
  };

  export type payment_collectionsUncheckedCreateInput = {
    id?: string;
    rental_id: string;
    firm_id: string;
    payment_mode_id: string;
    amount?: number;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type payment_collectionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    firm?: firmsUpdateOneWithoutPayment_collectionsNestedInput;
    payment_mode?: payment_modesUpdateOneWithoutPayment_collectionsNestedInput;
    rental?: rentalsUpdateOneWithoutPayment_collectionsNestedInput;
  };

  export type payment_collectionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rental_id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    payment_mode_id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_collectionsCreateManyInput = {
    id?: string;
    rental_id: string;
    firm_id: string;
    payment_mode_id: string;
    amount?: number;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type payment_collectionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_collectionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rental_id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    payment_mode_id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_modesCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    firm?: firmsCreateNestedOneWithoutPayment_modesInput;
    payment_collections?: payment_collectionsCreateNestedManyWithoutPayment_modeInput;
    rentals?: rentalsCreateNestedManyWithoutPayment_modeInput;
  };

  export type payment_modesUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    firm_id?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    payment_collections?: payment_collectionsUncheckedCreateNestedManyWithoutPayment_modeInput;
    rentals?: rentalsUncheckedCreateNestedManyWithoutPayment_modeInput;
  };

  export type payment_modesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    firm?: firmsUpdateOneWithoutPayment_modesNestedInput;
    payment_collections?: payment_collectionsUpdateManyWithoutPayment_modeNestedInput;
    rentals?: rentalsUpdateManyWithoutPayment_modeNestedInput;
  };

  export type payment_modesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    firm_id?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_collections?: payment_collectionsUncheckedUpdateManyWithoutPayment_modeNestedInput;
    rentals?: rentalsUncheckedUpdateManyWithoutPayment_modeNestedInput;
  };

  export type payment_modesCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    firm_id?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type payment_modesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_modesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    firm_id?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type prefixesCreateInput = {
    id?: string;
    object_type: string;
    name: string;
    start?: number;
    end?: number;
    current?: number;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type prefixesUncheckedCreateInput = {
    id?: string;
    object_type: string;
    name: string;
    start?: number;
    end?: number;
    current?: number;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type prefixesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    object_type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    start?: IntFieldUpdateOperationsInput | number;
    end?: IntFieldUpdateOperationsInput | number;
    current?: IntFieldUpdateOperationsInput | number;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type prefixesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    object_type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    start?: IntFieldUpdateOperationsInput | number;
    end?: IntFieldUpdateOperationsInput | number;
    current?: IntFieldUpdateOperationsInput | number;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type prefixesCreateManyInput = {
    id?: string;
    object_type: string;
    name: string;
    start?: number;
    end?: number;
    current?: number;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type prefixesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    object_type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    start?: IntFieldUpdateOperationsInput | number;
    end?: IntFieldUpdateOperationsInput | number;
    current?: IntFieldUpdateOperationsInput | number;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type prefixesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    object_type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    start?: IntFieldUpdateOperationsInput | number;
    end?: IntFieldUpdateOperationsInput | number;
    current?: IntFieldUpdateOperationsInput | number;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type productsCreateInput = {
    id?: string;
    name: string;
    code: string;
    price?: number;
    sales_price?: number;
    fine?: number;
    deposit?: number;
    description?: string | null;
    rental_period?: $Enums.Period;
    fine_period?: $Enums.Period;
    color?: string | null;
    type?: string | null;
    barcode?: string | null;
    brand?: string | null;
    size?: string | null;
    stock?: number;
    current_rented_stock?: number;
    keywords?: productsCreatekeywordsInput | string[];
    media?: productsCreatemediaInput | string[];
    status?: $Enums.Status;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    firm: firmsCreateNestedOneWithoutProductsInput;
  };

  export type productsUncheckedCreateInput = {
    id?: string;
    firm_id: string;
    name: string;
    code: string;
    price?: number;
    sales_price?: number;
    fine?: number;
    deposit?: number;
    description?: string | null;
    rental_period?: $Enums.Period;
    fine_period?: $Enums.Period;
    color?: string | null;
    type?: string | null;
    barcode?: string | null;
    brand?: string | null;
    size?: string | null;
    stock?: number;
    current_rented_stock?: number;
    keywords?: productsCreatekeywordsInput | string[];
    media?: productsCreatemediaInput | string[];
    status?: $Enums.Status;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type productsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    sales_price?: FloatFieldUpdateOperationsInput | number;
    fine?: FloatFieldUpdateOperationsInput | number;
    deposit?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    fine_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    barcode?: NullableStringFieldUpdateOperationsInput | string | null;
    brand?: NullableStringFieldUpdateOperationsInput | string | null;
    size?: NullableStringFieldUpdateOperationsInput | string | null;
    stock?: FloatFieldUpdateOperationsInput | number;
    current_rented_stock?: FloatFieldUpdateOperationsInput | number;
    keywords?: productsUpdatekeywordsInput | string[];
    media?: productsUpdatemediaInput | string[];
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    firm?: firmsUpdateOneRequiredWithoutProductsNestedInput;
  };

  export type productsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    sales_price?: FloatFieldUpdateOperationsInput | number;
    fine?: FloatFieldUpdateOperationsInput | number;
    deposit?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    fine_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    barcode?: NullableStringFieldUpdateOperationsInput | string | null;
    brand?: NullableStringFieldUpdateOperationsInput | string | null;
    size?: NullableStringFieldUpdateOperationsInput | string | null;
    stock?: FloatFieldUpdateOperationsInput | number;
    current_rented_stock?: FloatFieldUpdateOperationsInput | number;
    keywords?: productsUpdatekeywordsInput | string[];
    media?: productsUpdatemediaInput | string[];
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type productsCreateManyInput = {
    id?: string;
    firm_id: string;
    name: string;
    code: string;
    price?: number;
    sales_price?: number;
    fine?: number;
    deposit?: number;
    description?: string | null;
    rental_period?: $Enums.Period;
    fine_period?: $Enums.Period;
    color?: string | null;
    type?: string | null;
    barcode?: string | null;
    brand?: string | null;
    size?: string | null;
    stock?: number;
    current_rented_stock?: number;
    keywords?: productsCreatekeywordsInput | string[];
    media?: productsCreatemediaInput | string[];
    status?: $Enums.Status;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type productsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    sales_price?: FloatFieldUpdateOperationsInput | number;
    fine?: FloatFieldUpdateOperationsInput | number;
    deposit?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    fine_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    barcode?: NullableStringFieldUpdateOperationsInput | string | null;
    brand?: NullableStringFieldUpdateOperationsInput | string | null;
    size?: NullableStringFieldUpdateOperationsInput | string | null;
    stock?: FloatFieldUpdateOperationsInput | number;
    current_rented_stock?: FloatFieldUpdateOperationsInput | number;
    keywords?: productsUpdatekeywordsInput | string[];
    media?: productsUpdatemediaInput | string[];
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type productsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    sales_price?: FloatFieldUpdateOperationsInput | number;
    fine?: FloatFieldUpdateOperationsInput | number;
    deposit?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    fine_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    barcode?: NullableStringFieldUpdateOperationsInput | string | null;
    brand?: NullableStringFieldUpdateOperationsInput | string | null;
    size?: NullableStringFieldUpdateOperationsInput | string | null;
    stock?: FloatFieldUpdateOperationsInput | number;
    current_rented_stock?: FloatFieldUpdateOperationsInput | number;
    keywords?: productsUpdatekeywordsInput | string[];
    media?: productsUpdatemediaInput | string[];
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type provider_configurationsCreateInput = {
    id?: string;
    provider_type: string;
    name: string;
    description?: string | null;
    contact_number?: string | null;
    email?: string | null;
    identifier?: string | null;
    url?: string | null;
    type?: string | null;
    user_name?: string | null;
    password?: string | null;
    client_id?: string | null;
    client_password?: string | null;
    api_key?: string | null;
    api_secret?: string | null;
    status?: string | null;
    sender_details?: NullableJsonNullValueInput | InputJsonValue;
    outlet_reference?: string | null;
    redirect_url?: string | null;
    additional_properties?: provider_configurationsCreateadditional_propertiesInput | InputJsonValue[];
    sender_id?: string | null;
    account_usage_type_id?: string | null;
    access_key_id?: string | null;
    secret_access_key?: string | null;
    region?: string | null;
    bucket?: string | null;
    cdn?: string | null;
    project_id?: string | null;
    key_file_name?: string | null;
    cloud_name?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
  };

  export type provider_configurationsUncheckedCreateInput = {
    id?: string;
    provider_type: string;
    name: string;
    description?: string | null;
    contact_number?: string | null;
    email?: string | null;
    identifier?: string | null;
    url?: string | null;
    type?: string | null;
    user_name?: string | null;
    password?: string | null;
    client_id?: string | null;
    client_password?: string | null;
    api_key?: string | null;
    api_secret?: string | null;
    status?: string | null;
    sender_details?: NullableJsonNullValueInput | InputJsonValue;
    outlet_reference?: string | null;
    redirect_url?: string | null;
    additional_properties?: provider_configurationsCreateadditional_propertiesInput | InputJsonValue[];
    sender_id?: string | null;
    account_usage_type_id?: string | null;
    access_key_id?: string | null;
    secret_access_key?: string | null;
    region?: string | null;
    bucket?: string | null;
    cdn?: string | null;
    project_id?: string | null;
    key_file_name?: string | null;
    cloud_name?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
  };

  export type provider_configurationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider_type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    identifier?: NullableStringFieldUpdateOperationsInput | string | null;
    url?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    user_name?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    client_id?: NullableStringFieldUpdateOperationsInput | string | null;
    client_password?: NullableStringFieldUpdateOperationsInput | string | null;
    api_key?: NullableStringFieldUpdateOperationsInput | string | null;
    api_secret?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    sender_details?: NullableJsonNullValueInput | InputJsonValue;
    outlet_reference?: NullableStringFieldUpdateOperationsInput | string | null;
    redirect_url?: NullableStringFieldUpdateOperationsInput | string | null;
    additional_properties?: provider_configurationsUpdateadditional_propertiesInput | InputJsonValue[];
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null;
    account_usage_type_id?: NullableStringFieldUpdateOperationsInput | string | null;
    access_key_id?: NullableStringFieldUpdateOperationsInput | string | null;
    secret_access_key?: NullableStringFieldUpdateOperationsInput | string | null;
    region?: NullableStringFieldUpdateOperationsInput | string | null;
    bucket?: NullableStringFieldUpdateOperationsInput | string | null;
    cdn?: NullableStringFieldUpdateOperationsInput | string | null;
    project_id?: NullableStringFieldUpdateOperationsInput | string | null;
    key_file_name?: NullableStringFieldUpdateOperationsInput | string | null;
    cloud_name?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type provider_configurationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider_type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    identifier?: NullableStringFieldUpdateOperationsInput | string | null;
    url?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    user_name?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    client_id?: NullableStringFieldUpdateOperationsInput | string | null;
    client_password?: NullableStringFieldUpdateOperationsInput | string | null;
    api_key?: NullableStringFieldUpdateOperationsInput | string | null;
    api_secret?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    sender_details?: NullableJsonNullValueInput | InputJsonValue;
    outlet_reference?: NullableStringFieldUpdateOperationsInput | string | null;
    redirect_url?: NullableStringFieldUpdateOperationsInput | string | null;
    additional_properties?: provider_configurationsUpdateadditional_propertiesInput | InputJsonValue[];
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null;
    account_usage_type_id?: NullableStringFieldUpdateOperationsInput | string | null;
    access_key_id?: NullableStringFieldUpdateOperationsInput | string | null;
    secret_access_key?: NullableStringFieldUpdateOperationsInput | string | null;
    region?: NullableStringFieldUpdateOperationsInput | string | null;
    bucket?: NullableStringFieldUpdateOperationsInput | string | null;
    cdn?: NullableStringFieldUpdateOperationsInput | string | null;
    project_id?: NullableStringFieldUpdateOperationsInput | string | null;
    key_file_name?: NullableStringFieldUpdateOperationsInput | string | null;
    cloud_name?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type provider_configurationsCreateManyInput = {
    id?: string;
    provider_type: string;
    name: string;
    description?: string | null;
    contact_number?: string | null;
    email?: string | null;
    identifier?: string | null;
    url?: string | null;
    type?: string | null;
    user_name?: string | null;
    password?: string | null;
    client_id?: string | null;
    client_password?: string | null;
    api_key?: string | null;
    api_secret?: string | null;
    status?: string | null;
    sender_details?: NullableJsonNullValueInput | InputJsonValue;
    outlet_reference?: string | null;
    redirect_url?: string | null;
    additional_properties?: provider_configurationsCreateadditional_propertiesInput | InputJsonValue[];
    sender_id?: string | null;
    account_usage_type_id?: string | null;
    access_key_id?: string | null;
    secret_access_key?: string | null;
    region?: string | null;
    bucket?: string | null;
    cdn?: string | null;
    project_id?: string | null;
    key_file_name?: string | null;
    cloud_name?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
  };

  export type provider_configurationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider_type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    identifier?: NullableStringFieldUpdateOperationsInput | string | null;
    url?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    user_name?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    client_id?: NullableStringFieldUpdateOperationsInput | string | null;
    client_password?: NullableStringFieldUpdateOperationsInput | string | null;
    api_key?: NullableStringFieldUpdateOperationsInput | string | null;
    api_secret?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    sender_details?: NullableJsonNullValueInput | InputJsonValue;
    outlet_reference?: NullableStringFieldUpdateOperationsInput | string | null;
    redirect_url?: NullableStringFieldUpdateOperationsInput | string | null;
    additional_properties?: provider_configurationsUpdateadditional_propertiesInput | InputJsonValue[];
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null;
    account_usage_type_id?: NullableStringFieldUpdateOperationsInput | string | null;
    access_key_id?: NullableStringFieldUpdateOperationsInput | string | null;
    secret_access_key?: NullableStringFieldUpdateOperationsInput | string | null;
    region?: NullableStringFieldUpdateOperationsInput | string | null;
    bucket?: NullableStringFieldUpdateOperationsInput | string | null;
    cdn?: NullableStringFieldUpdateOperationsInput | string | null;
    project_id?: NullableStringFieldUpdateOperationsInput | string | null;
    key_file_name?: NullableStringFieldUpdateOperationsInput | string | null;
    cloud_name?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type provider_configurationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider_type?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    identifier?: NullableStringFieldUpdateOperationsInput | string | null;
    url?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    user_name?: NullableStringFieldUpdateOperationsInput | string | null;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    client_id?: NullableStringFieldUpdateOperationsInput | string | null;
    client_password?: NullableStringFieldUpdateOperationsInput | string | null;
    api_key?: NullableStringFieldUpdateOperationsInput | string | null;
    api_secret?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: NullableStringFieldUpdateOperationsInput | string | null;
    sender_details?: NullableJsonNullValueInput | InputJsonValue;
    outlet_reference?: NullableStringFieldUpdateOperationsInput | string | null;
    redirect_url?: NullableStringFieldUpdateOperationsInput | string | null;
    additional_properties?: provider_configurationsUpdateadditional_propertiesInput | InputJsonValue[];
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null;
    account_usage_type_id?: NullableStringFieldUpdateOperationsInput | string | null;
    access_key_id?: NullableStringFieldUpdateOperationsInput | string | null;
    secret_access_key?: NullableStringFieldUpdateOperationsInput | string | null;
    region?: NullableStringFieldUpdateOperationsInput | string | null;
    bucket?: NullableStringFieldUpdateOperationsInput | string | null;
    cdn?: NullableStringFieldUpdateOperationsInput | string | null;
    project_id?: NullableStringFieldUpdateOperationsInput | string | null;
    key_file_name?: NullableStringFieldUpdateOperationsInput | string | null;
    cloud_name?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type rentalsCreateInput = {
    id?: string;
    invoice_id: string;
    invoice_date?: Date | string;
    invoice_status?: $Enums.InvoiceStatus;
    rental_period?: $Enums.Period;
    discount_amount?: number;
    pending_amount?: number;
    advance_amount?: number;
    deposit_amount?: number;
    paid_amount?: number;
    total_amount?: number;
    fine_amount?: number;
    rental_products?: rentalsCreaterental_productsInput | InputJsonValue[];
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
    payment_collections?: payment_collectionsCreateNestedManyWithoutRentalInput;
    user?: customersCreateNestedOneWithoutRentalsInput;
    payment_mode?: payment_modesCreateNestedOneWithoutRentalsInput;
  };

  export type rentalsUncheckedCreateInput = {
    id?: string;
    user_id: string;
    payment_mode_id: string;
    invoice_id: string;
    invoice_date?: Date | string;
    invoice_status?: $Enums.InvoiceStatus;
    rental_period?: $Enums.Period;
    discount_amount?: number;
    pending_amount?: number;
    advance_amount?: number;
    deposit_amount?: number;
    paid_amount?: number;
    total_amount?: number;
    fine_amount?: number;
    rental_products?: rentalsCreaterental_productsInput | InputJsonValue[];
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
    payment_collections?: payment_collectionsUncheckedCreateNestedManyWithoutRentalInput;
  };

  export type rentalsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoice_id?: StringFieldUpdateOperationsInput | string;
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice_status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    discount_amount?: FloatFieldUpdateOperationsInput | number;
    pending_amount?: FloatFieldUpdateOperationsInput | number;
    advance_amount?: FloatFieldUpdateOperationsInput | number;
    deposit_amount?: FloatFieldUpdateOperationsInput | number;
    paid_amount?: FloatFieldUpdateOperationsInput | number;
    total_amount?: FloatFieldUpdateOperationsInput | number;
    fine_amount?: FloatFieldUpdateOperationsInput | number;
    rental_products?: rentalsUpdaterental_productsInput | InputJsonValue[];
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_collections?: payment_collectionsUpdateManyWithoutRentalNestedInput;
    user?: customersUpdateOneWithoutRentalsNestedInput;
    payment_mode?: payment_modesUpdateOneWithoutRentalsNestedInput;
  };

  export type rentalsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: StringFieldUpdateOperationsInput | string;
    payment_mode_id?: StringFieldUpdateOperationsInput | string;
    invoice_id?: StringFieldUpdateOperationsInput | string;
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice_status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    discount_amount?: FloatFieldUpdateOperationsInput | number;
    pending_amount?: FloatFieldUpdateOperationsInput | number;
    advance_amount?: FloatFieldUpdateOperationsInput | number;
    deposit_amount?: FloatFieldUpdateOperationsInput | number;
    paid_amount?: FloatFieldUpdateOperationsInput | number;
    total_amount?: FloatFieldUpdateOperationsInput | number;
    fine_amount?: FloatFieldUpdateOperationsInput | number;
    rental_products?: rentalsUpdaterental_productsInput | InputJsonValue[];
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_collections?: payment_collectionsUncheckedUpdateManyWithoutRentalNestedInput;
  };

  export type rentalsCreateManyInput = {
    id?: string;
    user_id: string;
    payment_mode_id: string;
    invoice_id: string;
    invoice_date?: Date | string;
    invoice_status?: $Enums.InvoiceStatus;
    rental_period?: $Enums.Period;
    discount_amount?: number;
    pending_amount?: number;
    advance_amount?: number;
    deposit_amount?: number;
    paid_amount?: number;
    total_amount?: number;
    fine_amount?: number;
    rental_products?: rentalsCreaterental_productsInput | InputJsonValue[];
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
  };

  export type rentalsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoice_id?: StringFieldUpdateOperationsInput | string;
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice_status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    discount_amount?: FloatFieldUpdateOperationsInput | number;
    pending_amount?: FloatFieldUpdateOperationsInput | number;
    advance_amount?: FloatFieldUpdateOperationsInput | number;
    deposit_amount?: FloatFieldUpdateOperationsInput | number;
    paid_amount?: FloatFieldUpdateOperationsInput | number;
    total_amount?: FloatFieldUpdateOperationsInput | number;
    fine_amount?: FloatFieldUpdateOperationsInput | number;
    rental_products?: rentalsUpdaterental_productsInput | InputJsonValue[];
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type rentalsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: StringFieldUpdateOperationsInput | string;
    payment_mode_id?: StringFieldUpdateOperationsInput | string;
    invoice_id?: StringFieldUpdateOperationsInput | string;
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice_status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    discount_amount?: FloatFieldUpdateOperationsInput | number;
    pending_amount?: FloatFieldUpdateOperationsInput | number;
    advance_amount?: FloatFieldUpdateOperationsInput | number;
    deposit_amount?: FloatFieldUpdateOperationsInput | number;
    paid_amount?: FloatFieldUpdateOperationsInput | number;
    total_amount?: FloatFieldUpdateOperationsInput | number;
    fine_amount?: FloatFieldUpdateOperationsInput | number;
    rental_products?: rentalsUpdaterental_productsInput | InputJsonValue[];
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type settingsCreateInput = {
    id?: string;
    is_sms_otp_mode_live?: boolean;
    is_email_otp_mode_live?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type settingsUncheckedCreateInput = {
    id?: string;
    is_sms_otp_mode_live?: boolean;
    is_email_otp_mode_live?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type settingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    is_sms_otp_mode_live?: BoolFieldUpdateOperationsInput | boolean;
    is_email_otp_mode_live?: BoolFieldUpdateOperationsInput | boolean;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type settingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    is_sms_otp_mode_live?: BoolFieldUpdateOperationsInput | boolean;
    is_email_otp_mode_live?: BoolFieldUpdateOperationsInput | boolean;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type settingsCreateManyInput = {
    id?: string;
    is_sms_otp_mode_live?: boolean;
    is_email_otp_mode_live?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type settingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    is_sms_otp_mode_live?: BoolFieldUpdateOperationsInput | boolean;
    is_email_otp_mode_live?: BoolFieldUpdateOperationsInput | boolean;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type settingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    is_sms_otp_mode_live?: BoolFieldUpdateOperationsInput | boolean;
    is_email_otp_mode_live?: BoolFieldUpdateOperationsInput | boolean;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type subscriptionsCreateInput = {
    id?: string;
    name: string;
    price?: number;
    validity?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type subscriptionsUncheckedCreateInput = {
    id?: string;
    name: string;
    price?: number;
    validity?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type subscriptionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    validity?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type subscriptionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    validity?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type subscriptionsCreateManyInput = {
    id?: string;
    name: string;
    price?: number;
    validity?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type subscriptionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    validity?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type subscriptionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    validity?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type templatesCreateInput = {
    id?: string;
    identifier: string;
    type?: string | null;
    template_type?: string | null;
    provider_name?: string | null;
    name?: string | null;
    subject?: string | null;
    description?: string | null;
    provider_template_code?: string | null;
    template?: string | null;
    instruction?: string | null;
    parameters?: number | null;
    is_html?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type templatesUncheckedCreateInput = {
    id?: string;
    identifier: string;
    type?: string | null;
    template_type?: string | null;
    provider_name?: string | null;
    name?: string | null;
    subject?: string | null;
    description?: string | null;
    provider_template_code?: string | null;
    template?: string | null;
    instruction?: string | null;
    parameters?: number | null;
    is_html?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type templatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    template_type?: NullableStringFieldUpdateOperationsInput | string | null;
    provider_name?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    provider_template_code?: NullableStringFieldUpdateOperationsInput | string | null;
    template?: NullableStringFieldUpdateOperationsInput | string | null;
    instruction?: NullableStringFieldUpdateOperationsInput | string | null;
    parameters?: NullableIntFieldUpdateOperationsInput | number | null;
    is_html?: BoolFieldUpdateOperationsInput | boolean;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type templatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    template_type?: NullableStringFieldUpdateOperationsInput | string | null;
    provider_name?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    provider_template_code?: NullableStringFieldUpdateOperationsInput | string | null;
    template?: NullableStringFieldUpdateOperationsInput | string | null;
    instruction?: NullableStringFieldUpdateOperationsInput | string | null;
    parameters?: NullableIntFieldUpdateOperationsInput | number | null;
    is_html?: BoolFieldUpdateOperationsInput | boolean;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type templatesCreateManyInput = {
    id?: string;
    identifier: string;
    type?: string | null;
    template_type?: string | null;
    provider_name?: string | null;
    name?: string | null;
    subject?: string | null;
    description?: string | null;
    provider_template_code?: string | null;
    template?: string | null;
    instruction?: string | null;
    parameters?: number | null;
    is_html?: boolean;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type templatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    template_type?: NullableStringFieldUpdateOperationsInput | string | null;
    provider_name?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    provider_template_code?: NullableStringFieldUpdateOperationsInput | string | null;
    template?: NullableStringFieldUpdateOperationsInput | string | null;
    instruction?: NullableStringFieldUpdateOperationsInput | string | null;
    parameters?: NullableIntFieldUpdateOperationsInput | number | null;
    is_html?: BoolFieldUpdateOperationsInput | boolean;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type templatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    identifier?: StringFieldUpdateOperationsInput | string;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    template_type?: NullableStringFieldUpdateOperationsInput | string | null;
    provider_name?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    subject?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    provider_template_code?: NullableStringFieldUpdateOperationsInput | string | null;
    template?: NullableStringFieldUpdateOperationsInput | string | null;
    instruction?: NullableStringFieldUpdateOperationsInput | string | null;
    parameters?: NullableIntFieldUpdateOperationsInput | number | null;
    is_html?: BoolFieldUpdateOperationsInput | boolean;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type terms_and_conditionsCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    firm: firmsCreateNestedOneWithoutTerms_and_conditionsInput;
  };

  export type terms_and_conditionsUncheckedCreateInput = {
    id?: string;
    name: string;
    firm_id: string;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type terms_and_conditionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    firm?: firmsUpdateOneRequiredWithoutTerms_and_conditionsNestedInput;
  };

  export type terms_and_conditionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type terms_and_conditionsCreateManyInput = {
    id?: string;
    name: string;
    firm_id: string;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type terms_and_conditionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type terms_and_conditionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type adminsCountOrderByAggregateInput = {
    id?: SortOrder;
    full_name?: SortOrder;
    mobile?: SortOrder;
    email?: SortOrder;
    image?: SortOrder;
    username?: SortOrder;
    alternate_mobile?: SortOrder;
    address?: SortOrder;
    documents?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    country?: SortOrder;
    pin_code?: SortOrder;
    adhaar_number?: SortOrder;
    driving_license_number?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type adminsMaxOrderByAggregateInput = {
    id?: SortOrder;
    full_name?: SortOrder;
    mobile?: SortOrder;
    email?: SortOrder;
    image?: SortOrder;
    username?: SortOrder;
    alternate_mobile?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    country?: SortOrder;
    pin_code?: SortOrder;
    adhaar_number?: SortOrder;
    driving_license_number?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type adminsMinOrderByAggregateInput = {
    id?: SortOrder;
    full_name?: SortOrder;
    mobile?: SortOrder;
    email?: SortOrder;
    image?: SortOrder;
    username?: SortOrder;
    alternate_mobile?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    country?: SortOrder;
    pin_code?: SortOrder;
    adhaar_number?: SortOrder;
    driving_license_number?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type blacklistsCountOrderByAggregateInput = {
    id?: SortOrder;
    refresh_token?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type blacklistsMaxOrderByAggregateInput = {
    id?: SortOrder;
    refresh_token?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type blacklistsMinOrderByAggregateInput = {
    id?: SortOrder;
    refresh_token?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type FirmsScalarRelationFilter = {
    is?: firmsWhereInput;
    isNot?: firmsWhereInput;
  };

  export type RentalsListRelationFilter = {
    every?: rentalsWhereInput;
    some?: rentalsWhereInput;
    none?: rentalsWhereInput;
  };

  export type rentalsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type customersCountOrderByAggregateInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    full_name?: SortOrder;
    mobile?: SortOrder;
    email?: SortOrder;
    image?: SortOrder;
    username?: SortOrder;
    alternate_mobile?: SortOrder;
    address?: SortOrder;
    documents?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    country?: SortOrder;
    pin_code?: SortOrder;
    adhaar_number?: SortOrder;
    driving_license_number?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type customersMaxOrderByAggregateInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    full_name?: SortOrder;
    mobile?: SortOrder;
    email?: SortOrder;
    image?: SortOrder;
    username?: SortOrder;
    alternate_mobile?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    country?: SortOrder;
    pin_code?: SortOrder;
    adhaar_number?: SortOrder;
    driving_license_number?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type customersMinOrderByAggregateInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    full_name?: SortOrder;
    mobile?: SortOrder;
    email?: SortOrder;
    image?: SortOrder;
    username?: SortOrder;
    alternate_mobile?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    country?: SortOrder;
    pin_code?: SortOrder;
    adhaar_number?: SortOrder;
    driving_license_number?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type ProductsListRelationFilter = {
    every?: productsWhereInput;
    some?: productsWhereInput;
    none?: productsWhereInput;
  };

  export type Terms_and_conditionsListRelationFilter = {
    every?: terms_and_conditionsWhereInput;
    some?: terms_and_conditionsWhereInput;
    none?: terms_and_conditionsWhereInput;
  };

  export type Payment_collectionsListRelationFilter = {
    every?: payment_collectionsWhereInput;
    some?: payment_collectionsWhereInput;
    none?: payment_collectionsWhereInput;
  };

  export type Payment_modesListRelationFilter = {
    every?: payment_modesWhereInput;
    some?: payment_modesWhereInput;
    none?: payment_modesWhereInput;
  };

  export type CustomersListRelationFilter = {
    every?: customersWhereInput;
    some?: customersWhereInput;
    none?: customersWhereInput;
  };

  export type OwnersListRelationFilter = {
    every?: ownersWhereInput;
    some?: ownersWhereInput;
    none?: ownersWhereInput;
  };

  export type productsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type terms_and_conditionsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type payment_collectionsOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type payment_modesOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type customersOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ownersOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type firmsCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    mobile?: SortOrder;
    email?: SortOrder;
    media?: SortOrder;
    gst_number?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    country?: SortOrder;
    pin_code?: SortOrder;
    description?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type firmsMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    mobile?: SortOrder;
    email?: SortOrder;
    gst_number?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    country?: SortOrder;
    pin_code?: SortOrder;
    description?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type firmsMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    mobile?: SortOrder;
    email?: SortOrder;
    gst_number?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    country?: SortOrder;
    pin_code?: SortOrder;
    description?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type FirmsNullableScalarRelationFilter = {
    is?: firmsWhereInput | null;
    isNot?: firmsWhereInput | null;
  };

  export type ownersCountOrderByAggregateInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    full_name?: SortOrder;
    mobile?: SortOrder;
    email?: SortOrder;
    image?: SortOrder;
    username?: SortOrder;
    alternate_mobile?: SortOrder;
    address?: SortOrder;
    documents?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    country?: SortOrder;
    pin_code?: SortOrder;
    adhaar_number?: SortOrder;
    driving_license_number?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type ownersMaxOrderByAggregateInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    full_name?: SortOrder;
    mobile?: SortOrder;
    email?: SortOrder;
    image?: SortOrder;
    username?: SortOrder;
    alternate_mobile?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    country?: SortOrder;
    pin_code?: SortOrder;
    adhaar_number?: SortOrder;
    driving_license_number?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type ownersMinOrderByAggregateInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    full_name?: SortOrder;
    mobile?: SortOrder;
    email?: SortOrder;
    image?: SortOrder;
    username?: SortOrder;
    alternate_mobile?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    state?: SortOrder;
    country?: SortOrder;
    pin_code?: SortOrder;
    adhaar_number?: SortOrder;
    driving_license_number?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type Payment_modesNullableScalarRelationFilter = {
    is?: payment_modesWhereInput | null;
    isNot?: payment_modesWhereInput | null;
  };

  export type RentalsNullableScalarRelationFilter = {
    is?: rentalsWhereInput | null;
    isNot?: rentalsWhereInput | null;
  };

  export type payment_collectionsCountOrderByAggregateInput = {
    id?: SortOrder;
    rental_id?: SortOrder;
    firm_id?: SortOrder;
    payment_mode_id?: SortOrder;
    amount?: SortOrder;
    description?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type payment_collectionsAvgOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type payment_collectionsMaxOrderByAggregateInput = {
    id?: SortOrder;
    rental_id?: SortOrder;
    firm_id?: SortOrder;
    payment_mode_id?: SortOrder;
    amount?: SortOrder;
    description?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type payment_collectionsMinOrderByAggregateInput = {
    id?: SortOrder;
    rental_id?: SortOrder;
    firm_id?: SortOrder;
    payment_mode_id?: SortOrder;
    amount?: SortOrder;
    description?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type payment_collectionsSumOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type payment_modesCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    firm_id?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type payment_modesMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    firm_id?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type payment_modesMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    firm_id?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type prefixesCountOrderByAggregateInput = {
    id?: SortOrder;
    object_type?: SortOrder;
    name?: SortOrder;
    start?: SortOrder;
    end?: SortOrder;
    current?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type prefixesAvgOrderByAggregateInput = {
    start?: SortOrder;
    end?: SortOrder;
    current?: SortOrder;
  };

  export type prefixesMaxOrderByAggregateInput = {
    id?: SortOrder;
    object_type?: SortOrder;
    name?: SortOrder;
    start?: SortOrder;
    end?: SortOrder;
    current?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type prefixesMinOrderByAggregateInput = {
    id?: SortOrder;
    object_type?: SortOrder;
    name?: SortOrder;
    start?: SortOrder;
    end?: SortOrder;
    current?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type prefixesSumOrderByAggregateInput = {
    start?: SortOrder;
    end?: SortOrder;
    current?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type EnumPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.Period | EnumPeriodFieldRefInput<$PrismaModel>;
    in?: $Enums.Period[] | ListEnumPeriodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Period[] | ListEnumPeriodFieldRefInput<$PrismaModel>;
    not?: NestedEnumPeriodFilter<$PrismaModel> | $Enums.Period;
  };

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status;
  };

  export type productsCodeFirm_idCompoundUniqueInput = {
    code: string;
    firm_id: string;
  };

  export type productsCountOrderByAggregateInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    name?: SortOrder;
    code?: SortOrder;
    price?: SortOrder;
    sales_price?: SortOrder;
    fine?: SortOrder;
    deposit?: SortOrder;
    description?: SortOrder;
    rental_period?: SortOrder;
    fine_period?: SortOrder;
    color?: SortOrder;
    type?: SortOrder;
    barcode?: SortOrder;
    brand?: SortOrder;
    size?: SortOrder;
    stock?: SortOrder;
    current_rented_stock?: SortOrder;
    keywords?: SortOrder;
    media?: SortOrder;
    status?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type productsAvgOrderByAggregateInput = {
    price?: SortOrder;
    sales_price?: SortOrder;
    fine?: SortOrder;
    deposit?: SortOrder;
    stock?: SortOrder;
    current_rented_stock?: SortOrder;
  };

  export type productsMaxOrderByAggregateInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    name?: SortOrder;
    code?: SortOrder;
    price?: SortOrder;
    sales_price?: SortOrder;
    fine?: SortOrder;
    deposit?: SortOrder;
    description?: SortOrder;
    rental_period?: SortOrder;
    fine_period?: SortOrder;
    color?: SortOrder;
    type?: SortOrder;
    barcode?: SortOrder;
    brand?: SortOrder;
    size?: SortOrder;
    stock?: SortOrder;
    current_rented_stock?: SortOrder;
    status?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type productsMinOrderByAggregateInput = {
    id?: SortOrder;
    firm_id?: SortOrder;
    name?: SortOrder;
    code?: SortOrder;
    price?: SortOrder;
    sales_price?: SortOrder;
    fine?: SortOrder;
    deposit?: SortOrder;
    description?: SortOrder;
    rental_period?: SortOrder;
    fine_period?: SortOrder;
    color?: SortOrder;
    type?: SortOrder;
    barcode?: SortOrder;
    brand?: SortOrder;
    size?: SortOrder;
    stock?: SortOrder;
    current_rented_stock?: SortOrder;
    status?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type productsSumOrderByAggregateInput = {
    price?: SortOrder;
    sales_price?: SortOrder;
    fine?: SortOrder;
    deposit?: SortOrder;
    stock?: SortOrder;
    current_rented_stock?: SortOrder;
  };

  export type EnumPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Period | EnumPeriodFieldRefInput<$PrismaModel>;
    in?: $Enums.Period[] | ListEnumPeriodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Period[] | ListEnumPeriodFieldRefInput<$PrismaModel>;
    not?: NestedEnumPeriodWithAggregatesFilter<$PrismaModel> | $Enums.Period;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPeriodFilter<$PrismaModel>;
    _max?: NestedEnumPeriodFilter<$PrismaModel>;
  };

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumStatusFilter<$PrismaModel>;
    _max?: NestedEnumStatusFilter<$PrismaModel>;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, "path">>;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };
  export type JsonNullableListFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableListFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, "path">>;

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null;
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>;
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type provider_configurationsNameProvider_typeCompoundUniqueInput = {
    name: string;
    provider_type: string;
  };

  export type provider_configurationsCountOrderByAggregateInput = {
    id?: SortOrder;
    provider_type?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    contact_number?: SortOrder;
    email?: SortOrder;
    identifier?: SortOrder;
    url?: SortOrder;
    type?: SortOrder;
    user_name?: SortOrder;
    password?: SortOrder;
    client_id?: SortOrder;
    client_password?: SortOrder;
    api_key?: SortOrder;
    api_secret?: SortOrder;
    status?: SortOrder;
    sender_details?: SortOrder;
    outlet_reference?: SortOrder;
    redirect_url?: SortOrder;
    additional_properties?: SortOrder;
    sender_id?: SortOrder;
    account_usage_type_id?: SortOrder;
    access_key_id?: SortOrder;
    secret_access_key?: SortOrder;
    region?: SortOrder;
    bucket?: SortOrder;
    cdn?: SortOrder;
    project_id?: SortOrder;
    key_file_name?: SortOrder;
    cloud_name?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    created_by?: SortOrder;
    created_at?: SortOrder;
    modified_at?: SortOrder;
    modified_by?: SortOrder;
  };

  export type provider_configurationsMaxOrderByAggregateInput = {
    id?: SortOrder;
    provider_type?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    contact_number?: SortOrder;
    email?: SortOrder;
    identifier?: SortOrder;
    url?: SortOrder;
    type?: SortOrder;
    user_name?: SortOrder;
    password?: SortOrder;
    client_id?: SortOrder;
    client_password?: SortOrder;
    api_key?: SortOrder;
    api_secret?: SortOrder;
    status?: SortOrder;
    outlet_reference?: SortOrder;
    redirect_url?: SortOrder;
    sender_id?: SortOrder;
    account_usage_type_id?: SortOrder;
    access_key_id?: SortOrder;
    secret_access_key?: SortOrder;
    region?: SortOrder;
    bucket?: SortOrder;
    cdn?: SortOrder;
    project_id?: SortOrder;
    key_file_name?: SortOrder;
    cloud_name?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    created_by?: SortOrder;
    created_at?: SortOrder;
    modified_at?: SortOrder;
    modified_by?: SortOrder;
  };

  export type provider_configurationsMinOrderByAggregateInput = {
    id?: SortOrder;
    provider_type?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    contact_number?: SortOrder;
    email?: SortOrder;
    identifier?: SortOrder;
    url?: SortOrder;
    type?: SortOrder;
    user_name?: SortOrder;
    password?: SortOrder;
    client_id?: SortOrder;
    client_password?: SortOrder;
    api_key?: SortOrder;
    api_secret?: SortOrder;
    status?: SortOrder;
    outlet_reference?: SortOrder;
    redirect_url?: SortOrder;
    sender_id?: SortOrder;
    account_usage_type_id?: SortOrder;
    access_key_id?: SortOrder;
    secret_access_key?: SortOrder;
    region?: SortOrder;
    bucket?: SortOrder;
    cdn?: SortOrder;
    project_id?: SortOrder;
    key_file_name?: SortOrder;
    cloud_name?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    created_by?: SortOrder;
    created_at?: SortOrder;
    modified_at?: SortOrder;
    modified_by?: SortOrder;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, "path">
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, "path">>;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus;
  };

  export type CustomersNullableScalarRelationFilter = {
    is?: customersWhereInput | null;
    isNot?: customersWhereInput | null;
  };

  export type rentalsCountOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    payment_mode_id?: SortOrder;
    invoice_id?: SortOrder;
    invoice_date?: SortOrder;
    invoice_status?: SortOrder;
    rental_period?: SortOrder;
    discount_amount?: SortOrder;
    pending_amount?: SortOrder;
    advance_amount?: SortOrder;
    deposit_amount?: SortOrder;
    paid_amount?: SortOrder;
    total_amount?: SortOrder;
    fine_amount?: SortOrder;
    rental_products?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    created_by?: SortOrder;
    created_at?: SortOrder;
    modified_at?: SortOrder;
    modified_by?: SortOrder;
  };

  export type rentalsAvgOrderByAggregateInput = {
    discount_amount?: SortOrder;
    pending_amount?: SortOrder;
    advance_amount?: SortOrder;
    deposit_amount?: SortOrder;
    paid_amount?: SortOrder;
    total_amount?: SortOrder;
    fine_amount?: SortOrder;
  };

  export type rentalsMaxOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    payment_mode_id?: SortOrder;
    invoice_id?: SortOrder;
    invoice_date?: SortOrder;
    invoice_status?: SortOrder;
    rental_period?: SortOrder;
    discount_amount?: SortOrder;
    pending_amount?: SortOrder;
    advance_amount?: SortOrder;
    deposit_amount?: SortOrder;
    paid_amount?: SortOrder;
    total_amount?: SortOrder;
    fine_amount?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    created_by?: SortOrder;
    created_at?: SortOrder;
    modified_at?: SortOrder;
    modified_by?: SortOrder;
  };

  export type rentalsMinOrderByAggregateInput = {
    id?: SortOrder;
    user_id?: SortOrder;
    payment_mode_id?: SortOrder;
    invoice_id?: SortOrder;
    invoice_date?: SortOrder;
    invoice_status?: SortOrder;
    rental_period?: SortOrder;
    discount_amount?: SortOrder;
    pending_amount?: SortOrder;
    advance_amount?: SortOrder;
    deposit_amount?: SortOrder;
    paid_amount?: SortOrder;
    total_amount?: SortOrder;
    fine_amount?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    created_by?: SortOrder;
    created_at?: SortOrder;
    modified_at?: SortOrder;
    modified_by?: SortOrder;
  };

  export type rentalsSumOrderByAggregateInput = {
    discount_amount?: SortOrder;
    pending_amount?: SortOrder;
    advance_amount?: SortOrder;
    deposit_amount?: SortOrder;
    paid_amount?: SortOrder;
    total_amount?: SortOrder;
    fine_amount?: SortOrder;
  };

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>;
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>;
  };

  export type settingsCountOrderByAggregateInput = {
    id?: SortOrder;
    is_sms_otp_mode_live?: SortOrder;
    is_email_otp_mode_live?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type settingsMaxOrderByAggregateInput = {
    id?: SortOrder;
    is_sms_otp_mode_live?: SortOrder;
    is_email_otp_mode_live?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type settingsMinOrderByAggregateInput = {
    id?: SortOrder;
    is_sms_otp_mode_live?: SortOrder;
    is_email_otp_mode_live?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type subscriptionsCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    validity?: SortOrder;
    description?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type subscriptionsAvgOrderByAggregateInput = {
    price?: SortOrder;
  };

  export type subscriptionsMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    validity?: SortOrder;
    description?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type subscriptionsMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    price?: SortOrder;
    validity?: SortOrder;
    description?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type subscriptionsSumOrderByAggregateInput = {
    price?: SortOrder;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type templatesProvider_nameIdentifierCompoundUniqueInput = {
    provider_name: string;
    identifier: string;
  };

  export type templatesCountOrderByAggregateInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    type?: SortOrder;
    template_type?: SortOrder;
    provider_name?: SortOrder;
    name?: SortOrder;
    subject?: SortOrder;
    description?: SortOrder;
    provider_template_code?: SortOrder;
    template?: SortOrder;
    instruction?: SortOrder;
    parameters?: SortOrder;
    is_html?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type templatesAvgOrderByAggregateInput = {
    parameters?: SortOrder;
  };

  export type templatesMaxOrderByAggregateInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    type?: SortOrder;
    template_type?: SortOrder;
    provider_name?: SortOrder;
    name?: SortOrder;
    subject?: SortOrder;
    description?: SortOrder;
    provider_template_code?: SortOrder;
    template?: SortOrder;
    instruction?: SortOrder;
    parameters?: SortOrder;
    is_html?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type templatesMinOrderByAggregateInput = {
    id?: SortOrder;
    identifier?: SortOrder;
    type?: SortOrder;
    template_type?: SortOrder;
    provider_name?: SortOrder;
    name?: SortOrder;
    subject?: SortOrder;
    description?: SortOrder;
    provider_template_code?: SortOrder;
    template?: SortOrder;
    instruction?: SortOrder;
    parameters?: SortOrder;
    is_html?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type templatesSumOrderByAggregateInput = {
    parameters?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type terms_and_conditionsCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    firm_id?: SortOrder;
    description?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type terms_and_conditionsMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    firm_id?: SortOrder;
    description?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type terms_and_conditionsMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    firm_id?: SortOrder;
    description?: SortOrder;
    active_flag?: SortOrder;
    delete_flag?: SortOrder;
    modified_at?: SortOrder;
    created_at?: SortOrder;
    created_by?: SortOrder;
    modified_by?: SortOrder;
  };

  export type adminsCreatedocumentsInput = {
    set: string[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type adminsUpdatedocumentsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type customersCreatedocumentsInput = {
    set: string[];
  };

  export type firmsCreateNestedOneWithoutCustomersInput = {
    create?: XOR<firmsCreateWithoutCustomersInput, firmsUncheckedCreateWithoutCustomersInput>;
    connectOrCreate?: firmsCreateOrConnectWithoutCustomersInput;
    connect?: firmsWhereUniqueInput;
  };

  export type rentalsCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<rentalsCreateWithoutUserInput, rentalsUncheckedCreateWithoutUserInput>
      | rentalsCreateWithoutUserInput[]
      | rentalsUncheckedCreateWithoutUserInput[];
    connectOrCreate?: rentalsCreateOrConnectWithoutUserInput | rentalsCreateOrConnectWithoutUserInput[];
    createMany?: rentalsCreateManyUserInputEnvelope;
    connect?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
  };

  export type rentalsUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<rentalsCreateWithoutUserInput, rentalsUncheckedCreateWithoutUserInput>
      | rentalsCreateWithoutUserInput[]
      | rentalsUncheckedCreateWithoutUserInput[];
    connectOrCreate?: rentalsCreateOrConnectWithoutUserInput | rentalsCreateOrConnectWithoutUserInput[];
    createMany?: rentalsCreateManyUserInputEnvelope;
    connect?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
  };

  export type customersUpdatedocumentsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type firmsUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<firmsCreateWithoutCustomersInput, firmsUncheckedCreateWithoutCustomersInput>;
    connectOrCreate?: firmsCreateOrConnectWithoutCustomersInput;
    upsert?: firmsUpsertWithoutCustomersInput;
    connect?: firmsWhereUniqueInput;
    update?: XOR<
      XOR<firmsUpdateToOneWithWhereWithoutCustomersInput, firmsUpdateWithoutCustomersInput>,
      firmsUncheckedUpdateWithoutCustomersInput
    >;
  };

  export type rentalsUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<rentalsCreateWithoutUserInput, rentalsUncheckedCreateWithoutUserInput>
      | rentalsCreateWithoutUserInput[]
      | rentalsUncheckedCreateWithoutUserInput[];
    connectOrCreate?: rentalsCreateOrConnectWithoutUserInput | rentalsCreateOrConnectWithoutUserInput[];
    upsert?: rentalsUpsertWithWhereUniqueWithoutUserInput | rentalsUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: rentalsCreateManyUserInputEnvelope;
    set?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    disconnect?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    delete?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    connect?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    update?: rentalsUpdateWithWhereUniqueWithoutUserInput | rentalsUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: rentalsUpdateManyWithWhereWithoutUserInput | rentalsUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: rentalsScalarWhereInput | rentalsScalarWhereInput[];
  };

  export type rentalsUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<rentalsCreateWithoutUserInput, rentalsUncheckedCreateWithoutUserInput>
      | rentalsCreateWithoutUserInput[]
      | rentalsUncheckedCreateWithoutUserInput[];
    connectOrCreate?: rentalsCreateOrConnectWithoutUserInput | rentalsCreateOrConnectWithoutUserInput[];
    upsert?: rentalsUpsertWithWhereUniqueWithoutUserInput | rentalsUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: rentalsCreateManyUserInputEnvelope;
    set?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    disconnect?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    delete?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    connect?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    update?: rentalsUpdateWithWhereUniqueWithoutUserInput | rentalsUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?: rentalsUpdateManyWithWhereWithoutUserInput | rentalsUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: rentalsScalarWhereInput | rentalsScalarWhereInput[];
  };

  export type firmsCreatemediaInput = {
    set: string[];
  };

  export type productsCreateNestedManyWithoutFirmInput = {
    create?:
      | XOR<productsCreateWithoutFirmInput, productsUncheckedCreateWithoutFirmInput>
      | productsCreateWithoutFirmInput[]
      | productsUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: productsCreateOrConnectWithoutFirmInput | productsCreateOrConnectWithoutFirmInput[];
    createMany?: productsCreateManyFirmInputEnvelope;
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[];
  };

  export type terms_and_conditionsCreateNestedManyWithoutFirmInput = {
    create?:
      | XOR<terms_and_conditionsCreateWithoutFirmInput, terms_and_conditionsUncheckedCreateWithoutFirmInput>
      | terms_and_conditionsCreateWithoutFirmInput[]
      | terms_and_conditionsUncheckedCreateWithoutFirmInput[];
    connectOrCreate?:
      | terms_and_conditionsCreateOrConnectWithoutFirmInput
      | terms_and_conditionsCreateOrConnectWithoutFirmInput[];
    createMany?: terms_and_conditionsCreateManyFirmInputEnvelope;
    connect?: terms_and_conditionsWhereUniqueInput | terms_and_conditionsWhereUniqueInput[];
  };

  export type payment_collectionsCreateNestedManyWithoutFirmInput = {
    create?:
      | XOR<payment_collectionsCreateWithoutFirmInput, payment_collectionsUncheckedCreateWithoutFirmInput>
      | payment_collectionsCreateWithoutFirmInput[]
      | payment_collectionsUncheckedCreateWithoutFirmInput[];
    connectOrCreate?:
      | payment_collectionsCreateOrConnectWithoutFirmInput
      | payment_collectionsCreateOrConnectWithoutFirmInput[];
    createMany?: payment_collectionsCreateManyFirmInputEnvelope;
    connect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
  };

  export type payment_modesCreateNestedManyWithoutFirmInput = {
    create?:
      | XOR<payment_modesCreateWithoutFirmInput, payment_modesUncheckedCreateWithoutFirmInput>
      | payment_modesCreateWithoutFirmInput[]
      | payment_modesUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: payment_modesCreateOrConnectWithoutFirmInput | payment_modesCreateOrConnectWithoutFirmInput[];
    createMany?: payment_modesCreateManyFirmInputEnvelope;
    connect?: payment_modesWhereUniqueInput | payment_modesWhereUniqueInput[];
  };

  export type customersCreateNestedManyWithoutFirmInput = {
    create?:
      | XOR<customersCreateWithoutFirmInput, customersUncheckedCreateWithoutFirmInput>
      | customersCreateWithoutFirmInput[]
      | customersUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: customersCreateOrConnectWithoutFirmInput | customersCreateOrConnectWithoutFirmInput[];
    createMany?: customersCreateManyFirmInputEnvelope;
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[];
  };

  export type ownersCreateNestedManyWithoutFirmInput = {
    create?:
      | XOR<ownersCreateWithoutFirmInput, ownersUncheckedCreateWithoutFirmInput>
      | ownersCreateWithoutFirmInput[]
      | ownersUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: ownersCreateOrConnectWithoutFirmInput | ownersCreateOrConnectWithoutFirmInput[];
    createMany?: ownersCreateManyFirmInputEnvelope;
    connect?: ownersWhereUniqueInput | ownersWhereUniqueInput[];
  };

  export type productsUncheckedCreateNestedManyWithoutFirmInput = {
    create?:
      | XOR<productsCreateWithoutFirmInput, productsUncheckedCreateWithoutFirmInput>
      | productsCreateWithoutFirmInput[]
      | productsUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: productsCreateOrConnectWithoutFirmInput | productsCreateOrConnectWithoutFirmInput[];
    createMany?: productsCreateManyFirmInputEnvelope;
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[];
  };

  export type terms_and_conditionsUncheckedCreateNestedManyWithoutFirmInput = {
    create?:
      | XOR<terms_and_conditionsCreateWithoutFirmInput, terms_and_conditionsUncheckedCreateWithoutFirmInput>
      | terms_and_conditionsCreateWithoutFirmInput[]
      | terms_and_conditionsUncheckedCreateWithoutFirmInput[];
    connectOrCreate?:
      | terms_and_conditionsCreateOrConnectWithoutFirmInput
      | terms_and_conditionsCreateOrConnectWithoutFirmInput[];
    createMany?: terms_and_conditionsCreateManyFirmInputEnvelope;
    connect?: terms_and_conditionsWhereUniqueInput | terms_and_conditionsWhereUniqueInput[];
  };

  export type payment_collectionsUncheckedCreateNestedManyWithoutFirmInput = {
    create?:
      | XOR<payment_collectionsCreateWithoutFirmInput, payment_collectionsUncheckedCreateWithoutFirmInput>
      | payment_collectionsCreateWithoutFirmInput[]
      | payment_collectionsUncheckedCreateWithoutFirmInput[];
    connectOrCreate?:
      | payment_collectionsCreateOrConnectWithoutFirmInput
      | payment_collectionsCreateOrConnectWithoutFirmInput[];
    createMany?: payment_collectionsCreateManyFirmInputEnvelope;
    connect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
  };

  export type payment_modesUncheckedCreateNestedManyWithoutFirmInput = {
    create?:
      | XOR<payment_modesCreateWithoutFirmInput, payment_modesUncheckedCreateWithoutFirmInput>
      | payment_modesCreateWithoutFirmInput[]
      | payment_modesUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: payment_modesCreateOrConnectWithoutFirmInput | payment_modesCreateOrConnectWithoutFirmInput[];
    createMany?: payment_modesCreateManyFirmInputEnvelope;
    connect?: payment_modesWhereUniqueInput | payment_modesWhereUniqueInput[];
  };

  export type customersUncheckedCreateNestedManyWithoutFirmInput = {
    create?:
      | XOR<customersCreateWithoutFirmInput, customersUncheckedCreateWithoutFirmInput>
      | customersCreateWithoutFirmInput[]
      | customersUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: customersCreateOrConnectWithoutFirmInput | customersCreateOrConnectWithoutFirmInput[];
    createMany?: customersCreateManyFirmInputEnvelope;
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[];
  };

  export type ownersUncheckedCreateNestedManyWithoutFirmInput = {
    create?:
      | XOR<ownersCreateWithoutFirmInput, ownersUncheckedCreateWithoutFirmInput>
      | ownersCreateWithoutFirmInput[]
      | ownersUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: ownersCreateOrConnectWithoutFirmInput | ownersCreateOrConnectWithoutFirmInput[];
    createMany?: ownersCreateManyFirmInputEnvelope;
    connect?: ownersWhereUniqueInput | ownersWhereUniqueInput[];
  };

  export type firmsUpdatemediaInput = {
    set?: string[];
    push?: string | string[];
  };

  export type productsUpdateManyWithoutFirmNestedInput = {
    create?:
      | XOR<productsCreateWithoutFirmInput, productsUncheckedCreateWithoutFirmInput>
      | productsCreateWithoutFirmInput[]
      | productsUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: productsCreateOrConnectWithoutFirmInput | productsCreateOrConnectWithoutFirmInput[];
    upsert?: productsUpsertWithWhereUniqueWithoutFirmInput | productsUpsertWithWhereUniqueWithoutFirmInput[];
    createMany?: productsCreateManyFirmInputEnvelope;
    set?: productsWhereUniqueInput | productsWhereUniqueInput[];
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[];
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[];
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[];
    update?: productsUpdateWithWhereUniqueWithoutFirmInput | productsUpdateWithWhereUniqueWithoutFirmInput[];
    updateMany?: productsUpdateManyWithWhereWithoutFirmInput | productsUpdateManyWithWhereWithoutFirmInput[];
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[];
  };

  export type terms_and_conditionsUpdateManyWithoutFirmNestedInput = {
    create?:
      | XOR<terms_and_conditionsCreateWithoutFirmInput, terms_and_conditionsUncheckedCreateWithoutFirmInput>
      | terms_and_conditionsCreateWithoutFirmInput[]
      | terms_and_conditionsUncheckedCreateWithoutFirmInput[];
    connectOrCreate?:
      | terms_and_conditionsCreateOrConnectWithoutFirmInput
      | terms_and_conditionsCreateOrConnectWithoutFirmInput[];
    upsert?:
      | terms_and_conditionsUpsertWithWhereUniqueWithoutFirmInput
      | terms_and_conditionsUpsertWithWhereUniqueWithoutFirmInput[];
    createMany?: terms_and_conditionsCreateManyFirmInputEnvelope;
    set?: terms_and_conditionsWhereUniqueInput | terms_and_conditionsWhereUniqueInput[];
    disconnect?: terms_and_conditionsWhereUniqueInput | terms_and_conditionsWhereUniqueInput[];
    delete?: terms_and_conditionsWhereUniqueInput | terms_and_conditionsWhereUniqueInput[];
    connect?: terms_and_conditionsWhereUniqueInput | terms_and_conditionsWhereUniqueInput[];
    update?:
      | terms_and_conditionsUpdateWithWhereUniqueWithoutFirmInput
      | terms_and_conditionsUpdateWithWhereUniqueWithoutFirmInput[];
    updateMany?:
      | terms_and_conditionsUpdateManyWithWhereWithoutFirmInput
      | terms_and_conditionsUpdateManyWithWhereWithoutFirmInput[];
    deleteMany?: terms_and_conditionsScalarWhereInput | terms_and_conditionsScalarWhereInput[];
  };

  export type payment_collectionsUpdateManyWithoutFirmNestedInput = {
    create?:
      | XOR<payment_collectionsCreateWithoutFirmInput, payment_collectionsUncheckedCreateWithoutFirmInput>
      | payment_collectionsCreateWithoutFirmInput[]
      | payment_collectionsUncheckedCreateWithoutFirmInput[];
    connectOrCreate?:
      | payment_collectionsCreateOrConnectWithoutFirmInput
      | payment_collectionsCreateOrConnectWithoutFirmInput[];
    upsert?:
      | payment_collectionsUpsertWithWhereUniqueWithoutFirmInput
      | payment_collectionsUpsertWithWhereUniqueWithoutFirmInput[];
    createMany?: payment_collectionsCreateManyFirmInputEnvelope;
    set?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    disconnect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    delete?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    connect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    update?:
      | payment_collectionsUpdateWithWhereUniqueWithoutFirmInput
      | payment_collectionsUpdateWithWhereUniqueWithoutFirmInput[];
    updateMany?:
      | payment_collectionsUpdateManyWithWhereWithoutFirmInput
      | payment_collectionsUpdateManyWithWhereWithoutFirmInput[];
    deleteMany?: payment_collectionsScalarWhereInput | payment_collectionsScalarWhereInput[];
  };

  export type payment_modesUpdateManyWithoutFirmNestedInput = {
    create?:
      | XOR<payment_modesCreateWithoutFirmInput, payment_modesUncheckedCreateWithoutFirmInput>
      | payment_modesCreateWithoutFirmInput[]
      | payment_modesUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: payment_modesCreateOrConnectWithoutFirmInput | payment_modesCreateOrConnectWithoutFirmInput[];
    upsert?: payment_modesUpsertWithWhereUniqueWithoutFirmInput | payment_modesUpsertWithWhereUniqueWithoutFirmInput[];
    createMany?: payment_modesCreateManyFirmInputEnvelope;
    set?: payment_modesWhereUniqueInput | payment_modesWhereUniqueInput[];
    disconnect?: payment_modesWhereUniqueInput | payment_modesWhereUniqueInput[];
    delete?: payment_modesWhereUniqueInput | payment_modesWhereUniqueInput[];
    connect?: payment_modesWhereUniqueInput | payment_modesWhereUniqueInput[];
    update?: payment_modesUpdateWithWhereUniqueWithoutFirmInput | payment_modesUpdateWithWhereUniqueWithoutFirmInput[];
    updateMany?: payment_modesUpdateManyWithWhereWithoutFirmInput | payment_modesUpdateManyWithWhereWithoutFirmInput[];
    deleteMany?: payment_modesScalarWhereInput | payment_modesScalarWhereInput[];
  };

  export type customersUpdateManyWithoutFirmNestedInput = {
    create?:
      | XOR<customersCreateWithoutFirmInput, customersUncheckedCreateWithoutFirmInput>
      | customersCreateWithoutFirmInput[]
      | customersUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: customersCreateOrConnectWithoutFirmInput | customersCreateOrConnectWithoutFirmInput[];
    upsert?: customersUpsertWithWhereUniqueWithoutFirmInput | customersUpsertWithWhereUniqueWithoutFirmInput[];
    createMany?: customersCreateManyFirmInputEnvelope;
    set?: customersWhereUniqueInput | customersWhereUniqueInput[];
    disconnect?: customersWhereUniqueInput | customersWhereUniqueInput[];
    delete?: customersWhereUniqueInput | customersWhereUniqueInput[];
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[];
    update?: customersUpdateWithWhereUniqueWithoutFirmInput | customersUpdateWithWhereUniqueWithoutFirmInput[];
    updateMany?: customersUpdateManyWithWhereWithoutFirmInput | customersUpdateManyWithWhereWithoutFirmInput[];
    deleteMany?: customersScalarWhereInput | customersScalarWhereInput[];
  };

  export type ownersUpdateManyWithoutFirmNestedInput = {
    create?:
      | XOR<ownersCreateWithoutFirmInput, ownersUncheckedCreateWithoutFirmInput>
      | ownersCreateWithoutFirmInput[]
      | ownersUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: ownersCreateOrConnectWithoutFirmInput | ownersCreateOrConnectWithoutFirmInput[];
    upsert?: ownersUpsertWithWhereUniqueWithoutFirmInput | ownersUpsertWithWhereUniqueWithoutFirmInput[];
    createMany?: ownersCreateManyFirmInputEnvelope;
    set?: ownersWhereUniqueInput | ownersWhereUniqueInput[];
    disconnect?: ownersWhereUniqueInput | ownersWhereUniqueInput[];
    delete?: ownersWhereUniqueInput | ownersWhereUniqueInput[];
    connect?: ownersWhereUniqueInput | ownersWhereUniqueInput[];
    update?: ownersUpdateWithWhereUniqueWithoutFirmInput | ownersUpdateWithWhereUniqueWithoutFirmInput[];
    updateMany?: ownersUpdateManyWithWhereWithoutFirmInput | ownersUpdateManyWithWhereWithoutFirmInput[];
    deleteMany?: ownersScalarWhereInput | ownersScalarWhereInput[];
  };

  export type productsUncheckedUpdateManyWithoutFirmNestedInput = {
    create?:
      | XOR<productsCreateWithoutFirmInput, productsUncheckedCreateWithoutFirmInput>
      | productsCreateWithoutFirmInput[]
      | productsUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: productsCreateOrConnectWithoutFirmInput | productsCreateOrConnectWithoutFirmInput[];
    upsert?: productsUpsertWithWhereUniqueWithoutFirmInput | productsUpsertWithWhereUniqueWithoutFirmInput[];
    createMany?: productsCreateManyFirmInputEnvelope;
    set?: productsWhereUniqueInput | productsWhereUniqueInput[];
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[];
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[];
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[];
    update?: productsUpdateWithWhereUniqueWithoutFirmInput | productsUpdateWithWhereUniqueWithoutFirmInput[];
    updateMany?: productsUpdateManyWithWhereWithoutFirmInput | productsUpdateManyWithWhereWithoutFirmInput[];
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[];
  };

  export type terms_and_conditionsUncheckedUpdateManyWithoutFirmNestedInput = {
    create?:
      | XOR<terms_and_conditionsCreateWithoutFirmInput, terms_and_conditionsUncheckedCreateWithoutFirmInput>
      | terms_and_conditionsCreateWithoutFirmInput[]
      | terms_and_conditionsUncheckedCreateWithoutFirmInput[];
    connectOrCreate?:
      | terms_and_conditionsCreateOrConnectWithoutFirmInput
      | terms_and_conditionsCreateOrConnectWithoutFirmInput[];
    upsert?:
      | terms_and_conditionsUpsertWithWhereUniqueWithoutFirmInput
      | terms_and_conditionsUpsertWithWhereUniqueWithoutFirmInput[];
    createMany?: terms_and_conditionsCreateManyFirmInputEnvelope;
    set?: terms_and_conditionsWhereUniqueInput | terms_and_conditionsWhereUniqueInput[];
    disconnect?: terms_and_conditionsWhereUniqueInput | terms_and_conditionsWhereUniqueInput[];
    delete?: terms_and_conditionsWhereUniqueInput | terms_and_conditionsWhereUniqueInput[];
    connect?: terms_and_conditionsWhereUniqueInput | terms_and_conditionsWhereUniqueInput[];
    update?:
      | terms_and_conditionsUpdateWithWhereUniqueWithoutFirmInput
      | terms_and_conditionsUpdateWithWhereUniqueWithoutFirmInput[];
    updateMany?:
      | terms_and_conditionsUpdateManyWithWhereWithoutFirmInput
      | terms_and_conditionsUpdateManyWithWhereWithoutFirmInput[];
    deleteMany?: terms_and_conditionsScalarWhereInput | terms_and_conditionsScalarWhereInput[];
  };

  export type payment_collectionsUncheckedUpdateManyWithoutFirmNestedInput = {
    create?:
      | XOR<payment_collectionsCreateWithoutFirmInput, payment_collectionsUncheckedCreateWithoutFirmInput>
      | payment_collectionsCreateWithoutFirmInput[]
      | payment_collectionsUncheckedCreateWithoutFirmInput[];
    connectOrCreate?:
      | payment_collectionsCreateOrConnectWithoutFirmInput
      | payment_collectionsCreateOrConnectWithoutFirmInput[];
    upsert?:
      | payment_collectionsUpsertWithWhereUniqueWithoutFirmInput
      | payment_collectionsUpsertWithWhereUniqueWithoutFirmInput[];
    createMany?: payment_collectionsCreateManyFirmInputEnvelope;
    set?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    disconnect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    delete?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    connect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    update?:
      | payment_collectionsUpdateWithWhereUniqueWithoutFirmInput
      | payment_collectionsUpdateWithWhereUniqueWithoutFirmInput[];
    updateMany?:
      | payment_collectionsUpdateManyWithWhereWithoutFirmInput
      | payment_collectionsUpdateManyWithWhereWithoutFirmInput[];
    deleteMany?: payment_collectionsScalarWhereInput | payment_collectionsScalarWhereInput[];
  };

  export type payment_modesUncheckedUpdateManyWithoutFirmNestedInput = {
    create?:
      | XOR<payment_modesCreateWithoutFirmInput, payment_modesUncheckedCreateWithoutFirmInput>
      | payment_modesCreateWithoutFirmInput[]
      | payment_modesUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: payment_modesCreateOrConnectWithoutFirmInput | payment_modesCreateOrConnectWithoutFirmInput[];
    upsert?: payment_modesUpsertWithWhereUniqueWithoutFirmInput | payment_modesUpsertWithWhereUniqueWithoutFirmInput[];
    createMany?: payment_modesCreateManyFirmInputEnvelope;
    set?: payment_modesWhereUniqueInput | payment_modesWhereUniqueInput[];
    disconnect?: payment_modesWhereUniqueInput | payment_modesWhereUniqueInput[];
    delete?: payment_modesWhereUniqueInput | payment_modesWhereUniqueInput[];
    connect?: payment_modesWhereUniqueInput | payment_modesWhereUniqueInput[];
    update?: payment_modesUpdateWithWhereUniqueWithoutFirmInput | payment_modesUpdateWithWhereUniqueWithoutFirmInput[];
    updateMany?: payment_modesUpdateManyWithWhereWithoutFirmInput | payment_modesUpdateManyWithWhereWithoutFirmInput[];
    deleteMany?: payment_modesScalarWhereInput | payment_modesScalarWhereInput[];
  };

  export type customersUncheckedUpdateManyWithoutFirmNestedInput = {
    create?:
      | XOR<customersCreateWithoutFirmInput, customersUncheckedCreateWithoutFirmInput>
      | customersCreateWithoutFirmInput[]
      | customersUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: customersCreateOrConnectWithoutFirmInput | customersCreateOrConnectWithoutFirmInput[];
    upsert?: customersUpsertWithWhereUniqueWithoutFirmInput | customersUpsertWithWhereUniqueWithoutFirmInput[];
    createMany?: customersCreateManyFirmInputEnvelope;
    set?: customersWhereUniqueInput | customersWhereUniqueInput[];
    disconnect?: customersWhereUniqueInput | customersWhereUniqueInput[];
    delete?: customersWhereUniqueInput | customersWhereUniqueInput[];
    connect?: customersWhereUniqueInput | customersWhereUniqueInput[];
    update?: customersUpdateWithWhereUniqueWithoutFirmInput | customersUpdateWithWhereUniqueWithoutFirmInput[];
    updateMany?: customersUpdateManyWithWhereWithoutFirmInput | customersUpdateManyWithWhereWithoutFirmInput[];
    deleteMany?: customersScalarWhereInput | customersScalarWhereInput[];
  };

  export type ownersUncheckedUpdateManyWithoutFirmNestedInput = {
    create?:
      | XOR<ownersCreateWithoutFirmInput, ownersUncheckedCreateWithoutFirmInput>
      | ownersCreateWithoutFirmInput[]
      | ownersUncheckedCreateWithoutFirmInput[];
    connectOrCreate?: ownersCreateOrConnectWithoutFirmInput | ownersCreateOrConnectWithoutFirmInput[];
    upsert?: ownersUpsertWithWhereUniqueWithoutFirmInput | ownersUpsertWithWhereUniqueWithoutFirmInput[];
    createMany?: ownersCreateManyFirmInputEnvelope;
    set?: ownersWhereUniqueInput | ownersWhereUniqueInput[];
    disconnect?: ownersWhereUniqueInput | ownersWhereUniqueInput[];
    delete?: ownersWhereUniqueInput | ownersWhereUniqueInput[];
    connect?: ownersWhereUniqueInput | ownersWhereUniqueInput[];
    update?: ownersUpdateWithWhereUniqueWithoutFirmInput | ownersUpdateWithWhereUniqueWithoutFirmInput[];
    updateMany?: ownersUpdateManyWithWhereWithoutFirmInput | ownersUpdateManyWithWhereWithoutFirmInput[];
    deleteMany?: ownersScalarWhereInput | ownersScalarWhereInput[];
  };

  export type ownersCreatedocumentsInput = {
    set: string[];
  };

  export type firmsCreateNestedOneWithoutOwnersInput = {
    create?: XOR<firmsCreateWithoutOwnersInput, firmsUncheckedCreateWithoutOwnersInput>;
    connectOrCreate?: firmsCreateOrConnectWithoutOwnersInput;
    connect?: firmsWhereUniqueInput;
  };

  export type ownersUpdatedocumentsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type firmsUpdateOneWithoutOwnersNestedInput = {
    create?: XOR<firmsCreateWithoutOwnersInput, firmsUncheckedCreateWithoutOwnersInput>;
    connectOrCreate?: firmsCreateOrConnectWithoutOwnersInput;
    upsert?: firmsUpsertWithoutOwnersInput;
    disconnect?: firmsWhereInput | boolean;
    delete?: firmsWhereInput | boolean;
    connect?: firmsWhereUniqueInput;
    update?: XOR<
      XOR<firmsUpdateToOneWithWhereWithoutOwnersInput, firmsUpdateWithoutOwnersInput>,
      firmsUncheckedUpdateWithoutOwnersInput
    >;
  };

  export type firmsCreateNestedOneWithoutPayment_collectionsInput = {
    create?: XOR<firmsCreateWithoutPayment_collectionsInput, firmsUncheckedCreateWithoutPayment_collectionsInput>;
    connectOrCreate?: firmsCreateOrConnectWithoutPayment_collectionsInput;
    connect?: firmsWhereUniqueInput;
  };

  export type payment_modesCreateNestedOneWithoutPayment_collectionsInput = {
    create?: XOR<
      payment_modesCreateWithoutPayment_collectionsInput,
      payment_modesUncheckedCreateWithoutPayment_collectionsInput
    >;
    connectOrCreate?: payment_modesCreateOrConnectWithoutPayment_collectionsInput;
    connect?: payment_modesWhereUniqueInput;
  };

  export type rentalsCreateNestedOneWithoutPayment_collectionsInput = {
    create?: XOR<rentalsCreateWithoutPayment_collectionsInput, rentalsUncheckedCreateWithoutPayment_collectionsInput>;
    connectOrCreate?: rentalsCreateOrConnectWithoutPayment_collectionsInput;
    connect?: rentalsWhereUniqueInput;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type firmsUpdateOneWithoutPayment_collectionsNestedInput = {
    create?: XOR<firmsCreateWithoutPayment_collectionsInput, firmsUncheckedCreateWithoutPayment_collectionsInput>;
    connectOrCreate?: firmsCreateOrConnectWithoutPayment_collectionsInput;
    upsert?: firmsUpsertWithoutPayment_collectionsInput;
    disconnect?: firmsWhereInput | boolean;
    delete?: firmsWhereInput | boolean;
    connect?: firmsWhereUniqueInput;
    update?: XOR<
      XOR<firmsUpdateToOneWithWhereWithoutPayment_collectionsInput, firmsUpdateWithoutPayment_collectionsInput>,
      firmsUncheckedUpdateWithoutPayment_collectionsInput
    >;
  };

  export type payment_modesUpdateOneWithoutPayment_collectionsNestedInput = {
    create?: XOR<
      payment_modesCreateWithoutPayment_collectionsInput,
      payment_modesUncheckedCreateWithoutPayment_collectionsInput
    >;
    connectOrCreate?: payment_modesCreateOrConnectWithoutPayment_collectionsInput;
    upsert?: payment_modesUpsertWithoutPayment_collectionsInput;
    disconnect?: payment_modesWhereInput | boolean;
    delete?: payment_modesWhereInput | boolean;
    connect?: payment_modesWhereUniqueInput;
    update?: XOR<
      XOR<
        payment_modesUpdateToOneWithWhereWithoutPayment_collectionsInput,
        payment_modesUpdateWithoutPayment_collectionsInput
      >,
      payment_modesUncheckedUpdateWithoutPayment_collectionsInput
    >;
  };

  export type rentalsUpdateOneWithoutPayment_collectionsNestedInput = {
    create?: XOR<rentalsCreateWithoutPayment_collectionsInput, rentalsUncheckedCreateWithoutPayment_collectionsInput>;
    connectOrCreate?: rentalsCreateOrConnectWithoutPayment_collectionsInput;
    upsert?: rentalsUpsertWithoutPayment_collectionsInput;
    disconnect?: rentalsWhereInput | boolean;
    delete?: rentalsWhereInput | boolean;
    connect?: rentalsWhereUniqueInput;
    update?: XOR<
      XOR<rentalsUpdateToOneWithWhereWithoutPayment_collectionsInput, rentalsUpdateWithoutPayment_collectionsInput>,
      rentalsUncheckedUpdateWithoutPayment_collectionsInput
    >;
  };

  export type firmsCreateNestedOneWithoutPayment_modesInput = {
    create?: XOR<firmsCreateWithoutPayment_modesInput, firmsUncheckedCreateWithoutPayment_modesInput>;
    connectOrCreate?: firmsCreateOrConnectWithoutPayment_modesInput;
    connect?: firmsWhereUniqueInput;
  };

  export type payment_collectionsCreateNestedManyWithoutPayment_modeInput = {
    create?:
      | XOR<
          payment_collectionsCreateWithoutPayment_modeInput,
          payment_collectionsUncheckedCreateWithoutPayment_modeInput
        >
      | payment_collectionsCreateWithoutPayment_modeInput[]
      | payment_collectionsUncheckedCreateWithoutPayment_modeInput[];
    connectOrCreate?:
      | payment_collectionsCreateOrConnectWithoutPayment_modeInput
      | payment_collectionsCreateOrConnectWithoutPayment_modeInput[];
    createMany?: payment_collectionsCreateManyPayment_modeInputEnvelope;
    connect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
  };

  export type rentalsCreateNestedManyWithoutPayment_modeInput = {
    create?:
      | XOR<rentalsCreateWithoutPayment_modeInput, rentalsUncheckedCreateWithoutPayment_modeInput>
      | rentalsCreateWithoutPayment_modeInput[]
      | rentalsUncheckedCreateWithoutPayment_modeInput[];
    connectOrCreate?: rentalsCreateOrConnectWithoutPayment_modeInput | rentalsCreateOrConnectWithoutPayment_modeInput[];
    createMany?: rentalsCreateManyPayment_modeInputEnvelope;
    connect?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
  };

  export type payment_collectionsUncheckedCreateNestedManyWithoutPayment_modeInput = {
    create?:
      | XOR<
          payment_collectionsCreateWithoutPayment_modeInput,
          payment_collectionsUncheckedCreateWithoutPayment_modeInput
        >
      | payment_collectionsCreateWithoutPayment_modeInput[]
      | payment_collectionsUncheckedCreateWithoutPayment_modeInput[];
    connectOrCreate?:
      | payment_collectionsCreateOrConnectWithoutPayment_modeInput
      | payment_collectionsCreateOrConnectWithoutPayment_modeInput[];
    createMany?: payment_collectionsCreateManyPayment_modeInputEnvelope;
    connect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
  };

  export type rentalsUncheckedCreateNestedManyWithoutPayment_modeInput = {
    create?:
      | XOR<rentalsCreateWithoutPayment_modeInput, rentalsUncheckedCreateWithoutPayment_modeInput>
      | rentalsCreateWithoutPayment_modeInput[]
      | rentalsUncheckedCreateWithoutPayment_modeInput[];
    connectOrCreate?: rentalsCreateOrConnectWithoutPayment_modeInput | rentalsCreateOrConnectWithoutPayment_modeInput[];
    createMany?: rentalsCreateManyPayment_modeInputEnvelope;
    connect?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
  };

  export type firmsUpdateOneWithoutPayment_modesNestedInput = {
    create?: XOR<firmsCreateWithoutPayment_modesInput, firmsUncheckedCreateWithoutPayment_modesInput>;
    connectOrCreate?: firmsCreateOrConnectWithoutPayment_modesInput;
    upsert?: firmsUpsertWithoutPayment_modesInput;
    disconnect?: firmsWhereInput | boolean;
    delete?: firmsWhereInput | boolean;
    connect?: firmsWhereUniqueInput;
    update?: XOR<
      XOR<firmsUpdateToOneWithWhereWithoutPayment_modesInput, firmsUpdateWithoutPayment_modesInput>,
      firmsUncheckedUpdateWithoutPayment_modesInput
    >;
  };

  export type payment_collectionsUpdateManyWithoutPayment_modeNestedInput = {
    create?:
      | XOR<
          payment_collectionsCreateWithoutPayment_modeInput,
          payment_collectionsUncheckedCreateWithoutPayment_modeInput
        >
      | payment_collectionsCreateWithoutPayment_modeInput[]
      | payment_collectionsUncheckedCreateWithoutPayment_modeInput[];
    connectOrCreate?:
      | payment_collectionsCreateOrConnectWithoutPayment_modeInput
      | payment_collectionsCreateOrConnectWithoutPayment_modeInput[];
    upsert?:
      | payment_collectionsUpsertWithWhereUniqueWithoutPayment_modeInput
      | payment_collectionsUpsertWithWhereUniqueWithoutPayment_modeInput[];
    createMany?: payment_collectionsCreateManyPayment_modeInputEnvelope;
    set?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    disconnect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    delete?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    connect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    update?:
      | payment_collectionsUpdateWithWhereUniqueWithoutPayment_modeInput
      | payment_collectionsUpdateWithWhereUniqueWithoutPayment_modeInput[];
    updateMany?:
      | payment_collectionsUpdateManyWithWhereWithoutPayment_modeInput
      | payment_collectionsUpdateManyWithWhereWithoutPayment_modeInput[];
    deleteMany?: payment_collectionsScalarWhereInput | payment_collectionsScalarWhereInput[];
  };

  export type rentalsUpdateManyWithoutPayment_modeNestedInput = {
    create?:
      | XOR<rentalsCreateWithoutPayment_modeInput, rentalsUncheckedCreateWithoutPayment_modeInput>
      | rentalsCreateWithoutPayment_modeInput[]
      | rentalsUncheckedCreateWithoutPayment_modeInput[];
    connectOrCreate?: rentalsCreateOrConnectWithoutPayment_modeInput | rentalsCreateOrConnectWithoutPayment_modeInput[];
    upsert?:
      | rentalsUpsertWithWhereUniqueWithoutPayment_modeInput
      | rentalsUpsertWithWhereUniqueWithoutPayment_modeInput[];
    createMany?: rentalsCreateManyPayment_modeInputEnvelope;
    set?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    disconnect?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    delete?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    connect?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    update?:
      | rentalsUpdateWithWhereUniqueWithoutPayment_modeInput
      | rentalsUpdateWithWhereUniqueWithoutPayment_modeInput[];
    updateMany?:
      | rentalsUpdateManyWithWhereWithoutPayment_modeInput
      | rentalsUpdateManyWithWhereWithoutPayment_modeInput[];
    deleteMany?: rentalsScalarWhereInput | rentalsScalarWhereInput[];
  };

  export type payment_collectionsUncheckedUpdateManyWithoutPayment_modeNestedInput = {
    create?:
      | XOR<
          payment_collectionsCreateWithoutPayment_modeInput,
          payment_collectionsUncheckedCreateWithoutPayment_modeInput
        >
      | payment_collectionsCreateWithoutPayment_modeInput[]
      | payment_collectionsUncheckedCreateWithoutPayment_modeInput[];
    connectOrCreate?:
      | payment_collectionsCreateOrConnectWithoutPayment_modeInput
      | payment_collectionsCreateOrConnectWithoutPayment_modeInput[];
    upsert?:
      | payment_collectionsUpsertWithWhereUniqueWithoutPayment_modeInput
      | payment_collectionsUpsertWithWhereUniqueWithoutPayment_modeInput[];
    createMany?: payment_collectionsCreateManyPayment_modeInputEnvelope;
    set?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    disconnect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    delete?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    connect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    update?:
      | payment_collectionsUpdateWithWhereUniqueWithoutPayment_modeInput
      | payment_collectionsUpdateWithWhereUniqueWithoutPayment_modeInput[];
    updateMany?:
      | payment_collectionsUpdateManyWithWhereWithoutPayment_modeInput
      | payment_collectionsUpdateManyWithWhereWithoutPayment_modeInput[];
    deleteMany?: payment_collectionsScalarWhereInput | payment_collectionsScalarWhereInput[];
  };

  export type rentalsUncheckedUpdateManyWithoutPayment_modeNestedInput = {
    create?:
      | XOR<rentalsCreateWithoutPayment_modeInput, rentalsUncheckedCreateWithoutPayment_modeInput>
      | rentalsCreateWithoutPayment_modeInput[]
      | rentalsUncheckedCreateWithoutPayment_modeInput[];
    connectOrCreate?: rentalsCreateOrConnectWithoutPayment_modeInput | rentalsCreateOrConnectWithoutPayment_modeInput[];
    upsert?:
      | rentalsUpsertWithWhereUniqueWithoutPayment_modeInput
      | rentalsUpsertWithWhereUniqueWithoutPayment_modeInput[];
    createMany?: rentalsCreateManyPayment_modeInputEnvelope;
    set?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    disconnect?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    delete?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    connect?: rentalsWhereUniqueInput | rentalsWhereUniqueInput[];
    update?:
      | rentalsUpdateWithWhereUniqueWithoutPayment_modeInput
      | rentalsUpdateWithWhereUniqueWithoutPayment_modeInput[];
    updateMany?:
      | rentalsUpdateManyWithWhereWithoutPayment_modeInput
      | rentalsUpdateManyWithWhereWithoutPayment_modeInput[];
    deleteMany?: rentalsScalarWhereInput | rentalsScalarWhereInput[];
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type productsCreatekeywordsInput = {
    set: string[];
  };

  export type productsCreatemediaInput = {
    set: string[];
  };

  export type firmsCreateNestedOneWithoutProductsInput = {
    create?: XOR<firmsCreateWithoutProductsInput, firmsUncheckedCreateWithoutProductsInput>;
    connectOrCreate?: firmsCreateOrConnectWithoutProductsInput;
    connect?: firmsWhereUniqueInput;
  };

  export type EnumPeriodFieldUpdateOperationsInput = {
    set?: $Enums.Period;
  };

  export type productsUpdatekeywordsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type productsUpdatemediaInput = {
    set?: string[];
    push?: string | string[];
  };

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status;
  };

  export type firmsUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<firmsCreateWithoutProductsInput, firmsUncheckedCreateWithoutProductsInput>;
    connectOrCreate?: firmsCreateOrConnectWithoutProductsInput;
    upsert?: firmsUpsertWithoutProductsInput;
    connect?: firmsWhereUniqueInput;
    update?: XOR<
      XOR<firmsUpdateToOneWithWhereWithoutProductsInput, firmsUpdateWithoutProductsInput>,
      firmsUncheckedUpdateWithoutProductsInput
    >;
  };

  export type provider_configurationsCreateadditional_propertiesInput = {
    set: InputJsonValue[];
  };

  export type provider_configurationsUpdateadditional_propertiesInput = {
    set?: InputJsonValue[];
    push?: InputJsonValue | InputJsonValue[];
  };

  export type rentalsCreaterental_productsInput = {
    set: InputJsonValue[];
  };

  export type payment_collectionsCreateNestedManyWithoutRentalInput = {
    create?:
      | XOR<payment_collectionsCreateWithoutRentalInput, payment_collectionsUncheckedCreateWithoutRentalInput>
      | payment_collectionsCreateWithoutRentalInput[]
      | payment_collectionsUncheckedCreateWithoutRentalInput[];
    connectOrCreate?:
      | payment_collectionsCreateOrConnectWithoutRentalInput
      | payment_collectionsCreateOrConnectWithoutRentalInput[];
    createMany?: payment_collectionsCreateManyRentalInputEnvelope;
    connect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
  };

  export type customersCreateNestedOneWithoutRentalsInput = {
    create?: XOR<customersCreateWithoutRentalsInput, customersUncheckedCreateWithoutRentalsInput>;
    connectOrCreate?: customersCreateOrConnectWithoutRentalsInput;
    connect?: customersWhereUniqueInput;
  };

  export type payment_modesCreateNestedOneWithoutRentalsInput = {
    create?: XOR<payment_modesCreateWithoutRentalsInput, payment_modesUncheckedCreateWithoutRentalsInput>;
    connectOrCreate?: payment_modesCreateOrConnectWithoutRentalsInput;
    connect?: payment_modesWhereUniqueInput;
  };

  export type payment_collectionsUncheckedCreateNestedManyWithoutRentalInput = {
    create?:
      | XOR<payment_collectionsCreateWithoutRentalInput, payment_collectionsUncheckedCreateWithoutRentalInput>
      | payment_collectionsCreateWithoutRentalInput[]
      | payment_collectionsUncheckedCreateWithoutRentalInput[];
    connectOrCreate?:
      | payment_collectionsCreateOrConnectWithoutRentalInput
      | payment_collectionsCreateOrConnectWithoutRentalInput[];
    createMany?: payment_collectionsCreateManyRentalInputEnvelope;
    connect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
  };

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus;
  };

  export type rentalsUpdaterental_productsInput = {
    set?: InputJsonValue[];
    push?: InputJsonValue | InputJsonValue[];
  };

  export type payment_collectionsUpdateManyWithoutRentalNestedInput = {
    create?:
      | XOR<payment_collectionsCreateWithoutRentalInput, payment_collectionsUncheckedCreateWithoutRentalInput>
      | payment_collectionsCreateWithoutRentalInput[]
      | payment_collectionsUncheckedCreateWithoutRentalInput[];
    connectOrCreate?:
      | payment_collectionsCreateOrConnectWithoutRentalInput
      | payment_collectionsCreateOrConnectWithoutRentalInput[];
    upsert?:
      | payment_collectionsUpsertWithWhereUniqueWithoutRentalInput
      | payment_collectionsUpsertWithWhereUniqueWithoutRentalInput[];
    createMany?: payment_collectionsCreateManyRentalInputEnvelope;
    set?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    disconnect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    delete?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    connect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    update?:
      | payment_collectionsUpdateWithWhereUniqueWithoutRentalInput
      | payment_collectionsUpdateWithWhereUniqueWithoutRentalInput[];
    updateMany?:
      | payment_collectionsUpdateManyWithWhereWithoutRentalInput
      | payment_collectionsUpdateManyWithWhereWithoutRentalInput[];
    deleteMany?: payment_collectionsScalarWhereInput | payment_collectionsScalarWhereInput[];
  };

  export type customersUpdateOneWithoutRentalsNestedInput = {
    create?: XOR<customersCreateWithoutRentalsInput, customersUncheckedCreateWithoutRentalsInput>;
    connectOrCreate?: customersCreateOrConnectWithoutRentalsInput;
    upsert?: customersUpsertWithoutRentalsInput;
    disconnect?: customersWhereInput | boolean;
    delete?: customersWhereInput | boolean;
    connect?: customersWhereUniqueInput;
    update?: XOR<
      XOR<customersUpdateToOneWithWhereWithoutRentalsInput, customersUpdateWithoutRentalsInput>,
      customersUncheckedUpdateWithoutRentalsInput
    >;
  };

  export type payment_modesUpdateOneWithoutRentalsNestedInput = {
    create?: XOR<payment_modesCreateWithoutRentalsInput, payment_modesUncheckedCreateWithoutRentalsInput>;
    connectOrCreate?: payment_modesCreateOrConnectWithoutRentalsInput;
    upsert?: payment_modesUpsertWithoutRentalsInput;
    disconnect?: payment_modesWhereInput | boolean;
    delete?: payment_modesWhereInput | boolean;
    connect?: payment_modesWhereUniqueInput;
    update?: XOR<
      XOR<payment_modesUpdateToOneWithWhereWithoutRentalsInput, payment_modesUpdateWithoutRentalsInput>,
      payment_modesUncheckedUpdateWithoutRentalsInput
    >;
  };

  export type payment_collectionsUncheckedUpdateManyWithoutRentalNestedInput = {
    create?:
      | XOR<payment_collectionsCreateWithoutRentalInput, payment_collectionsUncheckedCreateWithoutRentalInput>
      | payment_collectionsCreateWithoutRentalInput[]
      | payment_collectionsUncheckedCreateWithoutRentalInput[];
    connectOrCreate?:
      | payment_collectionsCreateOrConnectWithoutRentalInput
      | payment_collectionsCreateOrConnectWithoutRentalInput[];
    upsert?:
      | payment_collectionsUpsertWithWhereUniqueWithoutRentalInput
      | payment_collectionsUpsertWithWhereUniqueWithoutRentalInput[];
    createMany?: payment_collectionsCreateManyRentalInputEnvelope;
    set?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    disconnect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    delete?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    connect?: payment_collectionsWhereUniqueInput | payment_collectionsWhereUniqueInput[];
    update?:
      | payment_collectionsUpdateWithWhereUniqueWithoutRentalInput
      | payment_collectionsUpdateWithWhereUniqueWithoutRentalInput[];
    updateMany?:
      | payment_collectionsUpdateManyWithWhereWithoutRentalInput
      | payment_collectionsUpdateManyWithWhereWithoutRentalInput[];
    deleteMany?: payment_collectionsScalarWhereInput | payment_collectionsScalarWhereInput[];
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type firmsCreateNestedOneWithoutTerms_and_conditionsInput = {
    create?: XOR<firmsCreateWithoutTerms_and_conditionsInput, firmsUncheckedCreateWithoutTerms_and_conditionsInput>;
    connectOrCreate?: firmsCreateOrConnectWithoutTerms_and_conditionsInput;
    connect?: firmsWhereUniqueInput;
  };

  export type firmsUpdateOneRequiredWithoutTerms_and_conditionsNestedInput = {
    create?: XOR<firmsCreateWithoutTerms_and_conditionsInput, firmsUncheckedCreateWithoutTerms_and_conditionsInput>;
    connectOrCreate?: firmsCreateOrConnectWithoutTerms_and_conditionsInput;
    upsert?: firmsUpsertWithoutTerms_and_conditionsInput;
    connect?: firmsWhereUniqueInput;
    update?: XOR<
      XOR<firmsUpdateToOneWithWhereWithoutTerms_and_conditionsInput, firmsUpdateWithoutTerms_and_conditionsInput>,
      firmsUncheckedUpdateWithoutTerms_and_conditionsInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedEnumPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.Period | EnumPeriodFieldRefInput<$PrismaModel>;
    in?: $Enums.Period[] | ListEnumPeriodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Period[] | ListEnumPeriodFieldRefInput<$PrismaModel>;
    not?: NestedEnumPeriodFilter<$PrismaModel> | $Enums.Period;
  };

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status;
  };

  export type NestedEnumPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Period | EnumPeriodFieldRefInput<$PrismaModel>;
    in?: $Enums.Period[] | ListEnumPeriodFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Period[] | ListEnumPeriodFieldRefInput<$PrismaModel>;
    not?: NestedEnumPeriodWithAggregatesFilter<$PrismaModel> | $Enums.Period;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPeriodFilter<$PrismaModel>;
    _max?: NestedEnumPeriodFilter<$PrismaModel>;
  };

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumStatusFilter<$PrismaModel>;
    _max?: NestedEnumStatusFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, "path">
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, "path">>;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus;
  };

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>;
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type firmsCreateWithoutCustomersInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    products?: productsCreateNestedManyWithoutFirmInput;
    terms_and_conditions?: terms_and_conditionsCreateNestedManyWithoutFirmInput;
    payment_collections?: payment_collectionsCreateNestedManyWithoutFirmInput;
    payment_modes?: payment_modesCreateNestedManyWithoutFirmInput;
    owners?: ownersCreateNestedManyWithoutFirmInput;
  };

  export type firmsUncheckedCreateWithoutCustomersInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    products?: productsUncheckedCreateNestedManyWithoutFirmInput;
    terms_and_conditions?: terms_and_conditionsUncheckedCreateNestedManyWithoutFirmInput;
    payment_collections?: payment_collectionsUncheckedCreateNestedManyWithoutFirmInput;
    payment_modes?: payment_modesUncheckedCreateNestedManyWithoutFirmInput;
    owners?: ownersUncheckedCreateNestedManyWithoutFirmInput;
  };

  export type firmsCreateOrConnectWithoutCustomersInput = {
    where: firmsWhereUniqueInput;
    create: XOR<firmsCreateWithoutCustomersInput, firmsUncheckedCreateWithoutCustomersInput>;
  };

  export type rentalsCreateWithoutUserInput = {
    id?: string;
    invoice_id: string;
    invoice_date?: Date | string;
    invoice_status?: $Enums.InvoiceStatus;
    rental_period?: $Enums.Period;
    discount_amount?: number;
    pending_amount?: number;
    advance_amount?: number;
    deposit_amount?: number;
    paid_amount?: number;
    total_amount?: number;
    fine_amount?: number;
    rental_products?: rentalsCreaterental_productsInput | InputJsonValue[];
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
    payment_collections?: payment_collectionsCreateNestedManyWithoutRentalInput;
    payment_mode?: payment_modesCreateNestedOneWithoutRentalsInput;
  };

  export type rentalsUncheckedCreateWithoutUserInput = {
    id?: string;
    payment_mode_id: string;
    invoice_id: string;
    invoice_date?: Date | string;
    invoice_status?: $Enums.InvoiceStatus;
    rental_period?: $Enums.Period;
    discount_amount?: number;
    pending_amount?: number;
    advance_amount?: number;
    deposit_amount?: number;
    paid_amount?: number;
    total_amount?: number;
    fine_amount?: number;
    rental_products?: rentalsCreaterental_productsInput | InputJsonValue[];
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
    payment_collections?: payment_collectionsUncheckedCreateNestedManyWithoutRentalInput;
  };

  export type rentalsCreateOrConnectWithoutUserInput = {
    where: rentalsWhereUniqueInput;
    create: XOR<rentalsCreateWithoutUserInput, rentalsUncheckedCreateWithoutUserInput>;
  };

  export type rentalsCreateManyUserInputEnvelope = {
    data: rentalsCreateManyUserInput | rentalsCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type firmsUpsertWithoutCustomersInput = {
    update: XOR<firmsUpdateWithoutCustomersInput, firmsUncheckedUpdateWithoutCustomersInput>;
    create: XOR<firmsCreateWithoutCustomersInput, firmsUncheckedCreateWithoutCustomersInput>;
    where?: firmsWhereInput;
  };

  export type firmsUpdateToOneWithWhereWithoutCustomersInput = {
    where?: firmsWhereInput;
    data: XOR<firmsUpdateWithoutCustomersInput, firmsUncheckedUpdateWithoutCustomersInput>;
  };

  export type firmsUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    products?: productsUpdateManyWithoutFirmNestedInput;
    terms_and_conditions?: terms_and_conditionsUpdateManyWithoutFirmNestedInput;
    payment_collections?: payment_collectionsUpdateManyWithoutFirmNestedInput;
    payment_modes?: payment_modesUpdateManyWithoutFirmNestedInput;
    owners?: ownersUpdateManyWithoutFirmNestedInput;
  };

  export type firmsUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    products?: productsUncheckedUpdateManyWithoutFirmNestedInput;
    terms_and_conditions?: terms_and_conditionsUncheckedUpdateManyWithoutFirmNestedInput;
    payment_collections?: payment_collectionsUncheckedUpdateManyWithoutFirmNestedInput;
    payment_modes?: payment_modesUncheckedUpdateManyWithoutFirmNestedInput;
    owners?: ownersUncheckedUpdateManyWithoutFirmNestedInput;
  };

  export type rentalsUpsertWithWhereUniqueWithoutUserInput = {
    where: rentalsWhereUniqueInput;
    update: XOR<rentalsUpdateWithoutUserInput, rentalsUncheckedUpdateWithoutUserInput>;
    create: XOR<rentalsCreateWithoutUserInput, rentalsUncheckedCreateWithoutUserInput>;
  };

  export type rentalsUpdateWithWhereUniqueWithoutUserInput = {
    where: rentalsWhereUniqueInput;
    data: XOR<rentalsUpdateWithoutUserInput, rentalsUncheckedUpdateWithoutUserInput>;
  };

  export type rentalsUpdateManyWithWhereWithoutUserInput = {
    where: rentalsScalarWhereInput;
    data: XOR<rentalsUpdateManyMutationInput, rentalsUncheckedUpdateManyWithoutUserInput>;
  };

  export type rentalsScalarWhereInput = {
    AND?: rentalsScalarWhereInput | rentalsScalarWhereInput[];
    OR?: rentalsScalarWhereInput[];
    NOT?: rentalsScalarWhereInput | rentalsScalarWhereInput[];
    id?: StringFilter<"rentals"> | string;
    user_id?: StringFilter<"rentals"> | string;
    payment_mode_id?: StringFilter<"rentals"> | string;
    invoice_id?: StringFilter<"rentals"> | string;
    invoice_date?: DateTimeFilter<"rentals"> | Date | string;
    invoice_status?: EnumInvoiceStatusFilter<"rentals"> | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFilter<"rentals"> | $Enums.Period;
    discount_amount?: FloatFilter<"rentals"> | number;
    pending_amount?: FloatFilter<"rentals"> | number;
    advance_amount?: FloatFilter<"rentals"> | number;
    deposit_amount?: FloatFilter<"rentals"> | number;
    paid_amount?: FloatFilter<"rentals"> | number;
    total_amount?: FloatFilter<"rentals"> | number;
    fine_amount?: FloatFilter<"rentals"> | number;
    rental_products?: JsonNullableListFilter<"rentals">;
    active_flag?: BoolFilter<"rentals"> | boolean;
    delete_flag?: BoolFilter<"rentals"> | boolean;
    created_by?: StringNullableFilter<"rentals"> | string | null;
    created_at?: DateTimeFilter<"rentals"> | Date | string;
    modified_at?: DateTimeFilter<"rentals"> | Date | string;
    modified_by?: StringNullableFilter<"rentals"> | string | null;
  };

  export type productsCreateWithoutFirmInput = {
    id?: string;
    name: string;
    code: string;
    price?: number;
    sales_price?: number;
    fine?: number;
    deposit?: number;
    description?: string | null;
    rental_period?: $Enums.Period;
    fine_period?: $Enums.Period;
    color?: string | null;
    type?: string | null;
    barcode?: string | null;
    brand?: string | null;
    size?: string | null;
    stock?: number;
    current_rented_stock?: number;
    keywords?: productsCreatekeywordsInput | string[];
    media?: productsCreatemediaInput | string[];
    status?: $Enums.Status;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type productsUncheckedCreateWithoutFirmInput = {
    id?: string;
    name: string;
    code: string;
    price?: number;
    sales_price?: number;
    fine?: number;
    deposit?: number;
    description?: string | null;
    rental_period?: $Enums.Period;
    fine_period?: $Enums.Period;
    color?: string | null;
    type?: string | null;
    barcode?: string | null;
    brand?: string | null;
    size?: string | null;
    stock?: number;
    current_rented_stock?: number;
    keywords?: productsCreatekeywordsInput | string[];
    media?: productsCreatemediaInput | string[];
    status?: $Enums.Status;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type productsCreateOrConnectWithoutFirmInput = {
    where: productsWhereUniqueInput;
    create: XOR<productsCreateWithoutFirmInput, productsUncheckedCreateWithoutFirmInput>;
  };

  export type productsCreateManyFirmInputEnvelope = {
    data: productsCreateManyFirmInput | productsCreateManyFirmInput[];
    skipDuplicates?: boolean;
  };

  export type terms_and_conditionsCreateWithoutFirmInput = {
    id?: string;
    name: string;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type terms_and_conditionsUncheckedCreateWithoutFirmInput = {
    id?: string;
    name: string;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type terms_and_conditionsCreateOrConnectWithoutFirmInput = {
    where: terms_and_conditionsWhereUniqueInput;
    create: XOR<terms_and_conditionsCreateWithoutFirmInput, terms_and_conditionsUncheckedCreateWithoutFirmInput>;
  };

  export type terms_and_conditionsCreateManyFirmInputEnvelope = {
    data: terms_and_conditionsCreateManyFirmInput | terms_and_conditionsCreateManyFirmInput[];
    skipDuplicates?: boolean;
  };

  export type payment_collectionsCreateWithoutFirmInput = {
    id?: string;
    amount?: number;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    payment_mode?: payment_modesCreateNestedOneWithoutPayment_collectionsInput;
    rental?: rentalsCreateNestedOneWithoutPayment_collectionsInput;
  };

  export type payment_collectionsUncheckedCreateWithoutFirmInput = {
    id?: string;
    rental_id: string;
    payment_mode_id: string;
    amount?: number;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type payment_collectionsCreateOrConnectWithoutFirmInput = {
    where: payment_collectionsWhereUniqueInput;
    create: XOR<payment_collectionsCreateWithoutFirmInput, payment_collectionsUncheckedCreateWithoutFirmInput>;
  };

  export type payment_collectionsCreateManyFirmInputEnvelope = {
    data: payment_collectionsCreateManyFirmInput | payment_collectionsCreateManyFirmInput[];
    skipDuplicates?: boolean;
  };

  export type payment_modesCreateWithoutFirmInput = {
    id?: string;
    name: string;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    payment_collections?: payment_collectionsCreateNestedManyWithoutPayment_modeInput;
    rentals?: rentalsCreateNestedManyWithoutPayment_modeInput;
  };

  export type payment_modesUncheckedCreateWithoutFirmInput = {
    id?: string;
    name: string;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    payment_collections?: payment_collectionsUncheckedCreateNestedManyWithoutPayment_modeInput;
    rentals?: rentalsUncheckedCreateNestedManyWithoutPayment_modeInput;
  };

  export type payment_modesCreateOrConnectWithoutFirmInput = {
    where: payment_modesWhereUniqueInput;
    create: XOR<payment_modesCreateWithoutFirmInput, payment_modesUncheckedCreateWithoutFirmInput>;
  };

  export type payment_modesCreateManyFirmInputEnvelope = {
    data: payment_modesCreateManyFirmInput | payment_modesCreateManyFirmInput[];
    skipDuplicates?: boolean;
  };

  export type customersCreateWithoutFirmInput = {
    id?: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: customersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    rentals?: rentalsCreateNestedManyWithoutUserInput;
  };

  export type customersUncheckedCreateWithoutFirmInput = {
    id?: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: customersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    rentals?: rentalsUncheckedCreateNestedManyWithoutUserInput;
  };

  export type customersCreateOrConnectWithoutFirmInput = {
    where: customersWhereUniqueInput;
    create: XOR<customersCreateWithoutFirmInput, customersUncheckedCreateWithoutFirmInput>;
  };

  export type customersCreateManyFirmInputEnvelope = {
    data: customersCreateManyFirmInput | customersCreateManyFirmInput[];
    skipDuplicates?: boolean;
  };

  export type ownersCreateWithoutFirmInput = {
    id?: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: ownersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type ownersUncheckedCreateWithoutFirmInput = {
    id?: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: ownersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type ownersCreateOrConnectWithoutFirmInput = {
    where: ownersWhereUniqueInput;
    create: XOR<ownersCreateWithoutFirmInput, ownersUncheckedCreateWithoutFirmInput>;
  };

  export type ownersCreateManyFirmInputEnvelope = {
    data: ownersCreateManyFirmInput | ownersCreateManyFirmInput[];
    skipDuplicates?: boolean;
  };

  export type productsUpsertWithWhereUniqueWithoutFirmInput = {
    where: productsWhereUniqueInput;
    update: XOR<productsUpdateWithoutFirmInput, productsUncheckedUpdateWithoutFirmInput>;
    create: XOR<productsCreateWithoutFirmInput, productsUncheckedCreateWithoutFirmInput>;
  };

  export type productsUpdateWithWhereUniqueWithoutFirmInput = {
    where: productsWhereUniqueInput;
    data: XOR<productsUpdateWithoutFirmInput, productsUncheckedUpdateWithoutFirmInput>;
  };

  export type productsUpdateManyWithWhereWithoutFirmInput = {
    where: productsScalarWhereInput;
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyWithoutFirmInput>;
  };

  export type productsScalarWhereInput = {
    AND?: productsScalarWhereInput | productsScalarWhereInput[];
    OR?: productsScalarWhereInput[];
    NOT?: productsScalarWhereInput | productsScalarWhereInput[];
    id?: StringFilter<"products"> | string;
    firm_id?: StringFilter<"products"> | string;
    name?: StringFilter<"products"> | string;
    code?: StringFilter<"products"> | string;
    price?: FloatFilter<"products"> | number;
    sales_price?: FloatFilter<"products"> | number;
    fine?: FloatFilter<"products"> | number;
    deposit?: FloatFilter<"products"> | number;
    description?: StringNullableFilter<"products"> | string | null;
    rental_period?: EnumPeriodFilter<"products"> | $Enums.Period;
    fine_period?: EnumPeriodFilter<"products"> | $Enums.Period;
    color?: StringNullableFilter<"products"> | string | null;
    type?: StringNullableFilter<"products"> | string | null;
    barcode?: StringNullableFilter<"products"> | string | null;
    brand?: StringNullableFilter<"products"> | string | null;
    size?: StringNullableFilter<"products"> | string | null;
    stock?: FloatFilter<"products"> | number;
    current_rented_stock?: FloatFilter<"products"> | number;
    keywords?: StringNullableListFilter<"products">;
    media?: StringNullableListFilter<"products">;
    status?: EnumStatusFilter<"products"> | $Enums.Status;
    active_flag?: BoolFilter<"products"> | boolean;
    delete_flag?: BoolFilter<"products"> | boolean;
    modified_at?: DateTimeFilter<"products"> | Date | string;
    created_at?: DateTimeFilter<"products"> | Date | string;
    created_by?: StringNullableFilter<"products"> | string | null;
    modified_by?: StringNullableFilter<"products"> | string | null;
  };

  export type terms_and_conditionsUpsertWithWhereUniqueWithoutFirmInput = {
    where: terms_and_conditionsWhereUniqueInput;
    update: XOR<terms_and_conditionsUpdateWithoutFirmInput, terms_and_conditionsUncheckedUpdateWithoutFirmInput>;
    create: XOR<terms_and_conditionsCreateWithoutFirmInput, terms_and_conditionsUncheckedCreateWithoutFirmInput>;
  };

  export type terms_and_conditionsUpdateWithWhereUniqueWithoutFirmInput = {
    where: terms_and_conditionsWhereUniqueInput;
    data: XOR<terms_and_conditionsUpdateWithoutFirmInput, terms_and_conditionsUncheckedUpdateWithoutFirmInput>;
  };

  export type terms_and_conditionsUpdateManyWithWhereWithoutFirmInput = {
    where: terms_and_conditionsScalarWhereInput;
    data: XOR<terms_and_conditionsUpdateManyMutationInput, terms_and_conditionsUncheckedUpdateManyWithoutFirmInput>;
  };

  export type terms_and_conditionsScalarWhereInput = {
    AND?: terms_and_conditionsScalarWhereInput | terms_and_conditionsScalarWhereInput[];
    OR?: terms_and_conditionsScalarWhereInput[];
    NOT?: terms_and_conditionsScalarWhereInput | terms_and_conditionsScalarWhereInput[];
    id?: StringFilter<"terms_and_conditions"> | string;
    name?: StringFilter<"terms_and_conditions"> | string;
    firm_id?: StringFilter<"terms_and_conditions"> | string;
    description?: StringNullableFilter<"terms_and_conditions"> | string | null;
    active_flag?: BoolFilter<"terms_and_conditions"> | boolean;
    delete_flag?: BoolFilter<"terms_and_conditions"> | boolean;
    modified_at?: DateTimeFilter<"terms_and_conditions"> | Date | string;
    created_at?: DateTimeFilter<"terms_and_conditions"> | Date | string;
    created_by?: StringNullableFilter<"terms_and_conditions"> | string | null;
    modified_by?: StringNullableFilter<"terms_and_conditions"> | string | null;
  };

  export type payment_collectionsUpsertWithWhereUniqueWithoutFirmInput = {
    where: payment_collectionsWhereUniqueInput;
    update: XOR<payment_collectionsUpdateWithoutFirmInput, payment_collectionsUncheckedUpdateWithoutFirmInput>;
    create: XOR<payment_collectionsCreateWithoutFirmInput, payment_collectionsUncheckedCreateWithoutFirmInput>;
  };

  export type payment_collectionsUpdateWithWhereUniqueWithoutFirmInput = {
    where: payment_collectionsWhereUniqueInput;
    data: XOR<payment_collectionsUpdateWithoutFirmInput, payment_collectionsUncheckedUpdateWithoutFirmInput>;
  };

  export type payment_collectionsUpdateManyWithWhereWithoutFirmInput = {
    where: payment_collectionsScalarWhereInput;
    data: XOR<payment_collectionsUpdateManyMutationInput, payment_collectionsUncheckedUpdateManyWithoutFirmInput>;
  };

  export type payment_collectionsScalarWhereInput = {
    AND?: payment_collectionsScalarWhereInput | payment_collectionsScalarWhereInput[];
    OR?: payment_collectionsScalarWhereInput[];
    NOT?: payment_collectionsScalarWhereInput | payment_collectionsScalarWhereInput[];
    id?: StringFilter<"payment_collections"> | string;
    rental_id?: StringFilter<"payment_collections"> | string;
    firm_id?: StringFilter<"payment_collections"> | string;
    payment_mode_id?: StringFilter<"payment_collections"> | string;
    amount?: FloatFilter<"payment_collections"> | number;
    description?: StringNullableFilter<"payment_collections"> | string | null;
    active_flag?: BoolFilter<"payment_collections"> | boolean;
    delete_flag?: BoolFilter<"payment_collections"> | boolean;
    modified_at?: DateTimeFilter<"payment_collections"> | Date | string;
    created_at?: DateTimeFilter<"payment_collections"> | Date | string;
    created_by?: StringNullableFilter<"payment_collections"> | string | null;
    modified_by?: StringNullableFilter<"payment_collections"> | string | null;
  };

  export type payment_modesUpsertWithWhereUniqueWithoutFirmInput = {
    where: payment_modesWhereUniqueInput;
    update: XOR<payment_modesUpdateWithoutFirmInput, payment_modesUncheckedUpdateWithoutFirmInput>;
    create: XOR<payment_modesCreateWithoutFirmInput, payment_modesUncheckedCreateWithoutFirmInput>;
  };

  export type payment_modesUpdateWithWhereUniqueWithoutFirmInput = {
    where: payment_modesWhereUniqueInput;
    data: XOR<payment_modesUpdateWithoutFirmInput, payment_modesUncheckedUpdateWithoutFirmInput>;
  };

  export type payment_modesUpdateManyWithWhereWithoutFirmInput = {
    where: payment_modesScalarWhereInput;
    data: XOR<payment_modesUpdateManyMutationInput, payment_modesUncheckedUpdateManyWithoutFirmInput>;
  };

  export type payment_modesScalarWhereInput = {
    AND?: payment_modesScalarWhereInput | payment_modesScalarWhereInput[];
    OR?: payment_modesScalarWhereInput[];
    NOT?: payment_modesScalarWhereInput | payment_modesScalarWhereInput[];
    id?: StringFilter<"payment_modes"> | string;
    name?: StringFilter<"payment_modes"> | string;
    description?: StringNullableFilter<"payment_modes"> | string | null;
    firm_id?: StringNullableFilter<"payment_modes"> | string | null;
    active_flag?: BoolFilter<"payment_modes"> | boolean;
    delete_flag?: BoolFilter<"payment_modes"> | boolean;
    modified_at?: DateTimeFilter<"payment_modes"> | Date | string;
    created_at?: DateTimeFilter<"payment_modes"> | Date | string;
    created_by?: StringNullableFilter<"payment_modes"> | string | null;
    modified_by?: StringNullableFilter<"payment_modes"> | string | null;
  };

  export type customersUpsertWithWhereUniqueWithoutFirmInput = {
    where: customersWhereUniqueInput;
    update: XOR<customersUpdateWithoutFirmInput, customersUncheckedUpdateWithoutFirmInput>;
    create: XOR<customersCreateWithoutFirmInput, customersUncheckedCreateWithoutFirmInput>;
  };

  export type customersUpdateWithWhereUniqueWithoutFirmInput = {
    where: customersWhereUniqueInput;
    data: XOR<customersUpdateWithoutFirmInput, customersUncheckedUpdateWithoutFirmInput>;
  };

  export type customersUpdateManyWithWhereWithoutFirmInput = {
    where: customersScalarWhereInput;
    data: XOR<customersUpdateManyMutationInput, customersUncheckedUpdateManyWithoutFirmInput>;
  };

  export type customersScalarWhereInput = {
    AND?: customersScalarWhereInput | customersScalarWhereInput[];
    OR?: customersScalarWhereInput[];
    NOT?: customersScalarWhereInput | customersScalarWhereInput[];
    id?: StringFilter<"customers"> | string;
    firm_id?: StringFilter<"customers"> | string;
    full_name?: StringNullableFilter<"customers"> | string | null;
    mobile?: StringNullableFilter<"customers"> | string | null;
    email?: StringNullableFilter<"customers"> | string | null;
    image?: StringNullableFilter<"customers"> | string | null;
    username?: StringNullableFilter<"customers"> | string | null;
    alternate_mobile?: StringNullableFilter<"customers"> | string | null;
    address?: StringNullableFilter<"customers"> | string | null;
    documents?: StringNullableListFilter<"customers">;
    city?: StringNullableFilter<"customers"> | string | null;
    state?: StringNullableFilter<"customers"> | string | null;
    country?: StringNullableFilter<"customers"> | string | null;
    pin_code?: StringNullableFilter<"customers"> | string | null;
    adhaar_number?: StringNullableFilter<"customers"> | string | null;
    driving_license_number?: StringNullableFilter<"customers"> | string | null;
    active_flag?: BoolFilter<"customers"> | boolean;
    delete_flag?: BoolFilter<"customers"> | boolean;
    modified_at?: DateTimeFilter<"customers"> | Date | string;
    created_at?: DateTimeFilter<"customers"> | Date | string;
    created_by?: StringNullableFilter<"customers"> | string | null;
    modified_by?: StringNullableFilter<"customers"> | string | null;
  };

  export type ownersUpsertWithWhereUniqueWithoutFirmInput = {
    where: ownersWhereUniqueInput;
    update: XOR<ownersUpdateWithoutFirmInput, ownersUncheckedUpdateWithoutFirmInput>;
    create: XOR<ownersCreateWithoutFirmInput, ownersUncheckedCreateWithoutFirmInput>;
  };

  export type ownersUpdateWithWhereUniqueWithoutFirmInput = {
    where: ownersWhereUniqueInput;
    data: XOR<ownersUpdateWithoutFirmInput, ownersUncheckedUpdateWithoutFirmInput>;
  };

  export type ownersUpdateManyWithWhereWithoutFirmInput = {
    where: ownersScalarWhereInput;
    data: XOR<ownersUpdateManyMutationInput, ownersUncheckedUpdateManyWithoutFirmInput>;
  };

  export type ownersScalarWhereInput = {
    AND?: ownersScalarWhereInput | ownersScalarWhereInput[];
    OR?: ownersScalarWhereInput[];
    NOT?: ownersScalarWhereInput | ownersScalarWhereInput[];
    id?: StringFilter<"owners"> | string;
    firm_id?: StringFilter<"owners"> | string;
    full_name?: StringNullableFilter<"owners"> | string | null;
    mobile?: StringNullableFilter<"owners"> | string | null;
    email?: StringNullableFilter<"owners"> | string | null;
    image?: StringNullableFilter<"owners"> | string | null;
    username?: StringNullableFilter<"owners"> | string | null;
    alternate_mobile?: StringNullableFilter<"owners"> | string | null;
    address?: StringNullableFilter<"owners"> | string | null;
    documents?: StringNullableListFilter<"owners">;
    city?: StringNullableFilter<"owners"> | string | null;
    state?: StringNullableFilter<"owners"> | string | null;
    country?: StringNullableFilter<"owners"> | string | null;
    pin_code?: StringNullableFilter<"owners"> | string | null;
    adhaar_number?: StringNullableFilter<"owners"> | string | null;
    driving_license_number?: StringNullableFilter<"owners"> | string | null;
    active_flag?: BoolFilter<"owners"> | boolean;
    delete_flag?: BoolFilter<"owners"> | boolean;
    modified_at?: DateTimeFilter<"owners"> | Date | string;
    created_at?: DateTimeFilter<"owners"> | Date | string;
    created_by?: StringNullableFilter<"owners"> | string | null;
    modified_by?: StringNullableFilter<"owners"> | string | null;
  };

  export type firmsCreateWithoutOwnersInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    products?: productsCreateNestedManyWithoutFirmInput;
    terms_and_conditions?: terms_and_conditionsCreateNestedManyWithoutFirmInput;
    payment_collections?: payment_collectionsCreateNestedManyWithoutFirmInput;
    payment_modes?: payment_modesCreateNestedManyWithoutFirmInput;
    customers?: customersCreateNestedManyWithoutFirmInput;
  };

  export type firmsUncheckedCreateWithoutOwnersInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    products?: productsUncheckedCreateNestedManyWithoutFirmInput;
    terms_and_conditions?: terms_and_conditionsUncheckedCreateNestedManyWithoutFirmInput;
    payment_collections?: payment_collectionsUncheckedCreateNestedManyWithoutFirmInput;
    payment_modes?: payment_modesUncheckedCreateNestedManyWithoutFirmInput;
    customers?: customersUncheckedCreateNestedManyWithoutFirmInput;
  };

  export type firmsCreateOrConnectWithoutOwnersInput = {
    where: firmsWhereUniqueInput;
    create: XOR<firmsCreateWithoutOwnersInput, firmsUncheckedCreateWithoutOwnersInput>;
  };

  export type firmsUpsertWithoutOwnersInput = {
    update: XOR<firmsUpdateWithoutOwnersInput, firmsUncheckedUpdateWithoutOwnersInput>;
    create: XOR<firmsCreateWithoutOwnersInput, firmsUncheckedCreateWithoutOwnersInput>;
    where?: firmsWhereInput;
  };

  export type firmsUpdateToOneWithWhereWithoutOwnersInput = {
    where?: firmsWhereInput;
    data: XOR<firmsUpdateWithoutOwnersInput, firmsUncheckedUpdateWithoutOwnersInput>;
  };

  export type firmsUpdateWithoutOwnersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    products?: productsUpdateManyWithoutFirmNestedInput;
    terms_and_conditions?: terms_and_conditionsUpdateManyWithoutFirmNestedInput;
    payment_collections?: payment_collectionsUpdateManyWithoutFirmNestedInput;
    payment_modes?: payment_modesUpdateManyWithoutFirmNestedInput;
    customers?: customersUpdateManyWithoutFirmNestedInput;
  };

  export type firmsUncheckedUpdateWithoutOwnersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    products?: productsUncheckedUpdateManyWithoutFirmNestedInput;
    terms_and_conditions?: terms_and_conditionsUncheckedUpdateManyWithoutFirmNestedInput;
    payment_collections?: payment_collectionsUncheckedUpdateManyWithoutFirmNestedInput;
    payment_modes?: payment_modesUncheckedUpdateManyWithoutFirmNestedInput;
    customers?: customersUncheckedUpdateManyWithoutFirmNestedInput;
  };

  export type firmsCreateWithoutPayment_collectionsInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    products?: productsCreateNestedManyWithoutFirmInput;
    terms_and_conditions?: terms_and_conditionsCreateNestedManyWithoutFirmInput;
    payment_modes?: payment_modesCreateNestedManyWithoutFirmInput;
    customers?: customersCreateNestedManyWithoutFirmInput;
    owners?: ownersCreateNestedManyWithoutFirmInput;
  };

  export type firmsUncheckedCreateWithoutPayment_collectionsInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    products?: productsUncheckedCreateNestedManyWithoutFirmInput;
    terms_and_conditions?: terms_and_conditionsUncheckedCreateNestedManyWithoutFirmInput;
    payment_modes?: payment_modesUncheckedCreateNestedManyWithoutFirmInput;
    customers?: customersUncheckedCreateNestedManyWithoutFirmInput;
    owners?: ownersUncheckedCreateNestedManyWithoutFirmInput;
  };

  export type firmsCreateOrConnectWithoutPayment_collectionsInput = {
    where: firmsWhereUniqueInput;
    create: XOR<firmsCreateWithoutPayment_collectionsInput, firmsUncheckedCreateWithoutPayment_collectionsInput>;
  };

  export type payment_modesCreateWithoutPayment_collectionsInput = {
    id?: string;
    name: string;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    firm?: firmsCreateNestedOneWithoutPayment_modesInput;
    rentals?: rentalsCreateNestedManyWithoutPayment_modeInput;
  };

  export type payment_modesUncheckedCreateWithoutPayment_collectionsInput = {
    id?: string;
    name: string;
    description?: string | null;
    firm_id?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    rentals?: rentalsUncheckedCreateNestedManyWithoutPayment_modeInput;
  };

  export type payment_modesCreateOrConnectWithoutPayment_collectionsInput = {
    where: payment_modesWhereUniqueInput;
    create: XOR<
      payment_modesCreateWithoutPayment_collectionsInput,
      payment_modesUncheckedCreateWithoutPayment_collectionsInput
    >;
  };

  export type rentalsCreateWithoutPayment_collectionsInput = {
    id?: string;
    invoice_id: string;
    invoice_date?: Date | string;
    invoice_status?: $Enums.InvoiceStatus;
    rental_period?: $Enums.Period;
    discount_amount?: number;
    pending_amount?: number;
    advance_amount?: number;
    deposit_amount?: number;
    paid_amount?: number;
    total_amount?: number;
    fine_amount?: number;
    rental_products?: rentalsCreaterental_productsInput | InputJsonValue[];
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
    user?: customersCreateNestedOneWithoutRentalsInput;
    payment_mode?: payment_modesCreateNestedOneWithoutRentalsInput;
  };

  export type rentalsUncheckedCreateWithoutPayment_collectionsInput = {
    id?: string;
    user_id: string;
    payment_mode_id: string;
    invoice_id: string;
    invoice_date?: Date | string;
    invoice_status?: $Enums.InvoiceStatus;
    rental_period?: $Enums.Period;
    discount_amount?: number;
    pending_amount?: number;
    advance_amount?: number;
    deposit_amount?: number;
    paid_amount?: number;
    total_amount?: number;
    fine_amount?: number;
    rental_products?: rentalsCreaterental_productsInput | InputJsonValue[];
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
  };

  export type rentalsCreateOrConnectWithoutPayment_collectionsInput = {
    where: rentalsWhereUniqueInput;
    create: XOR<rentalsCreateWithoutPayment_collectionsInput, rentalsUncheckedCreateWithoutPayment_collectionsInput>;
  };

  export type firmsUpsertWithoutPayment_collectionsInput = {
    update: XOR<firmsUpdateWithoutPayment_collectionsInput, firmsUncheckedUpdateWithoutPayment_collectionsInput>;
    create: XOR<firmsCreateWithoutPayment_collectionsInput, firmsUncheckedCreateWithoutPayment_collectionsInput>;
    where?: firmsWhereInput;
  };

  export type firmsUpdateToOneWithWhereWithoutPayment_collectionsInput = {
    where?: firmsWhereInput;
    data: XOR<firmsUpdateWithoutPayment_collectionsInput, firmsUncheckedUpdateWithoutPayment_collectionsInput>;
  };

  export type firmsUpdateWithoutPayment_collectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    products?: productsUpdateManyWithoutFirmNestedInput;
    terms_and_conditions?: terms_and_conditionsUpdateManyWithoutFirmNestedInput;
    payment_modes?: payment_modesUpdateManyWithoutFirmNestedInput;
    customers?: customersUpdateManyWithoutFirmNestedInput;
    owners?: ownersUpdateManyWithoutFirmNestedInput;
  };

  export type firmsUncheckedUpdateWithoutPayment_collectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    products?: productsUncheckedUpdateManyWithoutFirmNestedInput;
    terms_and_conditions?: terms_and_conditionsUncheckedUpdateManyWithoutFirmNestedInput;
    payment_modes?: payment_modesUncheckedUpdateManyWithoutFirmNestedInput;
    customers?: customersUncheckedUpdateManyWithoutFirmNestedInput;
    owners?: ownersUncheckedUpdateManyWithoutFirmNestedInput;
  };

  export type payment_modesUpsertWithoutPayment_collectionsInput = {
    update: XOR<
      payment_modesUpdateWithoutPayment_collectionsInput,
      payment_modesUncheckedUpdateWithoutPayment_collectionsInput
    >;
    create: XOR<
      payment_modesCreateWithoutPayment_collectionsInput,
      payment_modesUncheckedCreateWithoutPayment_collectionsInput
    >;
    where?: payment_modesWhereInput;
  };

  export type payment_modesUpdateToOneWithWhereWithoutPayment_collectionsInput = {
    where?: payment_modesWhereInput;
    data: XOR<
      payment_modesUpdateWithoutPayment_collectionsInput,
      payment_modesUncheckedUpdateWithoutPayment_collectionsInput
    >;
  };

  export type payment_modesUpdateWithoutPayment_collectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    firm?: firmsUpdateOneWithoutPayment_modesNestedInput;
    rentals?: rentalsUpdateManyWithoutPayment_modeNestedInput;
  };

  export type payment_modesUncheckedUpdateWithoutPayment_collectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    firm_id?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    rentals?: rentalsUncheckedUpdateManyWithoutPayment_modeNestedInput;
  };

  export type rentalsUpsertWithoutPayment_collectionsInput = {
    update: XOR<rentalsUpdateWithoutPayment_collectionsInput, rentalsUncheckedUpdateWithoutPayment_collectionsInput>;
    create: XOR<rentalsCreateWithoutPayment_collectionsInput, rentalsUncheckedCreateWithoutPayment_collectionsInput>;
    where?: rentalsWhereInput;
  };

  export type rentalsUpdateToOneWithWhereWithoutPayment_collectionsInput = {
    where?: rentalsWhereInput;
    data: XOR<rentalsUpdateWithoutPayment_collectionsInput, rentalsUncheckedUpdateWithoutPayment_collectionsInput>;
  };

  export type rentalsUpdateWithoutPayment_collectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoice_id?: StringFieldUpdateOperationsInput | string;
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice_status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    discount_amount?: FloatFieldUpdateOperationsInput | number;
    pending_amount?: FloatFieldUpdateOperationsInput | number;
    advance_amount?: FloatFieldUpdateOperationsInput | number;
    deposit_amount?: FloatFieldUpdateOperationsInput | number;
    paid_amount?: FloatFieldUpdateOperationsInput | number;
    total_amount?: FloatFieldUpdateOperationsInput | number;
    fine_amount?: FloatFieldUpdateOperationsInput | number;
    rental_products?: rentalsUpdaterental_productsInput | InputJsonValue[];
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    user?: customersUpdateOneWithoutRentalsNestedInput;
    payment_mode?: payment_modesUpdateOneWithoutRentalsNestedInput;
  };

  export type rentalsUncheckedUpdateWithoutPayment_collectionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: StringFieldUpdateOperationsInput | string;
    payment_mode_id?: StringFieldUpdateOperationsInput | string;
    invoice_id?: StringFieldUpdateOperationsInput | string;
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice_status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    discount_amount?: FloatFieldUpdateOperationsInput | number;
    pending_amount?: FloatFieldUpdateOperationsInput | number;
    advance_amount?: FloatFieldUpdateOperationsInput | number;
    deposit_amount?: FloatFieldUpdateOperationsInput | number;
    paid_amount?: FloatFieldUpdateOperationsInput | number;
    total_amount?: FloatFieldUpdateOperationsInput | number;
    fine_amount?: FloatFieldUpdateOperationsInput | number;
    rental_products?: rentalsUpdaterental_productsInput | InputJsonValue[];
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type firmsCreateWithoutPayment_modesInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    products?: productsCreateNestedManyWithoutFirmInput;
    terms_and_conditions?: terms_and_conditionsCreateNestedManyWithoutFirmInput;
    payment_collections?: payment_collectionsCreateNestedManyWithoutFirmInput;
    customers?: customersCreateNestedManyWithoutFirmInput;
    owners?: ownersCreateNestedManyWithoutFirmInput;
  };

  export type firmsUncheckedCreateWithoutPayment_modesInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    products?: productsUncheckedCreateNestedManyWithoutFirmInput;
    terms_and_conditions?: terms_and_conditionsUncheckedCreateNestedManyWithoutFirmInput;
    payment_collections?: payment_collectionsUncheckedCreateNestedManyWithoutFirmInput;
    customers?: customersUncheckedCreateNestedManyWithoutFirmInput;
    owners?: ownersUncheckedCreateNestedManyWithoutFirmInput;
  };

  export type firmsCreateOrConnectWithoutPayment_modesInput = {
    where: firmsWhereUniqueInput;
    create: XOR<firmsCreateWithoutPayment_modesInput, firmsUncheckedCreateWithoutPayment_modesInput>;
  };

  export type payment_collectionsCreateWithoutPayment_modeInput = {
    id?: string;
    amount?: number;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    firm?: firmsCreateNestedOneWithoutPayment_collectionsInput;
    rental?: rentalsCreateNestedOneWithoutPayment_collectionsInput;
  };

  export type payment_collectionsUncheckedCreateWithoutPayment_modeInput = {
    id?: string;
    rental_id: string;
    firm_id: string;
    amount?: number;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type payment_collectionsCreateOrConnectWithoutPayment_modeInput = {
    where: payment_collectionsWhereUniqueInput;
    create: XOR<
      payment_collectionsCreateWithoutPayment_modeInput,
      payment_collectionsUncheckedCreateWithoutPayment_modeInput
    >;
  };

  export type payment_collectionsCreateManyPayment_modeInputEnvelope = {
    data: payment_collectionsCreateManyPayment_modeInput | payment_collectionsCreateManyPayment_modeInput[];
    skipDuplicates?: boolean;
  };

  export type rentalsCreateWithoutPayment_modeInput = {
    id?: string;
    invoice_id: string;
    invoice_date?: Date | string;
    invoice_status?: $Enums.InvoiceStatus;
    rental_period?: $Enums.Period;
    discount_amount?: number;
    pending_amount?: number;
    advance_amount?: number;
    deposit_amount?: number;
    paid_amount?: number;
    total_amount?: number;
    fine_amount?: number;
    rental_products?: rentalsCreaterental_productsInput | InputJsonValue[];
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
    payment_collections?: payment_collectionsCreateNestedManyWithoutRentalInput;
    user?: customersCreateNestedOneWithoutRentalsInput;
  };

  export type rentalsUncheckedCreateWithoutPayment_modeInput = {
    id?: string;
    user_id: string;
    invoice_id: string;
    invoice_date?: Date | string;
    invoice_status?: $Enums.InvoiceStatus;
    rental_period?: $Enums.Period;
    discount_amount?: number;
    pending_amount?: number;
    advance_amount?: number;
    deposit_amount?: number;
    paid_amount?: number;
    total_amount?: number;
    fine_amount?: number;
    rental_products?: rentalsCreaterental_productsInput | InputJsonValue[];
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
    payment_collections?: payment_collectionsUncheckedCreateNestedManyWithoutRentalInput;
  };

  export type rentalsCreateOrConnectWithoutPayment_modeInput = {
    where: rentalsWhereUniqueInput;
    create: XOR<rentalsCreateWithoutPayment_modeInput, rentalsUncheckedCreateWithoutPayment_modeInput>;
  };

  export type rentalsCreateManyPayment_modeInputEnvelope = {
    data: rentalsCreateManyPayment_modeInput | rentalsCreateManyPayment_modeInput[];
    skipDuplicates?: boolean;
  };

  export type firmsUpsertWithoutPayment_modesInput = {
    update: XOR<firmsUpdateWithoutPayment_modesInput, firmsUncheckedUpdateWithoutPayment_modesInput>;
    create: XOR<firmsCreateWithoutPayment_modesInput, firmsUncheckedCreateWithoutPayment_modesInput>;
    where?: firmsWhereInput;
  };

  export type firmsUpdateToOneWithWhereWithoutPayment_modesInput = {
    where?: firmsWhereInput;
    data: XOR<firmsUpdateWithoutPayment_modesInput, firmsUncheckedUpdateWithoutPayment_modesInput>;
  };

  export type firmsUpdateWithoutPayment_modesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    products?: productsUpdateManyWithoutFirmNestedInput;
    terms_and_conditions?: terms_and_conditionsUpdateManyWithoutFirmNestedInput;
    payment_collections?: payment_collectionsUpdateManyWithoutFirmNestedInput;
    customers?: customersUpdateManyWithoutFirmNestedInput;
    owners?: ownersUpdateManyWithoutFirmNestedInput;
  };

  export type firmsUncheckedUpdateWithoutPayment_modesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    products?: productsUncheckedUpdateManyWithoutFirmNestedInput;
    terms_and_conditions?: terms_and_conditionsUncheckedUpdateManyWithoutFirmNestedInput;
    payment_collections?: payment_collectionsUncheckedUpdateManyWithoutFirmNestedInput;
    customers?: customersUncheckedUpdateManyWithoutFirmNestedInput;
    owners?: ownersUncheckedUpdateManyWithoutFirmNestedInput;
  };

  export type payment_collectionsUpsertWithWhereUniqueWithoutPayment_modeInput = {
    where: payment_collectionsWhereUniqueInput;
    update: XOR<
      payment_collectionsUpdateWithoutPayment_modeInput,
      payment_collectionsUncheckedUpdateWithoutPayment_modeInput
    >;
    create: XOR<
      payment_collectionsCreateWithoutPayment_modeInput,
      payment_collectionsUncheckedCreateWithoutPayment_modeInput
    >;
  };

  export type payment_collectionsUpdateWithWhereUniqueWithoutPayment_modeInput = {
    where: payment_collectionsWhereUniqueInput;
    data: XOR<
      payment_collectionsUpdateWithoutPayment_modeInput,
      payment_collectionsUncheckedUpdateWithoutPayment_modeInput
    >;
  };

  export type payment_collectionsUpdateManyWithWhereWithoutPayment_modeInput = {
    where: payment_collectionsScalarWhereInput;
    data: XOR<
      payment_collectionsUpdateManyMutationInput,
      payment_collectionsUncheckedUpdateManyWithoutPayment_modeInput
    >;
  };

  export type rentalsUpsertWithWhereUniqueWithoutPayment_modeInput = {
    where: rentalsWhereUniqueInput;
    update: XOR<rentalsUpdateWithoutPayment_modeInput, rentalsUncheckedUpdateWithoutPayment_modeInput>;
    create: XOR<rentalsCreateWithoutPayment_modeInput, rentalsUncheckedCreateWithoutPayment_modeInput>;
  };

  export type rentalsUpdateWithWhereUniqueWithoutPayment_modeInput = {
    where: rentalsWhereUniqueInput;
    data: XOR<rentalsUpdateWithoutPayment_modeInput, rentalsUncheckedUpdateWithoutPayment_modeInput>;
  };

  export type rentalsUpdateManyWithWhereWithoutPayment_modeInput = {
    where: rentalsScalarWhereInput;
    data: XOR<rentalsUpdateManyMutationInput, rentalsUncheckedUpdateManyWithoutPayment_modeInput>;
  };

  export type firmsCreateWithoutProductsInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    terms_and_conditions?: terms_and_conditionsCreateNestedManyWithoutFirmInput;
    payment_collections?: payment_collectionsCreateNestedManyWithoutFirmInput;
    payment_modes?: payment_modesCreateNestedManyWithoutFirmInput;
    customers?: customersCreateNestedManyWithoutFirmInput;
    owners?: ownersCreateNestedManyWithoutFirmInput;
  };

  export type firmsUncheckedCreateWithoutProductsInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    terms_and_conditions?: terms_and_conditionsUncheckedCreateNestedManyWithoutFirmInput;
    payment_collections?: payment_collectionsUncheckedCreateNestedManyWithoutFirmInput;
    payment_modes?: payment_modesUncheckedCreateNestedManyWithoutFirmInput;
    customers?: customersUncheckedCreateNestedManyWithoutFirmInput;
    owners?: ownersUncheckedCreateNestedManyWithoutFirmInput;
  };

  export type firmsCreateOrConnectWithoutProductsInput = {
    where: firmsWhereUniqueInput;
    create: XOR<firmsCreateWithoutProductsInput, firmsUncheckedCreateWithoutProductsInput>;
  };

  export type firmsUpsertWithoutProductsInput = {
    update: XOR<firmsUpdateWithoutProductsInput, firmsUncheckedUpdateWithoutProductsInput>;
    create: XOR<firmsCreateWithoutProductsInput, firmsUncheckedCreateWithoutProductsInput>;
    where?: firmsWhereInput;
  };

  export type firmsUpdateToOneWithWhereWithoutProductsInput = {
    where?: firmsWhereInput;
    data: XOR<firmsUpdateWithoutProductsInput, firmsUncheckedUpdateWithoutProductsInput>;
  };

  export type firmsUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    terms_and_conditions?: terms_and_conditionsUpdateManyWithoutFirmNestedInput;
    payment_collections?: payment_collectionsUpdateManyWithoutFirmNestedInput;
    payment_modes?: payment_modesUpdateManyWithoutFirmNestedInput;
    customers?: customersUpdateManyWithoutFirmNestedInput;
    owners?: ownersUpdateManyWithoutFirmNestedInput;
  };

  export type firmsUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    terms_and_conditions?: terms_and_conditionsUncheckedUpdateManyWithoutFirmNestedInput;
    payment_collections?: payment_collectionsUncheckedUpdateManyWithoutFirmNestedInput;
    payment_modes?: payment_modesUncheckedUpdateManyWithoutFirmNestedInput;
    customers?: customersUncheckedUpdateManyWithoutFirmNestedInput;
    owners?: ownersUncheckedUpdateManyWithoutFirmNestedInput;
  };

  export type payment_collectionsCreateWithoutRentalInput = {
    id?: string;
    amount?: number;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    firm?: firmsCreateNestedOneWithoutPayment_collectionsInput;
    payment_mode?: payment_modesCreateNestedOneWithoutPayment_collectionsInput;
  };

  export type payment_collectionsUncheckedCreateWithoutRentalInput = {
    id?: string;
    firm_id: string;
    payment_mode_id: string;
    amount?: number;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type payment_collectionsCreateOrConnectWithoutRentalInput = {
    where: payment_collectionsWhereUniqueInput;
    create: XOR<payment_collectionsCreateWithoutRentalInput, payment_collectionsUncheckedCreateWithoutRentalInput>;
  };

  export type payment_collectionsCreateManyRentalInputEnvelope = {
    data: payment_collectionsCreateManyRentalInput | payment_collectionsCreateManyRentalInput[];
    skipDuplicates?: boolean;
  };

  export type customersCreateWithoutRentalsInput = {
    id?: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: customersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    firm: firmsCreateNestedOneWithoutCustomersInput;
  };

  export type customersUncheckedCreateWithoutRentalsInput = {
    id?: string;
    firm_id: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: customersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type customersCreateOrConnectWithoutRentalsInput = {
    where: customersWhereUniqueInput;
    create: XOR<customersCreateWithoutRentalsInput, customersUncheckedCreateWithoutRentalsInput>;
  };

  export type payment_modesCreateWithoutRentalsInput = {
    id?: string;
    name: string;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    firm?: firmsCreateNestedOneWithoutPayment_modesInput;
    payment_collections?: payment_collectionsCreateNestedManyWithoutPayment_modeInput;
  };

  export type payment_modesUncheckedCreateWithoutRentalsInput = {
    id?: string;
    name: string;
    description?: string | null;
    firm_id?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    payment_collections?: payment_collectionsUncheckedCreateNestedManyWithoutPayment_modeInput;
  };

  export type payment_modesCreateOrConnectWithoutRentalsInput = {
    where: payment_modesWhereUniqueInput;
    create: XOR<payment_modesCreateWithoutRentalsInput, payment_modesUncheckedCreateWithoutRentalsInput>;
  };

  export type payment_collectionsUpsertWithWhereUniqueWithoutRentalInput = {
    where: payment_collectionsWhereUniqueInput;
    update: XOR<payment_collectionsUpdateWithoutRentalInput, payment_collectionsUncheckedUpdateWithoutRentalInput>;
    create: XOR<payment_collectionsCreateWithoutRentalInput, payment_collectionsUncheckedCreateWithoutRentalInput>;
  };

  export type payment_collectionsUpdateWithWhereUniqueWithoutRentalInput = {
    where: payment_collectionsWhereUniqueInput;
    data: XOR<payment_collectionsUpdateWithoutRentalInput, payment_collectionsUncheckedUpdateWithoutRentalInput>;
  };

  export type payment_collectionsUpdateManyWithWhereWithoutRentalInput = {
    where: payment_collectionsScalarWhereInput;
    data: XOR<payment_collectionsUpdateManyMutationInput, payment_collectionsUncheckedUpdateManyWithoutRentalInput>;
  };

  export type customersUpsertWithoutRentalsInput = {
    update: XOR<customersUpdateWithoutRentalsInput, customersUncheckedUpdateWithoutRentalsInput>;
    create: XOR<customersCreateWithoutRentalsInput, customersUncheckedCreateWithoutRentalsInput>;
    where?: customersWhereInput;
  };

  export type customersUpdateToOneWithWhereWithoutRentalsInput = {
    where?: customersWhereInput;
    data: XOR<customersUpdateWithoutRentalsInput, customersUncheckedUpdateWithoutRentalsInput>;
  };

  export type customersUpdateWithoutRentalsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: customersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    firm?: firmsUpdateOneRequiredWithoutCustomersNestedInput;
  };

  export type customersUncheckedUpdateWithoutRentalsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: customersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_modesUpsertWithoutRentalsInput = {
    update: XOR<payment_modesUpdateWithoutRentalsInput, payment_modesUncheckedUpdateWithoutRentalsInput>;
    create: XOR<payment_modesCreateWithoutRentalsInput, payment_modesUncheckedCreateWithoutRentalsInput>;
    where?: payment_modesWhereInput;
  };

  export type payment_modesUpdateToOneWithWhereWithoutRentalsInput = {
    where?: payment_modesWhereInput;
    data: XOR<payment_modesUpdateWithoutRentalsInput, payment_modesUncheckedUpdateWithoutRentalsInput>;
  };

  export type payment_modesUpdateWithoutRentalsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    firm?: firmsUpdateOneWithoutPayment_modesNestedInput;
    payment_collections?: payment_collectionsUpdateManyWithoutPayment_modeNestedInput;
  };

  export type payment_modesUncheckedUpdateWithoutRentalsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    firm_id?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_collections?: payment_collectionsUncheckedUpdateManyWithoutPayment_modeNestedInput;
  };

  export type firmsCreateWithoutTerms_and_conditionsInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    products?: productsCreateNestedManyWithoutFirmInput;
    payment_collections?: payment_collectionsCreateNestedManyWithoutFirmInput;
    payment_modes?: payment_modesCreateNestedManyWithoutFirmInput;
    customers?: customersCreateNestedManyWithoutFirmInput;
    owners?: ownersCreateNestedManyWithoutFirmInput;
  };

  export type firmsUncheckedCreateWithoutTerms_and_conditionsInput = {
    id?: string;
    name: string;
    mobile?: string | null;
    email?: string | null;
    media?: firmsCreatemediaInput | string[];
    gst_number?: string | null;
    address?: string | null;
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
    products?: productsUncheckedCreateNestedManyWithoutFirmInput;
    payment_collections?: payment_collectionsUncheckedCreateNestedManyWithoutFirmInput;
    payment_modes?: payment_modesUncheckedCreateNestedManyWithoutFirmInput;
    customers?: customersUncheckedCreateNestedManyWithoutFirmInput;
    owners?: ownersUncheckedCreateNestedManyWithoutFirmInput;
  };

  export type firmsCreateOrConnectWithoutTerms_and_conditionsInput = {
    where: firmsWhereUniqueInput;
    create: XOR<firmsCreateWithoutTerms_and_conditionsInput, firmsUncheckedCreateWithoutTerms_and_conditionsInput>;
  };

  export type firmsUpsertWithoutTerms_and_conditionsInput = {
    update: XOR<firmsUpdateWithoutTerms_and_conditionsInput, firmsUncheckedUpdateWithoutTerms_and_conditionsInput>;
    create: XOR<firmsCreateWithoutTerms_and_conditionsInput, firmsUncheckedCreateWithoutTerms_and_conditionsInput>;
    where?: firmsWhereInput;
  };

  export type firmsUpdateToOneWithWhereWithoutTerms_and_conditionsInput = {
    where?: firmsWhereInput;
    data: XOR<firmsUpdateWithoutTerms_and_conditionsInput, firmsUncheckedUpdateWithoutTerms_and_conditionsInput>;
  };

  export type firmsUpdateWithoutTerms_and_conditionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    products?: productsUpdateManyWithoutFirmNestedInput;
    payment_collections?: payment_collectionsUpdateManyWithoutFirmNestedInput;
    payment_modes?: payment_modesUpdateManyWithoutFirmNestedInput;
    customers?: customersUpdateManyWithoutFirmNestedInput;
    owners?: ownersUpdateManyWithoutFirmNestedInput;
  };

  export type firmsUncheckedUpdateWithoutTerms_and_conditionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    media?: firmsUpdatemediaInput | string[];
    gst_number?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    products?: productsUncheckedUpdateManyWithoutFirmNestedInput;
    payment_collections?: payment_collectionsUncheckedUpdateManyWithoutFirmNestedInput;
    payment_modes?: payment_modesUncheckedUpdateManyWithoutFirmNestedInput;
    customers?: customersUncheckedUpdateManyWithoutFirmNestedInput;
    owners?: ownersUncheckedUpdateManyWithoutFirmNestedInput;
  };

  export type rentalsCreateManyUserInput = {
    id?: string;
    payment_mode_id: string;
    invoice_id: string;
    invoice_date?: Date | string;
    invoice_status?: $Enums.InvoiceStatus;
    rental_period?: $Enums.Period;
    discount_amount?: number;
    pending_amount?: number;
    advance_amount?: number;
    deposit_amount?: number;
    paid_amount?: number;
    total_amount?: number;
    fine_amount?: number;
    rental_products?: rentalsCreaterental_productsInput | InputJsonValue[];
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
  };

  export type rentalsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoice_id?: StringFieldUpdateOperationsInput | string;
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice_status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    discount_amount?: FloatFieldUpdateOperationsInput | number;
    pending_amount?: FloatFieldUpdateOperationsInput | number;
    advance_amount?: FloatFieldUpdateOperationsInput | number;
    deposit_amount?: FloatFieldUpdateOperationsInput | number;
    paid_amount?: FloatFieldUpdateOperationsInput | number;
    total_amount?: FloatFieldUpdateOperationsInput | number;
    fine_amount?: FloatFieldUpdateOperationsInput | number;
    rental_products?: rentalsUpdaterental_productsInput | InputJsonValue[];
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_collections?: payment_collectionsUpdateManyWithoutRentalNestedInput;
    payment_mode?: payment_modesUpdateOneWithoutRentalsNestedInput;
  };

  export type rentalsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    payment_mode_id?: StringFieldUpdateOperationsInput | string;
    invoice_id?: StringFieldUpdateOperationsInput | string;
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice_status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    discount_amount?: FloatFieldUpdateOperationsInput | number;
    pending_amount?: FloatFieldUpdateOperationsInput | number;
    advance_amount?: FloatFieldUpdateOperationsInput | number;
    deposit_amount?: FloatFieldUpdateOperationsInput | number;
    paid_amount?: FloatFieldUpdateOperationsInput | number;
    total_amount?: FloatFieldUpdateOperationsInput | number;
    fine_amount?: FloatFieldUpdateOperationsInput | number;
    rental_products?: rentalsUpdaterental_productsInput | InputJsonValue[];
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_collections?: payment_collectionsUncheckedUpdateManyWithoutRentalNestedInput;
  };

  export type rentalsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    payment_mode_id?: StringFieldUpdateOperationsInput | string;
    invoice_id?: StringFieldUpdateOperationsInput | string;
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice_status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    discount_amount?: FloatFieldUpdateOperationsInput | number;
    pending_amount?: FloatFieldUpdateOperationsInput | number;
    advance_amount?: FloatFieldUpdateOperationsInput | number;
    deposit_amount?: FloatFieldUpdateOperationsInput | number;
    paid_amount?: FloatFieldUpdateOperationsInput | number;
    total_amount?: FloatFieldUpdateOperationsInput | number;
    fine_amount?: FloatFieldUpdateOperationsInput | number;
    rental_products?: rentalsUpdaterental_productsInput | InputJsonValue[];
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type productsCreateManyFirmInput = {
    id?: string;
    name: string;
    code: string;
    price?: number;
    sales_price?: number;
    fine?: number;
    deposit?: number;
    description?: string | null;
    rental_period?: $Enums.Period;
    fine_period?: $Enums.Period;
    color?: string | null;
    type?: string | null;
    barcode?: string | null;
    brand?: string | null;
    size?: string | null;
    stock?: number;
    current_rented_stock?: number;
    keywords?: productsCreatekeywordsInput | string[];
    media?: productsCreatemediaInput | string[];
    status?: $Enums.Status;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type terms_and_conditionsCreateManyFirmInput = {
    id?: string;
    name: string;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type payment_collectionsCreateManyFirmInput = {
    id?: string;
    rental_id: string;
    payment_mode_id: string;
    amount?: number;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type payment_modesCreateManyFirmInput = {
    id?: string;
    name: string;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type customersCreateManyFirmInput = {
    id?: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: customersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type ownersCreateManyFirmInput = {
    id?: string;
    full_name?: string | null;
    mobile?: string | null;
    email?: string | null;
    image?: string | null;
    username?: string | null;
    alternate_mobile?: string | null;
    address?: string | null;
    documents?: ownersCreatedocumentsInput | string[];
    city?: string | null;
    state?: string | null;
    country?: string | null;
    pin_code?: string | null;
    adhaar_number?: string | null;
    driving_license_number?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type productsUpdateWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    sales_price?: FloatFieldUpdateOperationsInput | number;
    fine?: FloatFieldUpdateOperationsInput | number;
    deposit?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    fine_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    barcode?: NullableStringFieldUpdateOperationsInput | string | null;
    brand?: NullableStringFieldUpdateOperationsInput | string | null;
    size?: NullableStringFieldUpdateOperationsInput | string | null;
    stock?: FloatFieldUpdateOperationsInput | number;
    current_rented_stock?: FloatFieldUpdateOperationsInput | number;
    keywords?: productsUpdatekeywordsInput | string[];
    media?: productsUpdatemediaInput | string[];
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type productsUncheckedUpdateWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    sales_price?: FloatFieldUpdateOperationsInput | number;
    fine?: FloatFieldUpdateOperationsInput | number;
    deposit?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    fine_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    barcode?: NullableStringFieldUpdateOperationsInput | string | null;
    brand?: NullableStringFieldUpdateOperationsInput | string | null;
    size?: NullableStringFieldUpdateOperationsInput | string | null;
    stock?: FloatFieldUpdateOperationsInput | number;
    current_rented_stock?: FloatFieldUpdateOperationsInput | number;
    keywords?: productsUpdatekeywordsInput | string[];
    media?: productsUpdatemediaInput | string[];
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type productsUncheckedUpdateManyWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    price?: FloatFieldUpdateOperationsInput | number;
    sales_price?: FloatFieldUpdateOperationsInput | number;
    fine?: FloatFieldUpdateOperationsInput | number;
    deposit?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    fine_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    color?: NullableStringFieldUpdateOperationsInput | string | null;
    type?: NullableStringFieldUpdateOperationsInput | string | null;
    barcode?: NullableStringFieldUpdateOperationsInput | string | null;
    brand?: NullableStringFieldUpdateOperationsInput | string | null;
    size?: NullableStringFieldUpdateOperationsInput | string | null;
    stock?: FloatFieldUpdateOperationsInput | number;
    current_rented_stock?: FloatFieldUpdateOperationsInput | number;
    keywords?: productsUpdatekeywordsInput | string[];
    media?: productsUpdatemediaInput | string[];
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type terms_and_conditionsUpdateWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type terms_and_conditionsUncheckedUpdateWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type terms_and_conditionsUncheckedUpdateManyWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_collectionsUpdateWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_mode?: payment_modesUpdateOneWithoutPayment_collectionsNestedInput;
    rental?: rentalsUpdateOneWithoutPayment_collectionsNestedInput;
  };

  export type payment_collectionsUncheckedUpdateWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rental_id?: StringFieldUpdateOperationsInput | string;
    payment_mode_id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_collectionsUncheckedUpdateManyWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rental_id?: StringFieldUpdateOperationsInput | string;
    payment_mode_id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_modesUpdateWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_collections?: payment_collectionsUpdateManyWithoutPayment_modeNestedInput;
    rentals?: rentalsUpdateManyWithoutPayment_modeNestedInput;
  };

  export type payment_modesUncheckedUpdateWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_collections?: payment_collectionsUncheckedUpdateManyWithoutPayment_modeNestedInput;
    rentals?: rentalsUncheckedUpdateManyWithoutPayment_modeNestedInput;
  };

  export type payment_modesUncheckedUpdateManyWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type customersUpdateWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: customersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    rentals?: rentalsUpdateManyWithoutUserNestedInput;
  };

  export type customersUncheckedUpdateWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: customersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    rentals?: rentalsUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type customersUncheckedUpdateManyWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: customersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ownersUpdateWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: ownersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ownersUncheckedUpdateWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: ownersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ownersUncheckedUpdateManyWithoutFirmInput = {
    id?: StringFieldUpdateOperationsInput | string;
    full_name?: NullableStringFieldUpdateOperationsInput | string | null;
    mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    email?: NullableStringFieldUpdateOperationsInput | string | null;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    username?: NullableStringFieldUpdateOperationsInput | string | null;
    alternate_mobile?: NullableStringFieldUpdateOperationsInput | string | null;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    documents?: ownersUpdatedocumentsInput | string[];
    city?: NullableStringFieldUpdateOperationsInput | string | null;
    state?: NullableStringFieldUpdateOperationsInput | string | null;
    country?: NullableStringFieldUpdateOperationsInput | string | null;
    pin_code?: NullableStringFieldUpdateOperationsInput | string | null;
    adhaar_number?: NullableStringFieldUpdateOperationsInput | string | null;
    driving_license_number?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_collectionsCreateManyPayment_modeInput = {
    id?: string;
    rental_id: string;
    firm_id: string;
    amount?: number;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type rentalsCreateManyPayment_modeInput = {
    id?: string;
    user_id: string;
    invoice_id: string;
    invoice_date?: Date | string;
    invoice_status?: $Enums.InvoiceStatus;
    rental_period?: $Enums.Period;
    discount_amount?: number;
    pending_amount?: number;
    advance_amount?: number;
    deposit_amount?: number;
    paid_amount?: number;
    total_amount?: number;
    fine_amount?: number;
    rental_products?: rentalsCreaterental_productsInput | InputJsonValue[];
    active_flag?: boolean;
    delete_flag?: boolean;
    created_by?: string | null;
    created_at?: Date | string;
    modified_at?: Date | string;
    modified_by?: string | null;
  };

  export type payment_collectionsUpdateWithoutPayment_modeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    firm?: firmsUpdateOneWithoutPayment_collectionsNestedInput;
    rental?: rentalsUpdateOneWithoutPayment_collectionsNestedInput;
  };

  export type payment_collectionsUncheckedUpdateWithoutPayment_modeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rental_id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_collectionsUncheckedUpdateManyWithoutPayment_modeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rental_id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type rentalsUpdateWithoutPayment_modeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    invoice_id?: StringFieldUpdateOperationsInput | string;
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice_status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    discount_amount?: FloatFieldUpdateOperationsInput | number;
    pending_amount?: FloatFieldUpdateOperationsInput | number;
    advance_amount?: FloatFieldUpdateOperationsInput | number;
    deposit_amount?: FloatFieldUpdateOperationsInput | number;
    paid_amount?: FloatFieldUpdateOperationsInput | number;
    total_amount?: FloatFieldUpdateOperationsInput | number;
    fine_amount?: FloatFieldUpdateOperationsInput | number;
    rental_products?: rentalsUpdaterental_productsInput | InputJsonValue[];
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_collections?: payment_collectionsUpdateManyWithoutRentalNestedInput;
    user?: customersUpdateOneWithoutRentalsNestedInput;
  };

  export type rentalsUncheckedUpdateWithoutPayment_modeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: StringFieldUpdateOperationsInput | string;
    invoice_id?: StringFieldUpdateOperationsInput | string;
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice_status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    discount_amount?: FloatFieldUpdateOperationsInput | number;
    pending_amount?: FloatFieldUpdateOperationsInput | number;
    advance_amount?: FloatFieldUpdateOperationsInput | number;
    deposit_amount?: FloatFieldUpdateOperationsInput | number;
    paid_amount?: FloatFieldUpdateOperationsInput | number;
    total_amount?: FloatFieldUpdateOperationsInput | number;
    fine_amount?: FloatFieldUpdateOperationsInput | number;
    rental_products?: rentalsUpdaterental_productsInput | InputJsonValue[];
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    payment_collections?: payment_collectionsUncheckedUpdateManyWithoutRentalNestedInput;
  };

  export type rentalsUncheckedUpdateManyWithoutPayment_modeInput = {
    id?: StringFieldUpdateOperationsInput | string;
    user_id?: StringFieldUpdateOperationsInput | string;
    invoice_id?: StringFieldUpdateOperationsInput | string;
    invoice_date?: DateTimeFieldUpdateOperationsInput | Date | string;
    invoice_status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus;
    rental_period?: EnumPeriodFieldUpdateOperationsInput | $Enums.Period;
    discount_amount?: FloatFieldUpdateOperationsInput | number;
    pending_amount?: FloatFieldUpdateOperationsInput | number;
    advance_amount?: FloatFieldUpdateOperationsInput | number;
    deposit_amount?: FloatFieldUpdateOperationsInput | number;
    paid_amount?: FloatFieldUpdateOperationsInput | number;
    total_amount?: FloatFieldUpdateOperationsInput | number;
    fine_amount?: FloatFieldUpdateOperationsInput | number;
    rental_products?: rentalsUpdaterental_productsInput | InputJsonValue[];
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_collectionsCreateManyRentalInput = {
    id?: string;
    firm_id: string;
    payment_mode_id: string;
    amount?: number;
    description?: string | null;
    active_flag?: boolean;
    delete_flag?: boolean;
    modified_at?: Date | string;
    created_at?: Date | string;
    created_by?: string | null;
    modified_by?: string | null;
  };

  export type payment_collectionsUpdateWithoutRentalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
    firm?: firmsUpdateOneWithoutPayment_collectionsNestedInput;
    payment_mode?: payment_modesUpdateOneWithoutPayment_collectionsNestedInput;
  };

  export type payment_collectionsUncheckedUpdateWithoutRentalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    payment_mode_id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type payment_collectionsUncheckedUpdateManyWithoutRentalInput = {
    id?: StringFieldUpdateOperationsInput | string;
    firm_id?: StringFieldUpdateOperationsInput | string;
    payment_mode_id?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    active_flag?: BoolFieldUpdateOperationsInput | boolean;
    delete_flag?: BoolFieldUpdateOperationsInput | boolean;
    modified_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string;
    created_by?: NullableStringFieldUpdateOperationsInput | string | null;
    modified_by?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
